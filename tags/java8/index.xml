<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java8 on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/tags/java8/</link>
        <description>Recent content in Java8 on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Fri, 03 Apr 2020 09:21:43 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/tags/java8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Lamda</title>
        <link>https://mikeLing-qx.github.io/p/lamda/</link>
        <pubDate>Fri, 03 Apr 2020 09:21:43 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/lamda/</guid>
        <description>&lt;h1 id=&#34;1-函数式接口&#34;&gt;1. 函数式接口
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;函数接口是==只有一个抽象方法的接口==，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;11-常用的函数式接口&#34;&gt;1.1 常用的函数式接口
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221124154243782.png&#34;
	width=&#34;950&#34;
	height=&#34;369&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221124154243782&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;257&#34;
		data-flex-basis=&#34;617px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        Predicate&amp;lt;Integer&amp;gt; predicate = x -&amp;gt; x &amp;gt; 185;
        Student student = new Student(&amp;quot;9龙&amp;quot;, 23, 175);
        System.out.println(
            &amp;quot;9龙的身高高于185吗？：&amp;quot; + predicate.test(student.getStature()));

        Consumer&amp;lt;String&amp;gt; consumer = System.out::println;
        consumer.accept(&amp;quot;命运由我不由天&amp;quot;);

        Function&amp;lt;Student, String&amp;gt; function = Student::getName;
        String name = function.apply(student);
        System.out.println(name);

        Supplier&amp;lt;Integer&amp;gt; supplier = 
            () -&amp;gt; Integer.valueOf(BigDecimal.TEN.toString());
        System.out.println(supplier.get());

        UnaryOperator&amp;lt;Boolean&amp;gt; unaryOperator = uglily -&amp;gt; !uglily;
        Boolean apply2 = unaryOperator.apply(true);
        System.out.println(apply2);

        BinaryOperator&amp;lt;Integer&amp;gt; operator = (x, y) -&amp;gt; x * y;
        Integer integer = operator.apply(2, 3);
        System.out.println(integer);

        test(() -&amp;gt; &amp;quot;我是一个演示的函数式接口&amp;quot;);
    }

    /**
     * 演示自定义函数式接口使用
     *
     * @param worker
     */
    public static void test(Worker worker) {
        String work = worker.work();
        System.out.println(work);
    }

    public interface Worker {
        String work();
    }
}
//9龙的身高高于185吗？：false
//命运由我不由天
//9龙
//10
//false
//6
//我是一个演示的函数式接口

Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-惰性求值-及早求值&#34;&gt;1.2 惰性求值, 及早求值
&lt;/h2&gt;&lt;p&gt;惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。&lt;/p&gt;
&lt;p&gt;及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。&lt;/p&gt;
&lt;h1 id=&#34;2-常用流&#34;&gt;2. 常用流
&lt;/h1&gt;&lt;h2 id=&#34;20-创建流&#34;&gt;2.0 创建流
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221212105100904.png&#34;
	width=&#34;720&#34;
	height=&#34;472&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221212105100904&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;152&#34;
		data-flex-basis=&#34;366px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;单列集合: 集合对象.stream();&lt;/p&gt;
&lt;p&gt;数组: Arrays.stream(arr) 和 Stream.of(arr)&lt;/p&gt;
&lt;p&gt;双列集合: 转换成单列集合后再创建&lt;/p&gt;
&lt;p&gt;==peek 中间操作符, 可以用来调试==&lt;/p&gt;
&lt;h2 id=&#34;21-collectcollectorstolist&#34;&gt;2.1 collect(Collectors.toList())
&lt;/h2&gt;&lt;p&gt;将流转换为list。还有toSet()，toMap()等。及早求值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; studentList = Stream.of(new Student(&amp;quot;路飞&amp;quot;, 22, 175),
                new Student(&amp;quot;红发&amp;quot;, 40, 180),
                new Student(&amp;quot;白胡子&amp;quot;, 50, 185)).collect(Collectors.toList());
        System.out.println(studentList);
    }
}
//输出结果
//[Student{name=&#39;路飞&#39;, age=22, stature=175, specialities=null}, 
//Student{name=&#39;红发&#39;, age=40, stature=180, specialities=null}, 
//Student{name=&#39;白胡子&#39;, age=50, stature=185, specialities=null}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-filter&#34;&gt;2.2 filter
&lt;/h2&gt;&lt;p&gt;起过滤筛选的作用。==符合条件(为true)才能保存在流当中, 内部就是Predicate接口==。惰性求值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        List&amp;lt;Student&amp;gt; list = students.stream()
            .filter(stu -&amp;gt; stu.getStature() &amp;lt; 180)
            .collect(Collectors.toList());
        System.out.println(list);
    }
}
//输出结果
//[Student{name=&#39;路飞&#39;, age=22, stature=175, specialities=null}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23-map&#34;&gt;2.3 map
&lt;/h2&gt;&lt;p&gt;==内部就是Function接口.== 惰性求值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        List&amp;lt;String&amp;gt; names = students.stream().map(student -&amp;gt; student.getName())
                .collect(Collectors.toList());
        System.out.println(names);
    }
}
//输出结果
//[路飞, 红发, 白胡子]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-flatmap&#34;&gt;2.4 flatMap
&lt;/h2&gt;&lt;p&gt;==将多个Stream 合并成一个 Stream==, 惰性求值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221124155110782.png&#34;
	width=&#34;443&#34;
	height=&#34;122&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221124155110782&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;871px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        List&amp;lt;Student&amp;gt; studentList = Stream.of(students,
                asList(new Student(&amp;quot;艾斯&amp;quot;, 25, 183),
                        new Student(&amp;quot;雷利&amp;quot;, 48, 176)))
                .flatMap(students1 -&amp;gt; students1.stream()).collect(Collectors.toList());
        System.out.println(studentList);
    }
}
//输出结果
//[Student{name=&#39;路飞&#39;, age=22, stature=175, specialities=null}, 
//Student{name=&#39;红发&#39;, age=40, stature=180, specialities=null}, 
//Student{name=&#39;白胡子&#39;, age=50, stature=185, specialities=null}, 
//Student{name=&#39;艾斯&#39;, age=25, stature=183, specialities=null},
//Student{name=&#39;雷利&#39;, age=48, stature=176, specialities=null}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;25-max-min&#34;&gt;2.5 max min
&lt;/h2&gt;&lt;p&gt;集合中求最大最小值, 及早求值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        Optional&amp;lt;Student&amp;gt; max = students.stream()
            .max(Comparator.comparing(stu -&amp;gt; stu.getAge()));
        Optional&amp;lt;Student&amp;gt; min = students.stream()
            .min(Comparator.comparing(stu -&amp;gt; stu.getAge()));
        //判断是否有值
        if (max.isPresent()) {
            System.out.println(max.get());
        }
        if (min.isPresent()) {
            System.out.println(min.get());
        }
    }
}
//输出结果
//Student{name=&#39;白胡子&#39;, age=50, stature=185, specialities=null}
//Student{name=&#39;路飞&#39;, age=22, stature=175, specialities=null}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;jmax, min 接受一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;26-count&#34;&gt;2.6 count
&lt;/h2&gt;&lt;p&gt;一般结合filter 使用, 及早求值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        long count = students.stream().filter(s1 -&amp;gt; s1.getAge() &amp;lt; 45).count();
        System.out.println(&amp;quot;年龄小于45岁的人数是：&amp;quot; + count);
    }
}
//输出结果
//年龄小于45岁的人数是：2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27--distinct&#34;&gt;2.7  distinct
&lt;/h2&gt;&lt;p&gt;本质是通过equals方法和hashcode 判断是否是同个对象, 中间方法&lt;/p&gt;
&lt;h2 id=&#34;28-sorted&#34;&gt;2.8 sorted
&lt;/h2&gt;&lt;p&gt;两个重载方法&lt;/p&gt;
&lt;p&gt;元素对象实现comparable接口, 或者调用时传入&lt;/p&gt;
&lt;h2 id=&#34;29-limit&#34;&gt;2.9 limit
&lt;/h2&gt;&lt;p&gt;设置最大长度, 可以大于集合长度, 多出会被移除&lt;/p&gt;
&lt;h2 id=&#34;30-skip&#34;&gt;3.0 skip
&lt;/h2&gt;&lt;p&gt;跳过流中的前n个元素, 返回剩下的元素&lt;/p&gt;
&lt;h2 id=&#34;28-reduce&#34;&gt;2.8 reduce
&lt;/h2&gt;&lt;p&gt;对流中的数据按照你指定的计算方式得到一个结果, 可以传入一个初始化值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{@code
	U result = identity;
	for (T element : this stream)
		result = accumulator.apply(result, element)
	return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221212183613671.png&#34;
	width=&#34;485&#34;
	height=&#34;96&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221212183613671&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;505&#34;
		data-flex-basis=&#34;1212px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;==实现从一组值中生成一个值==, 上述中的max, min, count 这些方法都是reduce, 及早求值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221125112751287.png&#34;
	width=&#34;391&#34;
	height=&#34;285&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221125112751287&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;329px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestCase {
    public static void main(String[] args) {
        Integer reduce = Stream.of(1, 2, 3, 4).reduce(0, (acc, x) -&amp;gt; acc+ x);
        System.out.println(reduce);
    }
}
//输出结果
//10
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;reduce接收了一个==初始值为0的累加器==，依次取出值与累加器相加，最后累加器的值就是最终的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;3-高级集合类及收集器&#34;&gt;3. 高级集合类及收集器
&lt;/h1&gt;&lt;h2 id=&#34;31-转换成值&#34;&gt;3.1. 转换成值
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;收集器: 一种通用的, 从流生成复杂值的结构,  &lt;strong&gt;收集器可以从 java.util.stream.Collectors 类中静态导入的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CollectorsTest {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students1 = new ArrayList&amp;lt;&amp;gt;(3);
        students1.add(new Student(&amp;quot;路飞&amp;quot;, 23, 175));
        students1.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students1.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

        OutstandingClass ostClass1 = new OutstandingClass(&amp;quot;一班&amp;quot;, students1);
        //复制students1，并移除一个学生
        List&amp;lt;Student&amp;gt; students2 = new ArrayList&amp;lt;&amp;gt;(students1);
        students2.remove(1);
        OutstandingClass ostClass2 = new OutstandingClass(&amp;quot;二班&amp;quot;, students2);
        //将ostClass1、ostClass2转换为Stream
        Stream&amp;lt;OutstandingClass&amp;gt; classStream = Stream.of(ostClass1, ostClass2);
        OutstandingClass outstandingClass = biggestGroup(classStream);
        System.out.println(&amp;quot;人数最多的班级是：&amp;quot; + outstandingClass.getName());

        System.out.println(&amp;quot;一班平均年龄是：&amp;quot; + averageNumberOfStudent(students1));
    }

    /**
     * 获取人数最多的班级
     */
    private static OutstandingClass biggestGroup(Stream&amp;lt;OutstandingClass&amp;gt; outstandingClasses) {
        return outstandingClasses.collect(
                maxBy(comparing(ostClass -&amp;gt; ostClass.getStudents().size())))
                .orElseGet(OutstandingClass::new);
    }

    /**
     * 计算平均年龄
     */
    private static double averageNumberOfStudent(List&amp;lt;Student&amp;gt; students) {
        return students.stream().collect(averagingInt(Student::getAge));
    }
}
//输出结果
//人数最多的班级是：一班
//一班平均年龄是：37.666666666666664
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-转换成块-partitioningby&#34;&gt;3.2. 转换成块 partitioningBy
&lt;/h2&gt;&lt;p&gt;将流分解成两个集合, Collectors.partitioningBy 接受一个==Predicate 函数式接口==&lt;/p&gt;
&lt;p&gt;分成两块 一个 true 一块, false 一块&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221125115926929.png&#34;
	width=&#34;513&#34;
	height=&#34;278&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221125115926929&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;442px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PartitioningByTest {
    public static void main(String[] args) {
        //省略List&amp;lt;student&amp;gt; students的初始化
        Map&amp;lt;Boolean, List&amp;lt;Student&amp;gt;&amp;gt; listMap = students.stream().collect(
            Collectors.partitioningBy(student -&amp;gt; student.getSpecialities().
                                      contains(SpecialityEnum.SING)));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-数据分组-groupingby&#34;&gt;3.2 数据分组 groupingBy
&lt;/h2&gt;&lt;p&gt;==Collectors.groupingBy== 接受一个Function 做转换; 与sql 中的 group by 操作是一样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/lamda/images/image-20221125120437684.png&#34;
	width=&#34;501&#34;
	height=&#34;264&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221125120437684&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GroupingByTest {
    public static void main(String[] args) {
        //省略List&amp;lt;student&amp;gt; students的初始化
         Map&amp;lt;SpecialityEnum, List&amp;lt;Student&amp;gt;&amp;gt; listMap = 
             students.stream().collect(
             Collectors.groupingBy(student -&amp;gt; student.getSpecialities().get(0)));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 按照字符串长度进行分组    符合条件的元素将组成一个 List 映射到以条件长度为key 的 Map&amp;lt;Integer, List&amp;lt;String&amp;gt;&amp;gt; 中
servers.stream().collect(Collectors.groupingBy(String::length))

// 上面的写法等同于
Supplier&amp;lt;Map&amp;lt;Integer,List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; mapSupplier = HashMap::new;
        Map&amp;lt;Integer,List&amp;lt;String&amp;gt;&amp;gt; collect = servers.stream().collect(Collectors.groupingBy(String::length, mapSupplier, Collectors.toSet()));

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-字符串拼接-joining&#34;&gt;3.4 字符串拼接 joining
&lt;/h2&gt;&lt;p&gt;通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JoiningTest {
    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(3);
        students.add(new Student(&amp;quot;路飞&amp;quot;, 22, 175));
        students.add(new Student(&amp;quot;红发&amp;quot;, 40, 180));
        students.add(new Student(&amp;quot;白胡子&amp;quot;, 50, 185));

         String names = students.stream()
             .map(Student::getName).collect(Collectors.joining(&amp;quot;,&amp;quot;,&amp;quot;[&amp;quot;,&amp;quot;]&amp;quot;));
        System.out.println(names);
    }
}
//输出结果
//[路飞,红发,白胡子]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;35-collectingandthen&#34;&gt;3.5 collectingAndThen
&lt;/h2&gt;&lt;p&gt;该方法先执行了一个归纳操作，然后再对归纳的结果进行 &lt;code&gt;Function&lt;/code&gt; 函数处理输出一个新的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;servers.stream.collect(Collectors.collectingAndThen(Collectors.joining(&amp;quot;,&amp;quot;), String::toUpperCase));
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
