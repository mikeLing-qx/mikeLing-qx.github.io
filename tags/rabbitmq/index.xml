<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>RabbitMq on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/tags/rabbitmq/</link>
        <description>Recent content in RabbitMq on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Thu, 10 Aug 2023 16:15:39 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>RabbitMq_2</title>
        <link>https://mikeLing-qx.github.io/p/rabbitmq_2/</link>
        <pubDate>Thu, 10 Aug 2023 16:15:39 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/rabbitmq_2/</guid>
        <description>&lt;h1 id=&#34;rabbitmq高级特性二&#34;&gt;RabbitMQ高级特性（二）
&lt;/h1&gt;&lt;p&gt;课程回顾：消息队列MQ&lt;/p&gt;
&lt;p&gt;1、MQ的介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念：消息队列，在消息传输过程中用来&lt;strong&gt;保存消息的容器&lt;/strong&gt;。 目的：完成应用间的相互通信。&lt;/li&gt;
&lt;li&gt;使用场景：
&lt;ul&gt;
&lt;li&gt;业务的解耦&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;li&gt;流量削峰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产品：ActiveMQ、RabbitMQ、RocketMQ、Kafka&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、RabbitMQ介绍以及安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍：略（erlang语言开发的）&lt;/li&gt;
&lt;li&gt;安装：先安装erlang开发环境   +    再RabbitMQ【计算机名称不能为中文的】&lt;/li&gt;
&lt;li&gt;配置：用户名  、 虚拟主机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、RabbitMQ入门程序：使用的是MQ的简单模式&lt;/p&gt;
&lt;p&gt;4、RabbitMQ的通信方式：五种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单模式&lt;/li&gt;
&lt;li&gt;工作模式&lt;/li&gt;
&lt;li&gt;P/S模式：fanout，广播&lt;/li&gt;
&lt;li&gt;路由模式：Direct，定向      将消息进行分类，将消息发送到各个满足条件的队列中&lt;/li&gt;
&lt;li&gt;主题模式：Topic，主题        将消息进行分类，路由器是进行匹配规则    *：0个1个  #：0个1个多个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5、SpringBoot集成RabbitMQ【目的：减少代码开发】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写生产者：略&lt;/li&gt;
&lt;li&gt;编写消费者：编写监听器     @RabbitListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;课程计划：&lt;/p&gt;
&lt;p&gt;1、消息的可靠性投递&lt;/p&gt;
&lt;p&gt;2、消费端ack【确认】机制&lt;/p&gt;
&lt;p&gt;3、消费端限流&lt;/p&gt;
&lt;p&gt;4、延时队列【TTL、DLX】&lt;/p&gt;
&lt;p&gt;5、RabbitMQ相关应用问题【了解】&lt;/p&gt;
&lt;p&gt;6、RabbitMQ集群【了解】   运维人员&lt;/p&gt;
&lt;h1 id=&#34;1-消息的可靠性投递&#34;&gt;1 消息的可靠性投递
&lt;/h1&gt;&lt;h2 id=&#34;11-什么是可靠性投递&#34;&gt;1.1 什么是可靠性投递
&lt;/h2&gt;&lt;p&gt;在使用RabbitMQ的时候，作为消息的发送方希望杜绝任何&lt;strong&gt;消息丢失或者投递失败&lt;/strong&gt;的场景。如果消息投递失败，RabbitMQ为我们提供了两种模式用来控制消息的可靠投递。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;confirm：确认模式&lt;/li&gt;
&lt;li&gt;return：退回模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;我们都知道MQ消息投递的流程，producer&amp;mdash;&amp;gt;exchange&amp;mdash;&amp;gt;routingKey&amp;mdash;&amp;gt;queue&amp;mdash;&amp;gt;consumer。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589253589529.png&#34;
	width=&#34;919&#34;
	height=&#34;203&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589253589529&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;452&#34;
		data-flex-basis=&#34;1086px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么这两种模式又是如何工作的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;confirm模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要开启confirm模式&lt;/li&gt;
&lt;li&gt;消息&lt;strong&gt;从producer到达exchange&lt;/strong&gt;后，会执行一个confirmCallback回调函数&lt;/li&gt;
&lt;li&gt;该回调函数的方法中有个ack参数
&lt;ul&gt;
&lt;li&gt;ack = true，则发送成功&lt;/li&gt;
&lt;li&gt;ack = false，则发送失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;return模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要开启return模式&lt;/li&gt;
&lt;li&gt;消息从exchange路由到queue后
&lt;ul&gt;
&lt;li&gt;如果投递成功，不会执行一个returnCallback回调函数&lt;/li&gt;
&lt;li&gt;如果投递失败，则会执行一个returnCallback回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-confirm模式&#34;&gt;1.2 confirm模式
&lt;/h2&gt;&lt;h3 id=&#34;121-创建工程&#34;&gt;1.2.1 创建工程
&lt;/h3&gt;&lt;p&gt;创建&lt;code&gt;&amp;lt;rabbitmq-day02-demo1-reliable&amp;gt;&lt;/code&gt;工程并且添加依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589255639549.png&#34;
	width=&#34;1129&#34;
	height=&#34;228&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589255639549&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;495&#34;
		data-flex-basis=&#34;1188px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;pom文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--起步依赖--&amp;gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;122-编写启动类&#34;&gt;1.2.2 编写启动类
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;&amp;lt;com.itheima.ReliableApplication&amp;gt;&lt;/code&gt;编写启动类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589982295928.png&#34;
	width=&#34;1401&#34;
	height=&#34;364&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589982295928&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;384&#34;
		data-flex-basis=&#34;923px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class ReliableApplication {

    public static void main(String[] args) {
        SpringApplication.run(ReliableApplication.class, args);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;123-编写创建队列的配置类&#34;&gt;1.2.3 编写创建队列的配置类
&lt;/h3&gt;&lt;p&gt;创建配置类&lt;code&gt;&amp;lt;com.itheima.config.ConfirmQueueConfig&amp;gt;&lt;/code&gt;   或者 我们也可以在启动类中创建队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589982627103.png&#34;
	width=&#34;1368&#34;
	height=&#34;667&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589982627103&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;205&#34;
		data-flex-basis=&#34;492px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class ConfirmQueueConfig {

    // 创建队列
    @Bean
    public Queue confirmQueue(){
        return new Queue(&amp;quot;confirm-queue&amp;quot;, true);
    }

    // 创建交换机
    @Bean
    public Exchange confirmExchange(){
        return new DirectExchange(&amp;quot;confirm-exchange&amp;quot;, true, false);
    }

    // 队列绑定到交换机
    @Bean
    public Binding queueBindToExchange(Queue confirmQueue, Exchange confirmExchange){
        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(&amp;quot;confirm-routing-key&amp;quot;).noargs();
    }
}
	
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;124-添加yml文件&#34;&gt;1.2.4 添加yml文件
&lt;/h3&gt;&lt;p&gt;在resources目录下添加application.yml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    # 开启confirm模式
    publisher-confirms: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589260159231.png&#34;
	width=&#34;788&#34;
	height=&#34;255&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589260159231&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;309&#34;
		data-flex-basis=&#34;741px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;125-编写单元测试&#34;&gt;1.2.5 编写单元测试
&lt;/h3&gt;&lt;p&gt;在test包下编写单元测试类：&lt;code&gt;&amp;lt;com.itheima.ReliableTest&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@RunWith(SpringRunner.class)
public class ReliableTest {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * @author 栗子
     * @Description confirm模式测试
     * @Date 13:15 2020/5/12
     * @param
     * @return void
     **/
    @Test
    public void testConfirm(){
        // 1、设置回调函数
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             * @author 栗子
             * @Description
             * @Date 13:15 2020/5/12
             * @param correlationData   其他相关属性
             * @param ack               应答，成功或失败
             * @param cause             失败原因
             * @return void
             **/
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                if (ack){
                    System.out.println(&amp;quot;我成功接收到消息了。。。&amp;quot;);
                }else {
                    System.out.println(&amp;quot;我没有接收得到消息，原因是：&amp;quot; + cause);
                }
            }
        });
        // 2-1、正确发送消息
        rabbitTemplate.convertAndSend(&amp;quot;confirm-exchange&amp;quot;, &amp;quot;confirm-routing-key&amp;quot;, &amp;quot;confirm确认模式。。。&amp;quot;);
        // 2-2、错误发送消息，我们可以指定一个不存在的交换机
        // rabbitTemplate.convertAndSend(&amp;quot;confirm-exchange-001&amp;quot;, &amp;quot;confirm-routing-key&amp;quot;, &amp;quot;confirm确认模式。。。&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;126-测试结果&#34;&gt;1.2.6 测试结果
&lt;/h3&gt;&lt;p&gt;发送消息成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589261244520.png&#34;
	width=&#34;1394&#34;
	height=&#34;545&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589261244520&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;255&#34;
		data-flex-basis=&#34;613px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;发送消息失败：&lt;strong&gt;【温馨提示：confirm模式只针对交换机，因此在测试过程中指定错误路由则callback回调函数中的ack依然为true。】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589261285720.png&#34;
	width=&#34;1403&#34;
	height=&#34;546&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589261285720&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;256&#34;
		data-flex-basis=&#34;616px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-return模式&#34;&gt;1.3 return模式
&lt;/h2&gt;&lt;h3 id=&#34;131-创建队列&#34;&gt;1.3.1 创建队列
&lt;/h3&gt;&lt;p&gt;编写创建队列的配置类&lt;code&gt;&amp;lt;com.itheima.config.ReturnQueueConfig&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class ReturnQueueConfig {

    // 创建队列
    @Bean
    public Queue returnQueue(){
        return new Queue(&amp;quot;return-queue&amp;quot;, true);
    }

    // 创建交换机
    @Bean
    public Exchange returnExchange(){
        return new DirectExchange(&amp;quot;return-exchange&amp;quot;, true, false);
    }

    // 队列绑定到交换机
    @Bean
    public Binding queueBindToExchangeByReturn(Queue returnQueue, Exchange returnExchange){
        return BindingBuilder.bind(returnQueue).to(returnExchange).with(&amp;quot;return-routing-key&amp;quot;).noargs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;132-编写yml文件&#34;&gt;1.3.2 编写yml文件
&lt;/h3&gt;&lt;p&gt;开启return模式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    # 开启confirm模式
    publisher-confirms: true
    # 开启return模式
    publisher-returns: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589266554102.png&#34;
	width=&#34;528&#34;
	height=&#34;245&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589266554102&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;517px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;133-编写单元测试&#34;&gt;1.3.3 编写单元测试
&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;&amp;lt;ReliableTest&amp;gt;&lt;/code&gt;测试类中添加方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testReturn(){
    // 1、消息处理方式 true：消息通过交换机无法匹配到队列时会返回给生产者  false：匹配不到直接丢弃消息
    //        rabbitTemplate.setMandatory(true); // 默认则为true，如果设置为false就算发送失败也不会执行callback方法，因为消息被丢弃
    // 2、设置回调函数
    rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
        /**
             * @author 栗子
             * @Description
             * @Date 15:08 2020/5/12
             * @param message    消息体
             * @param replyCode  响应码
             * @param replyText  响应信息
             * @param exchange
             * @param routingKey
             * @return void
             **/
        @Override
        public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
            System.out.println(&amp;quot;消息路由失败会执行该方法。。。&amp;quot;);
            System.out.println(&amp;quot;发送的消息体：&amp;quot; + new String(message.getBody()));
            System.out.println(&amp;quot;响应码：&amp;quot; + replyCode);
            System.out.println(&amp;quot;响应信息：&amp;quot; + replyText);
        }
    });
    // 3-1、正确发送消息
    //         rabbitTemplate.convertAndSend(&amp;quot;test-return-exchange&amp;quot;, &amp;quot;test-return-routing-key&amp;quot;, &amp;quot;return退回模式。。。&amp;quot;);
    // 3-2、错误发送消息，我们可以指定一个不存在的路由
    rabbitTemplate.convertAndSend(&amp;quot;test-return-exchange&amp;quot;, &amp;quot;test-return-routing-key-001&amp;quot;, &amp;quot;return退回模式。。。&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;134-测试结果&#34;&gt;1.3.4 测试结果
&lt;/h3&gt;&lt;p&gt;PS：当程序中指定一个不存在的routingKey的时候，发送失败则会触发returnCallback回调方法。（温馨提示：指定错误的exchange无效。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589267616853.png&#34;
	width=&#34;1693&#34;
	height=&#34;561&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589267616853&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;301&#34;
		data-flex-basis=&#34;724px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;14-总结&#34;&gt;1.4 总结
&lt;/h2&gt;&lt;p&gt;1、confirm确认模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启confirm模式（application.yml   &lt;strong&gt;spring.publisher-confirms=true&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;设置回调函数：rabbitTemplate.setConfirmCallback
&lt;ul&gt;
&lt;li&gt;若ack=true，消息投递成功&lt;/li&gt;
&lt;li&gt;若ack=false，消息投递失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、return退回模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启return模式（application.yml   &lt;strong&gt;spring.publisher-returns=true&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;设置消息处理方式：rabbitTemplate.setMandatory(true) 【可以省略，默认为true。】&lt;/li&gt;
&lt;li&gt;设置回调函数：rabbitTemplate.setReturnCallback
&lt;ul&gt;
&lt;li&gt;投递失败，则会执行该方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-消费端ack机制&#34;&gt;2 消费端ack机制
&lt;/h1&gt;&lt;h2 id=&#34;21-什么是ack&#34;&gt;2.1 什么是ack
&lt;/h2&gt;&lt;p&gt;在第一章节中我们就生产者发送消息如何保证消息可靠性投递进行了处理，也就是说需要保证消息能够成功发送到broker中，但是如果消费者消费消息失败那又该如何处理呢？&lt;/p&gt;
&lt;p&gt;如果在处理消息的过程中，消费者的服务在处理消息的时候出现异常，那么可能这条正在处理的消息就没有完成消息消费，数据就会丢失。为了确保数据不会丢失，RabbitMQ支持&lt;strong&gt;确认机制&lt;/strong&gt;ACK （Acknowledge）。&lt;/p&gt;
&lt;p&gt;消费端接收到消息后有三种ack方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动确认：ack = &amp;ldquo;none&amp;rdquo;&lt;/li&gt;
&lt;li&gt;手动确认：ack = &amp;ldquo;manual&amp;rdquo;&lt;/li&gt;
&lt;li&gt;根据异常确认（少，不考虑）：ack = &amp;ldquo;auto&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动确认是指，消息一旦被consumer接收到则自动确认收到，并将相应的message从RabbitMQ的消息缓存中移除。但是在实际的业务处理中，很可能是消息被接收到了，但是业务处理出现了异常，那么消息从缓存中移除即该消息就被丢弃了。如果设置了手动确认，则需要在业务处理成功后，调用&lt;strong&gt;channel.basicAck()方法手动签收&lt;/strong&gt;，如果出现了异常，则调用&lt;strong&gt;channel.basicNack()方法，让其自动重发消息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总结：ack机制，确认机制（消费者对mq中的消息进行确认）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手动确认，获取到消息&amp;mdash;&amp;gt;消费消息【处理业务】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费成功：签收   &lt;strong&gt;channel.basicAck(id, true)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;消费失败：将消息重回队列中  &lt;strong&gt;channel.basicNack()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-ack代码实现&#34;&gt;2.2 ack代码实现
&lt;/h2&gt;&lt;h3 id=&#34;221-创建工程&#34;&gt;2.2.1 创建工程
&lt;/h3&gt;&lt;p&gt;创建工程&lt;code&gt;&amp;lt;rabbitmq-day02-demo2-ack&amp;gt;&lt;/code&gt;并且添加依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589272481648.png&#34;
	width=&#34;1106&#34;
	height=&#34;189&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589272481648&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;585&#34;
		data-flex-basis=&#34;1404px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;pom.xml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--起步依赖--&amp;gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;222-编写启动类&#34;&gt;2.2.2 编写启动类
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589272614817.png&#34;
	width=&#34;1190&#34;
	height=&#34;353&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589272614817&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;337&#34;
		data-flex-basis=&#34;809px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class AckApplication {

    public static void main(String[] args) {
        SpringApplication.run(AckApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;223-添加applicationyml文件&#34;&gt;2.2.3 添加application.yml文件
&lt;/h3&gt;&lt;p&gt;在resources目录下添加yml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    # 消息确认方式
    listener:
      simple:
        acknowledge-mode: manual  # 手动确认
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;224-编写监听器&#34;&gt;2.2.4 编写监听器
&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;&amp;lt;com.itheima.listener&amp;gt;包下创建AckListener监听器&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queues = {&amp;quot;confirm-queue&amp;quot;})
public class AckListener {

    @RabbitHandler
    public void readMsg(String msg, Message message, Channel channel){
        System.out.println(&amp;quot;获取到的消息体：&amp;quot; + new String(message.getBody()));
        long id = message.getMessageProperties().getDeliveryTag();
        try {
            System.out.println(&amp;quot;业务处理成功...&amp;quot;);
            // 业务处理成功：手动签收
            channel.basicAck(id, true);
        } catc h (Exception e) {
            System.out.println(&amp;quot;业务处理失败...&amp;quot;);
            try {
                Thread.sleep(2000); // 消息每隔2s发送一次
                // 业务处理失败：拒收，并且让消息重回队列
                channel.basicNack(id, true, true);
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;225-测试&#34;&gt;2.2.5 测试
&lt;/h3&gt;&lt;p&gt;我们可以模拟一个业务处理失败的场景。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589986335087.png&#34;
	width=&#34;953&#34;
	height=&#34;596&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589986335087&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;383px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-总结&#34;&gt;2.3 总结
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;MQ消息的可靠性：
1、持久化：exchange、queue、message都需要持久化
2、生产者确保消息被成功发送，confirm
3、消费者保证消息被消费，ack
4、搭建Broker(mq服务)的高可用性
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-消费端限流&#34;&gt;3 消费端限流
&lt;/h1&gt;&lt;h2 id=&#34;31-限流介绍&#34;&gt;3.1 限流介绍
&lt;/h2&gt;&lt;p&gt;如果并发访问量大的情况下，生产方不停的发送消息，消费端可能处理不了那么多消息，此时消息在队列中堆积很多，当消费端启动，瞬间就会涌入很多消息，消费端有可能瞬间垮掉，这时我们可以在消费端进行限流操作，每秒钟拉取多少个消息。这样就可以进行并发量的控制，减轻系统的负载，提供系统的可用性，这种效果往往可以在秒杀和抢购中进行使用。rabbitmq中有限流的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589288254017.png&#34;
	width=&#34;770&#34;
	height=&#34;372&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589288254017&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;206&#34;
		data-flex-basis=&#34;496px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-代码实现&#34;&gt;3.2 代码实现
&lt;/h2&gt;&lt;h3 id=&#34;321-开启限流&#34;&gt;3.2.1 开启限流
&lt;/h3&gt;&lt;p&gt;这里我们就不在单独的去创建工程了，我们在&lt;code&gt;&amp;lt;rabbitmq-day02-demo2-ack&amp;gt;&lt;/code&gt;工程中application.yml中添加限流配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    # 确认方式
    listener:
      simple:
        acknowledge-mode: manual
        # 每次最多处理消息的个数
        prefetch: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589986639903.png&#34;
	width=&#34;713&#34;
	height=&#34;293&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589986639903&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;584px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;322-单元测试&#34;&gt;3.2.2 单元测试
&lt;/h3&gt;&lt;h4 id=&#34;3221-发送n条消息&#34;&gt;3.2.2.1 发送n条消息
&lt;/h4&gt;&lt;p&gt;在&lt;code&gt;&amp;lt;rabbitmq-day02-demo1-reliable&amp;gt;工程的测试类ReliableTest中添加测试方法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 发送10条消息
@Test
public void testSendMsg(){
    for (int i = 1; i &amp;lt;= 10; i++) {
        rabbitTemplate.convertAndSend(&amp;quot;confirm-exchange&amp;quot;, &amp;quot;confirm-routing-key&amp;quot;, &amp;quot;发送消息：&amp;quot; + i);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3222-修改监听器代码&#34;&gt;3.2.2.2 修改监听器代码
&lt;/h4&gt;&lt;p&gt;修改&lt;code&gt;&amp;lt;rabbitmq-day02-demo2-ack&amp;gt;&lt;/code&gt;工程中监听器代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除异常代码&lt;code&gt;&amp;lt;System.out.println(9/0)&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;并且在try代码块让程序进行休眠，例如：休眠5s&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queues = {&amp;quot;confirm-queue&amp;quot;})
public class AckListener {

    @RabbitHandler
    public void readMsg(String msg, Message message, Channel channel){
        System.out.println(&amp;quot;获取到的消息体：&amp;quot; + new String(message.getBody()));
        long id = message.getMessageProperties().getDeliveryTag();
        try {
            Thread.sleep(5000);
            System.out.println(&amp;quot;业务处理成功...&amp;quot;);
            // 业务处理成功：手动签收签收
            channel.basicAck(id, true);
        } catch (Exception e) {

            System.out.println(&amp;quot;业务处理失败...&amp;quot;);
            try {
                Thread.sleep(2000); // 消息每隔2s发送一次
                // 业务处理失败：拒收，并且让消息重回队列
                channel.basicNack(id, true, true);
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3223-结果说明&#34;&gt;3.2.2.3 结果说明
&lt;/h4&gt;&lt;p&gt;生产者发送消息（没有启动消费者）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589290150555.png&#34;
	width=&#34;906&#34;
	height=&#34;124&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589290150555&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;730&#34;
		data-flex-basis=&#34;1753px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ready：待消费的消息总数，10条&lt;/li&gt;
&lt;li&gt;Unacked：待应答的消息总数，0条&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启动消费端后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589290236123.png&#34;
	width=&#34;907&#34;
	height=&#34;94&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589290236123&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;964&#34;
		data-flex-basis=&#34;2315px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ready：待消费的消息总数，5条&lt;/li&gt;
&lt;li&gt;Unacked：待应答的消息总数，5条&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-延时队列&#34;&gt;4 延时队列
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;环境搭建：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;&amp;lt;rabbitmq-day02-demo3-delay&amp;gt;&lt;/code&gt;工程并且添加依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--起步依赖--&amp;gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写启动类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class DelayApplication {

    public static void main(String[] args) {
        SpringApplication.run(DelayApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写application.yml文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;41-ttl&#34;&gt;4.1 TTL
&lt;/h2&gt;&lt;h3 id=&#34;411-概念&#34;&gt;4.1.1 概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TTL：Time To Live（存活时间/过期时间）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当消息到达存活时间后，该消息还没有被消费，会自动被清除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RabbitMQ可以对消息设置过期时间也可以对整个队列设置过期时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果都设置了，哪个时间先到则生效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;举个最常见了栗子：当我们在某个平台购买商品或者火车票、机票等，如果半个小时内没有支付，则该订单失效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589291916403.png&#34;
	width=&#34;662&#34;
	height=&#34;232&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589291916403&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;285&#34;
		data-flex-basis=&#34;684px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;412-代码实现&#34;&gt;4.1.2 代码实现
&lt;/h3&gt;&lt;h4 id=&#34;4121-创建队列&#34;&gt;4.1.2.1 创建队列
&lt;/h4&gt;&lt;p&gt;在工程中创建队列的配置类&lt;code&gt;&amp;lt;com.itheima.config.TTLConfig&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class TTLConfig {

    // 创建队列
    @Bean
    public Queue ttlQueue(){
        // 创建队列，并且指定队列的过期时间
        return QueueBuilder.durable(&amp;quot;ttl-queue&amp;quot;).withArgument(&amp;quot;x-message-ttl&amp;quot;, 10000).build();
    }

    @Bean
    public Exchange ttlExchange(){
        // 注意，由于routingkey我们使用了匹配，因此我们要创建topic类型的交换机
        return new TopicExchange(&amp;quot;ttl-exchange&amp;quot;, true, false);
    }

    // 队列绑定到交换机
    @Bean
    public Binding queueBindToExchangeByTTL(Queue ttlQueue, Exchange ttlExchange){
        return BindingBuilder.bind(ttlQueue).to(ttlExchange).with(&amp;quot;ttl.#&amp;quot;).noargs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4122-编写单元测试&#34;&gt;4.1.2.2 编写单元测试
&lt;/h4&gt;&lt;p&gt;在工程的test包下创建测试类&lt;code&gt;&amp;lt;com.itheima.DelayTest&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testTTL(){
    // 可以设置消息的属性消息
    MessagePostProcessor messagePostProcessor = new MessagePostProcessor() {
        @Override
        public Message postProcessMessage(Message message) throws AmqpException {
            // 设置消息的过期时间 5s
            message.getMessageProperties().setExpiration(&amp;quot;5000&amp;quot;);
            return message;
        }
    };
    rabbitTemplate.convertAndSend(&amp;quot;test-ttl-exchange&amp;quot;,&amp;quot;ttl.hehe&amp;quot;, &amp;quot;ttl消息&amp;quot;, messagePostProcessor);
}

PS：温馨提示，如果同时设置了队列过期时间和消息的过期时间，那么时间越短的先生效。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;413-客户端创建队列了解&#34;&gt;4.1.3 客户端创建队列【了解】
&lt;/h3&gt;&lt;p&gt;1、创建队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589294819246.png&#34;
	width=&#34;1059&#34;
	height=&#34;359&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589294819246&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;294&#34;
		data-flex-basis=&#34;707px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;2、创建交换机&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589294871233.png&#34;
	width=&#34;839&#34;
	height=&#34;337&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589294871233&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;248&#34;
		data-flex-basis=&#34;597px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;3、队列绑定交换机&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589294973845.png&#34;
	width=&#34;916&#34;
	height=&#34;414&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589294973845&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;221&#34;
		data-flex-basis=&#34;531px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;4、发送消息【PS：&lt;strong&gt;Delivery mode ：2 - Persistent，指定为消息持久化&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589989186990.png&#34;
	width=&#34;917&#34;
	height=&#34;490&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589989186990&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;187&#34;
		data-flex-basis=&#34;449px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-dlx&#34;&gt;4.2 DLX
&lt;/h2&gt;&lt;h3 id=&#34;421-概念&#34;&gt;4.2.1 概念
&lt;/h3&gt;&lt;p&gt;DLX：Dead-Letter-Exchange，死信交换机。当消息成为Dead Message后，可以被重新发送到另一个交换机，这个交换机就称为死信交换机。&lt;/p&gt;
&lt;p&gt;DLX其始就是一个Exchange，和一般的Exchange没有区别，仅仅只是设置某个队列的属性而已。当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。消费端可以监听这个队列中的消息做相应的处理。&lt;/p&gt;
&lt;h3 id=&#34;422-处理过程&#34;&gt;4.2.2 处理过程
&lt;/h3&gt;&lt;p&gt;1、生成者将消息发送到交换机后，由交换机路由到指定的队列&lt;/p&gt;
&lt;p&gt;2、当该消息成为了死信后并且将该消息发送给DLX。PS：成为死信的三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列消息长度达到限制&lt;/li&gt;
&lt;li&gt;消费者拒签消息&lt;/li&gt;
&lt;li&gt;原队列中存在消息过期设置，消息到达超时时间未被消费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、DLX再将这个消息路由给死信队列，并且由对应的消费者消费&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1590042255594.png&#34;
	width=&#34;878&#34;
	height=&#34;409&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1590042255594&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;214&#34;
		data-flex-basis=&#34;515px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589341135991.png&#34;
	width=&#34;876&#34;
	height=&#34;300&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589341135991&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;700px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;423-代码实现&#34;&gt;4.2.3 代码实现
&lt;/h3&gt;&lt;p&gt;创建配置类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class DLXConfig {

    // 创建交换机
    @Bean
    public Exchange delayExchange(){
        return new DirectExchange(&amp;quot;delay-exchange&amp;quot;);
    }
    // 创建队列
    @Bean
    public Queue delayQueue(){
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;();
        args.put(&amp;quot;x-message-ttl&amp;quot;, 20000);           // 队列过期时间
        args.put(&amp;quot;x-max-length&amp;quot;, 10000000);         // 队列中消息数量
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, &amp;quot;dlx-exchange&amp;quot;);       // 绑定死信交换机
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, &amp;quot;dlx-routing-key&amp;quot;);    // 绑定死信路由器
        return QueueBuilder.durable(&amp;quot;delay-queue&amp;quot;).withArguments(args).build();
    }

    // 将队列绑定到交换机
    @Bean
    public Binding delayBinding(Queue delayQueue, Exchange delayExchange){
        return BindingBuilder.bind(delayQueue).to(delayExchange).with(&amp;quot;delay-routing-key&amp;quot;).noargs();
    }

    // 创建死信交换机
    @Bean
    public Exchange dlxExhange(){
        return new DirectExchange(&amp;quot;dlx-exchange&amp;quot;);
    }

    // 创建死信队列
    @Bean
    public Queue dlxQueue(){
        return new Queue(&amp;quot;dlx-queue&amp;quot;);
    }

    // 将死信队列绑定到死信交换机上
    @Bean
    public Binding dlxBinding(Queue dlxQueue, Exchange dlxExhange){
        return BindingBuilder.bind(dlxQueue).to(dlxExhange).with(&amp;quot;dlx-routing-key&amp;quot;).noargs();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单元测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDLX(){
    // 发送消息
    rabbitTemplate.convertAndSend(&amp;quot;delay-exchange&amp;quot;,&amp;quot;delay-routing-key&amp;quot;, &amp;quot;死信消息&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发送消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589992130599.png&#34;
	width=&#34;1061&#34;
	height=&#34;160&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589992130599&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;663&#34;
		data-flex-basis=&#34;1591px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;20S后，我们再看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589992207176.png&#34;
	width=&#34;1023&#34;
	height=&#34;161&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589992207176&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;635&#34;
		data-flex-basis=&#34;1524px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;43-延时队列&#34;&gt;4.3 延时队列
&lt;/h2&gt;&lt;h3 id=&#34;431-什么是延时队列&#34;&gt;4.3.1 什么是延时队列
&lt;/h3&gt;&lt;p&gt;延时队列，即消息进入队列后不会被立即消费，只有到达指定的时间后才会被消费。比较遗憾的是，RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL + DLX组合来实现延时队列的效果。&lt;/p&gt;
&lt;h3 id=&#34;432-需求&#34;&gt;4.3.2 需求
&lt;/h3&gt;&lt;p&gt;例如：用户下单后，30分钟内未完成支付，取消订单回滚库存。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;延时队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1590044162041.png&#34;
	width=&#34;1156&#34;
	height=&#34;298&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1590044162041&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;387&#34;
		data-flex-basis=&#34;931px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;433-代码实现&#34;&gt;4.3.3 代码实现
&lt;/h3&gt;&lt;p&gt;在【4.2章节中】我们其始已实现了延时队列了。我们只需要去监听死信队列去消费消息即可。创建监听器，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queues = {&amp;quot;dlx-queue&amp;quot;})
public class DelayListener {

    @RabbitHandler
    public void readMsg(String msg){
        SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);
        System.out.println(&amp;quot;消费消息时间：&amp;quot; + sdf.format(new Date()));
        System.out.println(&amp;quot;获取到的消息为：&amp;quot; + msg);
    }
}


// 单元测试
@Test
public void testDLX(){
    // 发送消息
    rabbitTemplate.convertAndSend(&amp;quot;delay-exchange&amp;quot;,&amp;quot;delay-routing-key&amp;quot;, &amp;quot;死信消息&amp;quot;);
    SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);
    System.out.println(&amp;quot;发送消息时间：&amp;quot; + sdf.format(new Date()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-rabbitmq应用&#34;&gt;5 RabbitMQ应用
&lt;/h1&gt;&lt;h2 id=&#34;51-日志与监控&#34;&gt;5.1 日志与监控
&lt;/h2&gt;&lt;h3 id=&#34;511-日志&#34;&gt;5.1.1 日志
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux OS下：&lt;/p&gt;
&lt;p&gt;RabbitMQ默认存放日志的路径：/var/log/rabbitmq/rabbit@xxx.log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows OS下，例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589518752061.png&#34;
	width=&#34;855&#34;
	height=&#34;184&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589518752061&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;464&#34;
		data-flex-basis=&#34;1115px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;512-管控台监控&#34;&gt;5.1.2 管控台监控
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589518528251.png&#34;
	width=&#34;1524&#34;
	height=&#34;683&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589518528251&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;535px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-消息补偿-面试&#34;&gt;5.2 消息补偿-面试
&lt;/h2&gt;&lt;p&gt;需求：100%保证消息发送成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589518181167.png&#34;
	width=&#34;1009&#34;
	height=&#34;413&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589518181167&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;586px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;53-消息幂等性保障-面试&#34;&gt;5.3 消息幂等性保障-面试
&lt;/h2&gt;&lt;p&gt;思想一样。&lt;/p&gt;
&lt;p&gt;MySql的数据库引擎：InnoDB（默认）   +   MYISAM      建表：engines=MYISAM&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构：InnoDB   B+T   B+T+链表&lt;/li&gt;
&lt;li&gt;不会进行全表扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1590045582913.png&#34;
	width=&#34;1210&#34;
	height=&#34;311&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1590045582913&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;389&#34;
		data-flex-basis=&#34;933px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;需求：数据 库存只有1件了。    显示10个人买。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁：for update&lt;/li&gt;
&lt;li&gt;**乐视锁：**需要在表设计的时候添加一个额外的字段  version（1 -2）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幂等性：指一次或多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，任意多次请求对资源本身所产生的影响均与一次请求所产生的影响相同。在MQ中，消费多条相同的消息，得到与消费该消息一次相同的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/assets/1589518408986.png&#34;
	width=&#34;1043&#34;
	height=&#34;467&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589518408986&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;536px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-rabbitmq集群-了解&#34;&gt;6 RabbitMQ集群-了解
&lt;/h1&gt;&lt;p&gt;没有意义：docker&amp;mdash;部署集群的mq&lt;/p&gt;
&lt;p&gt;注意：在学习docker的时候我们在给大家演示如何搭建集群。&lt;/p&gt;
&lt;h1 id=&#34;总结mq的高级特性&#34;&gt;总结：MQ的高级特性
&lt;/h1&gt;&lt;p&gt;1、消息的可靠性投递&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;confirm：确认模式【交换机】&lt;/li&gt;
&lt;li&gt;return：退回模式【路由器】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、消息的确认机制【ack】  消费方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动确认：略&lt;/li&gt;
&lt;li&gt;手动确认：快递送到咱手中，本人需要签字。（买了华为P30     送了MP3：拒收，消息重回队列）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、消费端限流：配置限流【每次处理消息的最大个数】&lt;/p&gt;
&lt;p&gt;4、延时队列：TTL  + DLX&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TTL：过期&lt;/li&gt;
&lt;li&gt;DLX：死信交换机   死信队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5、RabbitMQ的应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志和监控&lt;/li&gt;
&lt;li&gt;消息补偿：要求消息100%发送到队列中&lt;/li&gt;
&lt;li&gt;消息幂等性; 保障：乐视锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7-rabbit-避免重复消费&#34;&gt;7. Rabbit 避免重复消费;
&lt;/h1&gt;&lt;h1 id=&#34;8-保证消息的顺序&#34;&gt;8. 保证消息的顺序
&lt;/h1&gt;&lt;p&gt;大体来说主流的解决方案有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是使用单线程消费来保证消息的顺序性&lt;/li&gt;
&lt;li&gt;对消息进行编号，消费者处理时根据编号来判断顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;乍一看，觉得两种方案没有什么问题，但是深入了解下，觉得这两种解决方案并不能完全接保证消息的消费的顺序性问题。&lt;/p&gt;
&lt;p&gt;首先我们来分析下，是什么导致RabbitMQ消息的顺序性问题的，常见的有以下几种情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息生产者启用了发送确认机制，在发生超时、中断等，需要RabbitMQ补偿发送时，那么此时消息在源头就已经出现顺序混乱了，导致消息被消费时也是乱序的&lt;/li&gt;
&lt;li&gt;另一种情况，如果消息发送时，设置了超时时间，并且采用了死信队列，模拟了延时队列的效果，那么此时消息的顺序也时不能保证的&lt;/li&gt;
&lt;li&gt;还有一种情况，如果消息设置了优先级，那么在高并发的情况下，消息的顺序也是得不到保证的，消息的消费顺序也就不能保证了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刚才我们分析了出现消息乱序的几种情况，这里我们首先排除了实用单线程来消费，原因很简单，发送的消息的顺序（源头数据的顺序出现了异常）出现了异常，单线程消费的顺序肯定也是异常的&lt;/p&gt;
&lt;p&gt;其次对消息进行编号，这个可以解决消息顺序的问题，但是对加大了对业务处理的复杂性&lt;/p&gt;
&lt;p&gt;messageId&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_2/images/image-20220104141506541.png&#34;
	width=&#34;521&#34;
	height=&#34;368&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220104141506541&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;339px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>RabbitMq_1</title>
        <link>https://mikeLing-qx.github.io/p/rabbitmq_1/</link>
        <pubDate>Tue, 08 Aug 2023 16:15:32 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/rabbitmq_1/</guid>
        <description>&lt;h1 id=&#34;rabbitmq一&#34;&gt;RabbitMQ（一）
&lt;/h1&gt;&lt;p&gt;课程回顾：&lt;/p&gt;
&lt;p&gt;1、OpenFeign进行远程调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍
&lt;ul&gt;
&lt;li&gt;对RestTemplate进行了封装&lt;/li&gt;
&lt;li&gt;通过更加优雅的方式【客户端    编写Feign相当于编写Service】进行调用&lt;/li&gt;
&lt;li&gt;集成了负载均衡、集成了熔断器、支持日志、支持请求与响应压缩&lt;/li&gt;
&lt;li&gt;代码实现：略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、SpringCloudGateway网关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景：鉴权操作、认证操作、记录日志、限流等等&lt;/li&gt;
&lt;li&gt;网关介绍：
&lt;ul&gt;
&lt;li&gt;路由：转发到哪个服务上&lt;/li&gt;
&lt;li&gt;断言：匹配具体的url地址&lt;/li&gt;
&lt;li&gt;过滤器：在本次的请求中，通过过滤器完成一些限制（业务需求）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;局部过滤器&lt;/li&gt;
&lt;li&gt;全局过滤器&lt;/li&gt;
&lt;li&gt;官方自带的过滤器&lt;/li&gt;
&lt;li&gt;自定义过滤器：
&lt;ul&gt;
&lt;li&gt;全局过滤器：实现GlobalFilter接口，还可以实现Ordered接口，指定过滤器的执行顺序的【代替该接口：@Order注解】&lt;/li&gt;
&lt;li&gt;局部过滤器：
&lt;ul&gt;
&lt;li&gt;继承AbstractGatewayFilterFactory&lt;/li&gt;
&lt;li&gt;自定义过滤器的名称规范：XxxGatewayFilterFactory&lt;/li&gt;
&lt;li&gt;需要在yml文件中配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、SpringCloudConfig：配置中心&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置中心：管理服务中的配置文件的&lt;/li&gt;
&lt;li&gt;执行流程：托管平台（码云/GitHub）&amp;mdash;&amp;gt;配置中心&amp;mdash;&amp;gt;分发到具体的服务中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习目标：MQ：Message Queue（消息队列）&lt;/p&gt;
&lt;p&gt;1、消息队列介绍【了解】&lt;/p&gt;
&lt;p&gt;2、RabbitMQ介绍以及安装【应用】&lt;/p&gt;
&lt;p&gt;3、编写RabbitMQ的入门程序【掌握】&lt;/p&gt;
&lt;p&gt;4、RabbitMQ的通信方式【重点】&lt;/p&gt;
&lt;p&gt;5、SpringBoot集成RabbitMQ【掌握】&lt;/p&gt;
&lt;h1 id=&#34;1-消息队列概述&#34;&gt;1. 消息队列概述
&lt;/h1&gt;&lt;p&gt;学习过Redis：5种数据结构     List可以作为消息队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1589938458020.png&#34;
	width=&#34;1119&#34;
	height=&#34;330&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589938458020&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;339&#34;
		data-flex-basis=&#34;813px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-什么是mq&#34;&gt;1.1. 什么是MQ
&lt;/h2&gt;&lt;p&gt;消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。&lt;/p&gt;
&lt;p&gt;MQ全称为Message Queue，消息队列作用在（一个）应用程序和（一个或多个）&lt;strong&gt;应用程序之间进行通信过程中保存消息的容器&lt;/strong&gt;。【是在消息的传输过程中保存消息的容器 】&lt;/p&gt;
&lt;h2 id=&#34;12-常见产品&#34;&gt;1.2 常见产品
&lt;/h2&gt;&lt;p&gt;场景的消息中间件（MOM）产品有：RabbitMQ  ActiveMQ  RocketMQ  kafka&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564382934252.png&#34;
	width=&#34;1292&#34;
	height=&#34;454&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564382934252&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;284&#34;
		data-flex-basis=&#34;682px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kafka&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;Apache下的一个子项目，使用scala实现的一个高性能分布式Publish/Subscribe消息队列系统。
	1.快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；
	2.高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；
	3.高堆积：支持topic下消费者较长时间离线，消息堆积量大；
	4.完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现负载均衡；
	5.支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-mq的常见应用场景&#34;&gt;1.3 MQ的常见应用场景
&lt;/h2&gt;&lt;h3 id=&#34;131-应用解耦&#34;&gt;1.3.1 应用解耦
&lt;/h3&gt;&lt;p&gt;双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口.这种做法有一个缺点:当库存系统出现故障时,订单就会失败。(这样某云、某东将少赚好多好多钱)订单系统和库存系统高耦合.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户提交订单：同步处理，需要执行的时间：50ms * n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564383470643.png&#34;
	width=&#34;994&#34;
	height=&#34;123&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564383470643&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;808&#34;
		data-flex-basis=&#34;1939px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思考：在上述业务逻辑中，其实用户只需要关心自己的订单提交是否成功即可，至于其他的服务（业务）处理与用户是没有任何关系的，因此针对这个场景，我们是否可以这样去做呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564383948529.png&#34;
	width=&#34;954&#34;
	height=&#34;302&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564383948529&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;315&#34;
		data-flex-basis=&#34;758px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间提高3倍。&lt;/p&gt;
&lt;p&gt;订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。库存系统:订阅下单的消息,获取下单消息,进行库操作。就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失。&lt;/p&gt;
&lt;h3 id=&#34;132-异步处理&#34;&gt;1.3.2 异步处理
&lt;/h3&gt;&lt;p&gt;例如：用户注册。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户注册，将数据写入数据库，然后等待系统发送短信，收到短信后继续等待系统发送邮件。这个过程中短信业务与邮件业务与用户也是无关的，因此也可以通过MQ去解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564384216328.png&#34;
	width=&#34;763&#34;
	height=&#34;99&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564384216328&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;770&#34;
		data-flex-basis=&#34;1849px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MQ：用户注册过程中，只需要将手机号和email发送到MQ中即可，然后由其他服务监听MQ然后获取消息并且处理相关业务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564385009047.png&#34;
	width=&#34;933&#34;
	height=&#34;296&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564385009047&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;315&#34;
		data-flex-basis=&#34;756px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;133-流量削峰&#34;&gt;1.3.3 流量削峰
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564385121615.png&#34;
	width=&#34;591&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564385121615&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;353&#34;
		data-flex-basis=&#34;849px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;流量削峰一般在秒杀活动中应用广泛。场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以控制活动人数，超过此一定阀值的订单直接丢弃(这就是为什么秒杀一次都没有成功过:cry:)&lt;/li&gt;
&lt;li&gt;可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)&lt;/li&gt;
&lt;li&gt;用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面&lt;/li&gt;
&lt;li&gt;秒杀业务根据消息队列中的请求信息，再做后续业务处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14-思考&#34;&gt;1.4 思考
&lt;/h2&gt;&lt;p&gt;所有服务间调用是否都可以使用MQ？&lt;strong&gt;不是&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;记住一个原则：调用方实时依赖执行结果的业务场景，使用直接调用，而不是MQ 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564382839184.png&#34;
	width=&#34;989&#34;
	height=&#34;363&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564382839184&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;272&#34;
		data-flex-basis=&#34;653px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;15-amqp-和-jms&#34;&gt;1.5 AMQP 和 JMS
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564385585125.png&#34;
	width=&#34;801&#34;
	height=&#34;438&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564385585125&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;438px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AMQP高级消息队列协议，是一个进程间传递异步消息的网络协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JMS和AMQP区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JMS规定了两种消息模式（P2P、P/S）；而AMQP的消息模式更加丰富&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JMS：应用层接口    AMQP：消息传输的协议。&lt;/p&gt;
&lt;h1 id=&#34;2-rabbitmq介绍以及安装&#34;&gt;2. RabbitMQ介绍以及安装
&lt;/h1&gt;&lt;h2 id=&#34;21-rabbitmq介绍&#34;&gt;2.1 RabbitMQ介绍
&lt;/h2&gt;&lt;p&gt;RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。&lt;/p&gt;
&lt;p&gt;RabbitMQ官方地址：http://www.rabbitmq.com/&lt;/p&gt;
&lt;p&gt;RabbitMQ提供了5种通信模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式；&lt;/p&gt;
&lt;p&gt;官网对应模式介绍：https://www.rabbitmq.com/getstarted.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1555988678324.png&#34;
	width=&#34;1014&#34;
	height=&#34;551&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1555988678324&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-安装说明&#34;&gt;2.2. 安装说明
&lt;/h2&gt;&lt;p&gt;略：详细查看 &lt;code&gt;资料/软件/安装Windows RabbitMQ.pdf&lt;/code&gt; 文档。&lt;/p&gt;
&lt;p&gt;1、先安装erlang&lt;/p&gt;
&lt;p&gt;2、再安装mq服务&lt;/p&gt;
&lt;h2 id=&#34;23-用户以及virtual-hosts配置&#34;&gt;2.3 用户以及Virtual Hosts配置
&lt;/h2&gt;&lt;h3 id=&#34;231-配置账号&#34;&gt;2.3.1 配置账号
&lt;/h3&gt;&lt;p&gt;RabbitMQ在安装好后，可以访问http://localhost:15672 ；其&lt;strong&gt;自带了guest/guest的用户名和密码&lt;/strong&gt;；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564386195991.png&#34;
	width=&#34;832&#34;
	height=&#34;576&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564386195991&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;346px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;创建用户后效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564386635450.png&#34;
	width=&#34;699&#34;
	height=&#34;271&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564386635450&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;257&#34;
		data-flex-basis=&#34;619px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;角色说明&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;超级管理员(administrator)：可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。&lt;/li&gt;
&lt;li&gt;监控者(monitoring)：可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)&lt;/li&gt;
&lt;li&gt;策略制定者(policymaker)：可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。&lt;/li&gt;
&lt;li&gt;普通管理者(management)：仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。&lt;/li&gt;
&lt;li&gt;其他：无法登陆管理控制台，通常就是普通的生产者和消费者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;232-配置virtual-hosts&#34;&gt;2.3.2 配置Virtual Hosts
&lt;/h3&gt;&lt;p&gt;像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。&lt;strong&gt;Virtual Name一般以/开头&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：创建Virtual Hosts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564386791029.png&#34;
	width=&#34;1292&#34;
	height=&#34;344&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564386791029&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;375&#34;
		data-flex-basis=&#34;901px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：设置Virtual Hosts权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先：点击【名称】&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564386931079.png&#34;
	width=&#34;1298&#34;
	height=&#34;277&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564386931079&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;468&#34;
		data-flex-basis=&#34;1124px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;权限设置：进入权限设置页面后，关联一个用户，然后确定【Set permission】。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564387033583.png&#34;
	width=&#34;759&#34;
	height=&#34;414&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564387033583&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;440px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564387162595.png&#34;
	width=&#34;633&#34;
	height=&#34;225&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564387162595&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;281&#34;
		data-flex-basis=&#34;675px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;user：用户名
configure ：一个正则表达式，用户对符合该正则表达式的所有资源拥有 configure 操作的权限
write：一个正则表达式，用户对符合该正则表达式的所有资源拥有 write 操作的权限
read：一个正则表达式，用户对符合该正则表达式的所有资源拥有 read 操作的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-rabbitmq入门程序&#34;&gt;3 RabbitMQ入门程序
&lt;/h1&gt;&lt;p&gt;入门案例将使用RabbitMQ的简单模式实现。&lt;/p&gt;
&lt;h2 id=&#34;31-创建工程&#34;&gt;3.1 创建工程
&lt;/h2&gt;&lt;p&gt;创建工程：&lt;code&gt;rabbitmq-day01-demo1-quickstart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564389013218.png&#34;
	width=&#34;792&#34;
	height=&#34;303&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564389013218&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;261&#34;
		data-flex-basis=&#34;627px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;添加依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--添加mq依赖--&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.6.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-创建生产者&#34;&gt;3.2 创建生产者
&lt;/h2&gt;&lt;h3 id=&#34;321-实现步骤&#34;&gt;3.2.1 实现步骤
&lt;/h3&gt;&lt;p&gt;创建生产者具体步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;// 1.创建链接工厂对象
// 2.设置RabbitMQ服务主机地址,默认localhost
// 3.设置RabbitMQ服务端口,默认5672
// 4.设置虚拟主机名字，默认/
// 5.设置用户连接名，默认guest
// 6.设置链接密码，默认guest
// 7.创建一个新链接
// 8.创建消息通道
// 9.创建队列
// 10.创建消息
// 11.消息发送
// 12.关闭资源
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建com.itheima.quickstart.Producer类，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Producer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1.创建链接工厂对象
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 2.设置RabbitMQ服务主机地址,默认localhost
        connectionFactory.setHost(&amp;quot;localhost&amp;quot;);
        // 3.设置RabbitMQ服务端口,默认5672
        connectionFactory.setPort(5672);
        // 4.设置虚拟主机名字，默认/
        connectionFactory.setVirtualHost(&amp;quot;/sz_itcast&amp;quot;);
        // 5.设置用户连接名，默认guest
        connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
        // 6.设置链接密码，默认guest
        connectionFactory.setPassword(&amp;quot;123456&amp;quot;);
        // 7.创建链接
        Connection connection = connectionFactory.newConnection();
        // 8.创建消息通道
        Channel channel = connection.createChannel();
        // 9.创建队列
        // arg0：队列名称 arg1：是否持久化 arg2：是否排外 arg3：关闭连接时队列是否自动删除 arg4：队列其他参数
        channel.queueDeclare(&amp;quot;simple_queue&amp;quot;, true, false, false, null);
        // 10.创建消息
        String message = &amp;quot;你好，欢迎来到程序员。&amp;quot;;
        // 11.消息发送
        // arg0：交换机名称，没有指定使用默认的Default Exchange
        // arg1：路由key，点对点模式可以使用队列名称 arg2：指定消息其他属性 arg3：消息的字节码
        channel.basicPublish(&amp;quot;&amp;quot;, &amp;quot;simple_queue&amp;quot;, null, message.getBytes());
        // 12.关闭资源
        channel.close();
        connection.close();
    }
}

PS：参数详细说明
arg2 boolean exclusive 是否排外
如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常。

arg4:队列其他参数设置
- Message TTL 设置消息生命周期
- Auto Expire 当队列在指定的时间没有被访问就会被删除
- Max Length 限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉
- Max Length Bytes 限定队列最大占用的空间大小
- DLX 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉
- DLK 将删除的消息推送到指定交换机的指定路由键的队列中去
- Maximum priority 声明优先级队列
- Lazy mode 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;322-效果&#34;&gt;3.2.2 效果
&lt;/h3&gt;&lt;p&gt;在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564390252163.png&#34;
	width=&#34;822&#34;
	height=&#34;359&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564390252163&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;228&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果想查看消息，可以点击&lt;code&gt;队列名称-&amp;gt;Get Messages&lt;/code&gt;,如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564390303556.png&#34;
	width=&#34;501&#34;
	height=&#34;418&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564390303556&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;119&#34;
		data-flex-basis=&#34;287px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;3--自己实现代码&#34;&gt;3  自己实现代码
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;package com.itheima.simple;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @description: 简单模式 生产者  没有交换机 , 队列名称 = 路由器名称
 * @author: QIXIANG LING
 * @date: 2020/5/23 19:25
 */
public class SimpleProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory connectionFactory = new ConnectionFactory();

        // 2. 设置RabbitMq服务主机地址
        connectionFactory.setHost(&amp;quot;localhost&amp;quot;);

        // 3, 设置RabbitMq 服务端口, 默认5672 (通信端口 TCP)    (15672 是应用层的端口 http 访问rabbitMQ客户端的端口)

        connectionFactory.setPort(5672);

        // 4.设置虚拟主机名字, 默认/
        connectionFactory.setVirtualHost(&amp;quot;/sz_itheima88&amp;quot;);

        // 5. 设置用户连接名和 密码
        connectionFactory.setUsername(&amp;quot;Rina&amp;quot;);
        connectionFactory.setPassword(&amp;quot;123456&amp;quot;);

        // 7. 创建新连接
        Connection connection = connectionFactory.newConnection();

        // 8. 创建消息通道
        Channel channel = connection.createChannel();

        // 9. 创建队列
        //  需要参数 String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&amp;lt;String, Object&amp;gt; arguments

        // queue 队列的名称 ; durable 是否持久化 ; exclusive 是否排外 (操作这个队列的时候是否允许别人也操作)
        // autoDelete : 是否自动删除 ;  arguments (指定队列的一些额外属性 ) 队列的过期时间 , 长度

        channel.queueDeclare(&amp;quot;simple-queue&amp;quot;,true,false,false,null);

        // 10 . 创建消息
        String message  = &amp;quot;望月理奈,夏海里伽子,花鸟玲爱&amp;quot;;


        // 11 .消息发送
        // String exchange (指定交换机的名称) , String routingKey (路由器的名称) , BasicProperties props (指定消息的属性 :可指定过期时间), byte[] body
        channel.basicPublish(&amp;quot;&amp;quot;,&amp;quot;simple-exchange&amp;quot;,null,message.getBytes(&amp;quot;UTF-8&amp;quot;));
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;323-queues列表说明&#34;&gt;3.2.3 Queues列表说明
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PS：列表说明
- Features消息特征：
  - D：持久化
- State：当前的状态
  - running：运行中
  - idle：空闲。 
- Ready：待消费的消息总数 
- Unacked：待应答的消息总数 
- total：消息总数 = Ready+Unacked 
- incoming：消息进入的速率
- deliver/get：消息获取的速率
- ack：消息应答的速率

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33-创建消费者&#34;&gt;3.3 创建消费者
&lt;/h2&gt;&lt;p&gt;消费者创建可以按照如下步骤实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;// 1.创建链接工厂对象
// 2.设置RabbitMQ服务主机地址,默认localhost
// 3.设置RabbitMQ服务端口,默认5672
// 4.设置虚拟主机名字，默认/
// 5.设置用户连接名，默认guest
// 6.设置链接密码，默认guest
// 7.创建一个新链接
// 8.创建消息通道
// 9.创建队列
// 10.创建消费者，并设置消息处理
// 11.消息监听
// 12.关闭资源(不建议关闭，建议一直监听消息)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照上面的步骤创建消息消费者com.itheima.rabbitmq.simple.Consumer代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Consumer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1.创建链接工厂对象
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 2.设置RabbitMQ服务主机地址,默认localhost
        connectionFactory.setHost(&amp;quot;localhost&amp;quot;);
        // 3.设置RabbitMQ服务端口,默认5672
        connectionFactory.setPort(5672);
        // 4.设置虚拟主机名字，默认/
        connectionFactory.setVirtualHost(&amp;quot;/sz_itcast&amp;quot;);
        // 5.设置用户连接名，默认guest
        connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
        // 6.设置链接密码，默认guest
        connectionFactory.setPassword(&amp;quot;123456&amp;quot;);
        // 7.创建一个新链接
        Connection connection = connectionFactory.newConnection();
        // 8.创建消息通道
        Channel channel = connection.createChannel();
        // 9.创建队列
        channel.queueDeclare(&amp;quot;simple_queue&amp;quot;, true, false, false, null);
        // 10.创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            /**
             * @param consumerTag 消费者标签，在channel.basicConsume时候可以指定
             * @param envelope 消息包的内容，可从中获取消息id，消息routing key，交换机，消息和重发标志(收到消息失败后是否需要重新发送)
             * @param properties 消息属性信息
             * @param body 消息体
             **/
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        // arg1：是否自动应答，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认
        // arg2：消费者接收消息到后回调（消费消息）
        channel.basicConsume(&amp;quot;simple_queue&amp;quot;, true, consumer);
        // 12.关闭资源(不建议关闭，建议一直监听消息)
    }
}

PS：同一个会话， consumerTag 是固定的 可以做此会话的名字， deliveryTag 每次接收消息+1，可以做此消息处理通道的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;332-console控制台&#34;&gt;3.3.2 console控制台
&lt;/h3&gt;&lt;p&gt;执行后，控制台输入如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564391734810.png&#34;
	width=&#34;918&#34;
	height=&#34;391&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564391734810&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;234&#34;
		data-flex-basis=&#34;563px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;333-rabbitmq控制台&#34;&gt;3.3.3 RabbitMQ控制台
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564391840497.png&#34;
	width=&#34;805&#34;
	height=&#34;307&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564391840497&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;262&#34;
		data-flex-basis=&#34;629px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-代码抽取&#34;&gt;3.4 代码抽取
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;重复代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564394914493.png&#34;
	width=&#34;829&#34;
	height=&#34;295&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564394914493&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;281&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;无论是消费者，还是生产者，都需要创建连接，因此我们可以将这段公共的代码抽取到工具类中。创建com.itheima.rabbitmq.util.ConnectionUtil工具类对象，用于创建Connection，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564395167481.png&#34;
	width=&#34;1072&#34;
	height=&#34;491&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564395167481&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;523px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConnectionUtils {

    // 提供一个公共的静态的访问方法
    public static Connection getConnection() throws Exception {
        // 1.创建链接工厂对象
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 2.设置RabbitMQ服务主机地址,默认localhost
        connectionFactory.setHost(&amp;quot;localhost&amp;quot;);
        // 3.设置RabbitMQ服务端口,默认5672
        connectionFactory.setPort(5672);
        // 4.设置虚拟主机名字，默认/
        connectionFactory.setVirtualHost(&amp;quot;/sz_itcast&amp;quot;);
        // 5.设置用户连接名，默认guest
        connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
        // 6.设置链接密码，默认guest
        connectionFactory.setPassword(&amp;quot;123456&amp;quot;);
        // 7.创建链接
        Connection connection = connectionFactory.newConnection();
        return connection;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;生产者优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改Producer，链接对象使用上面的ConnectionUtil工具类创建，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//创建链接
Connection connection = ConnectionUtil.getConnection();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;消费者优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改Consumer，链接对象使用上面的ConnectionUtil工具类创建，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//创建链接
Connection connection = ConnectionUtil.getConnection();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-小结&#34;&gt;3.4 小结
&lt;/h2&gt;&lt;p&gt;上述的入门案例中使用的是如下的AMQP最简单的P2P通信方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1555991074575.png&#34;
	width=&#34;902&#34;
	height=&#34;151&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1555991074575&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;597&#34;
		data-flex-basis=&#34;1433px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在上图的模型中，有以下概念：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;P：生产者，也就是要发送消息的程序
C：消费者：消息的接受者，会一直等待消息到来。
queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。

在rabbitMQ中的消费者是一定要监听某个消息队列才能获取消息。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-rabbitmq工作模式&#34;&gt;4. RabbitMQ工作模式
&lt;/h1&gt;&lt;p&gt;RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式。&lt;/p&gt;
&lt;h2 id=&#34;41-work-queues工作队列模式&#34;&gt;4.1 Work queues工作队列模式
&lt;/h2&gt;&lt;h3 id=&#34;411-模式说明&#34;&gt;4.1.1 模式说明
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1562516450360.png&#34;
	width=&#34;935&#34;
	height=&#34;189&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1562516450360&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;494&#34;
		data-flex-basis=&#34;1187px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Work Queues&lt;/code&gt;与入门程序的&lt;code&gt;简单模式&lt;/code&gt;相比，多了一个或多个消费端，多个消费端共同消费同一个队列中的消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度（也就是多人处理）。&lt;/p&gt;
&lt;h3 id=&#34;412-代码实现&#34;&gt;4.1.2 代码实现
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Work Queues&lt;/code&gt;与入门程序的&lt;code&gt;简单模式&lt;/code&gt;的代码是几乎一样的；可以完全复制，并复制多一个消费者进行多个消费者同时消费消息的测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564396531411.png&#34;
	width=&#34;524&#34;
	height=&#34;273&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564396531411&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;4121-创建生产者&#34;&gt;4.1.2.1 创建生产者
&lt;/h4&gt;&lt;p&gt;创建WorkProducer消息生产者对象，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WorkProducer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        channel.queueDeclare(&amp;quot;work_queue&amp;quot;, true, false, false, null);
        for (int i = 0; i &amp;lt; 10; i++){
            // 创建消息
            String message = &amp;quot;你好，欢迎来到黑马程序员，学号：&amp;quot; + i;
            // 消息发送
            channel.basicPublish(&amp;quot;&amp;quot;, &amp;quot;work_queue&amp;quot;, null, message.getBytes());
        }
        // 关闭资源
        channel.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4122-创建消费者1&#34;&gt;4.1.2.2 创建消费者1
&lt;/h4&gt;&lt;p&gt;WorkConsumer1,代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WorkConsumer1 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;work_queue&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者1获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;work_queue&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4123-创建消费者2&#34;&gt;4.1.2.3 创建消费者2
&lt;/h4&gt;&lt;p&gt;创建WorkConsumer2，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WorkConsumer2 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;work_queue&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者2获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;work_queue&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;413-测试&#34;&gt;4.1.3 测试
&lt;/h3&gt;&lt;p&gt;启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者1：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564397871582.png&#34;
	width=&#34;860&#34;
	height=&#34;125&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564397871582&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;688&#34;
		data-flex-basis=&#34;1651px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者2：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564397884743.png&#34;
	width=&#34;836&#34;
	height=&#34;129&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564397884743&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;648&#34;
		data-flex-basis=&#34;1555px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;414-小结&#34;&gt;4.1.4 小结
&lt;/h3&gt;&lt;p&gt;在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是&lt;strong&gt;竞争&lt;/strong&gt;的关系。&lt;/p&gt;
&lt;p&gt;默认，RabbitMQ会一个一个的发送信息给下一个消费者(consumer)，而不考虑每个任务的时长且&lt;strong&gt;是一次性分配，并非一个一个分配&lt;/strong&gt;。平均的每个消费者将会获得相等数量的消息。这种发送消息得方式叫做——轮询（round-robin）。&lt;/p&gt;
&lt;p&gt;P/S：消息的发布与订阅者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fanout：广播模式&lt;/li&gt;
&lt;li&gt;RoutingKey：路由模式&lt;/li&gt;
&lt;li&gt;Topic：主题模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-fanout广播模式&#34;&gt;4.2 Fanout广播模式
&lt;/h2&gt;&lt;h3 id=&#34;421-模式说明&#34;&gt;4.2.1 模式说明
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1562518625240.png&#34;
	width=&#34;956&#34;
	height=&#34;193&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1562518625240&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;495&#34;
		data-flex-basis=&#34;1188px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;发布订阅模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;1.每个消费者监听自己的队列。
2.生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收
到消息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在订阅模型中，多了一个exchange角色，而且过程略有变化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）
C：消费者，消息的接受者，会一直等待消息到来。
Queue：消息队列，接收消息、缓存消息。
Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：
	Fanout：广播，将消息交给所有绑定到交换机的队列
	Direct：定向，把消息交给符合指定routing key 的队列
	Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Exchange（交换机）只负责转发消息，不具备存储消息的能力&lt;/strong&gt;，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！&lt;/p&gt;
&lt;h3 id=&#34;422-代码&#34;&gt;4.2.2 代码
&lt;/h3&gt;&lt;h4 id=&#34;4221-创建生产者&#34;&gt;4.2.2.1 创建生产者
&lt;/h4&gt;&lt;p&gt;生产者需要注意如下3点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;1.声明交换机
2.声明队列
3.队列需要绑定指定的交换机
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建FanoutProducer消息生产者，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FanoutProducer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;fanout_queue1&amp;quot;, true, false, false, null);
        channel.queueDeclare(&amp;quot;fanout_queue2&amp;quot;, true, false, false, null);
        // 创建交换机：arg0,交换机名称  arg1,交换机类型（广播）
        channel.exchangeDeclare(&amp;quot;fanout_exchange&amp;quot;, BuiltinExchangeType.FANOUT);
        // 将队列绑定到交换机
        channel.queueBind(&amp;quot;fanout_queue1&amp;quot;, &amp;quot;fanout_exchange&amp;quot;, &amp;quot;&amp;quot;);
        channel.queueBind(&amp;quot;fanout_queue2&amp;quot;, &amp;quot;fanout_exchange&amp;quot;, &amp;quot;&amp;quot;);
        for (int i = 0; i &amp;lt; 10; i++){
            // 创建消息
            String message = &amp;quot;你好，欢迎来到程序员，fanout：&amp;quot; + i;
            // 消息发送
            channel.basicPublish(&amp;quot;fanout_exchange&amp;quot;, &amp;quot;&amp;quot;, null, message.getBytes());
        }
        // 关闭资源
        channel.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4222-创建消费者1&#34;&gt;4.2.2.2 创建消费者1
&lt;/h4&gt;&lt;p&gt;创建FanoutConsumer1消费者，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FanoutConsumer1 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;fanout_queue1&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者1获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;fanout_queue1&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4223-创建消费者2&#34;&gt;4.2.2.3 创建消费者2
&lt;/h4&gt;&lt;p&gt;创建FanoutConsumer2消费者，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FanoutConsumer2 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;fanout_queue2&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者2获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;fanout_queue2&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;423-测试&#34;&gt;4.2.3 测试
&lt;/h3&gt;&lt;p&gt;启动所有消费者，然后使用生产者发送消息；在每个消费者对应的控制台可以查看到生产者发送的所有消息；到达&lt;strong&gt;广播&lt;/strong&gt;的效果。&lt;/p&gt;
&lt;p&gt;消费者1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564497091180.png&#34;
	width=&#34;934&#34;
	height=&#34;293&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564497091180&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;318&#34;
		data-flex-basis=&#34;765px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;消费者2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564497107892.png&#34;
	width=&#34;942&#34;
	height=&#34;303&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564497107892&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;310&#34;
		data-flex-basis=&#34;746px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在执行完测试代码后，其实到RabbitMQ的管理后台找到&lt;code&gt;Exchanges&lt;/code&gt;选项卡，点击 &lt;code&gt;fanout_exchange&lt;/code&gt; 的交换机，可以查看到如下的绑定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564497143772.png&#34;
	width=&#34;742&#34;
	height=&#34;483&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564497143772&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;368px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;424-小结&#34;&gt;4.2.4 小结
&lt;/h3&gt;&lt;p&gt;交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布订阅模式与work队列模式的区别&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;1、work队列模式不用定义交换机，而发布/订阅模式需要定义交换机。 
2、发布/订阅模式的生产方是面向交换机发送消息，work队列模式的生产方是面向队列发送消息(底层使用默认交换机)。
3、发布/订阅模式需要设置队列和交换机的绑定，work队列模式不需要设置，实际上work队列模式会将队列绑 定到默认的交换机 。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-routing路由模式&#34;&gt;4.3 Routing路由模式
&lt;/h2&gt;&lt;h3 id=&#34;431-模式说明&#34;&gt;4.3.1. 模式说明
&lt;/h3&gt;&lt;p&gt;路由模式特点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;1.队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）
2.消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。
3.Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1562522054280.png&#34;
	width=&#34;1269&#34;
	height=&#34;330&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1562522054280&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;384&#34;
		data-flex-basis=&#34;922px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。
X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列
C1：消费者，其所在队列指定了需要routing key 为 error 的消息
C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;432-代码&#34;&gt;4.3.2 代码
&lt;/h3&gt;&lt;p&gt;在编码上与 &lt;code&gt;Publish/Subscribe发布与订阅模式&lt;/code&gt; 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。&lt;/p&gt;
&lt;h4 id=&#34;4321-创建生产者&#34;&gt;4.3.2.1 创建生产者
&lt;/h4&gt;&lt;p&gt;创建RoutingKeyProducer消息生产者，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RoutingKeyProducer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;routing_key_queue1&amp;quot;, true, false, false, null);
        channel.queueDeclare(&amp;quot;routing_key_queue2&amp;quot;, true, false, false, null);
        // 创建交换机：arg0,交换机名称  arg1,交换机类型（广播）
        channel.exchangeDeclare(&amp;quot;routing_key_exchange&amp;quot;, BuiltinExchangeType.DIRECT);
        // 将队列绑定到交换机
        // routing_key_queue1：error
        // routing_key_queue2：error、info、warning
        channel.queueBind(&amp;quot;routing_key_queue1&amp;quot;, &amp;quot;routing_key_exchange&amp;quot;, &amp;quot;error&amp;quot;);
        channel.queueBind(&amp;quot;routing_key_queue2&amp;quot;, &amp;quot;routing_key_exchange&amp;quot;, &amp;quot;error&amp;quot;);
        channel.queueBind(&amp;quot;routing_key_queue2&amp;quot;, &amp;quot;routing_key_exchange&amp;quot;, &amp;quot;info&amp;quot;);
        channel.queueBind(&amp;quot;routing_key_queue2&amp;quot;, &amp;quot;routing_key_exchange&amp;quot;, &amp;quot;warning&amp;quot;);
        for (int i = 0; i &amp;lt; 10; i++){
            // 创建消息
            String message = &amp;quot;你好，欢迎来到黑马程序员，routing_key：&amp;quot; + i;
            String routingKey = &amp;quot;&amp;quot;;
            if (i%2 == 0){ // routing_key_queue1、routing_key_queue2 0、2、4、6、8
                routingKey = &amp;quot;error&amp;quot;;
            }else if (i%5 == 0){    // routing_key_queue2：5
                routingKey = &amp;quot;info&amp;quot;;
            }else { // 0、1、5
                routingKey = &amp;quot;warning&amp;quot;;
            }
            message += &amp;quot;---&amp;gt;&amp;quot; + routingKey;

            // 消息发送
            channel.basicPublish(&amp;quot;routing_key_exchange&amp;quot;, routingKey, null, message.getBytes());
        }
        // 关闭资源
        channel.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4322-创建消费者1&#34;&gt;4.3.2.2 创建消费者1
&lt;/h4&gt;&lt;p&gt;创建RoutingKeyConsumer1，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RoutingKeyConsumer1 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;routing_key_queue1&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者1获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;routing_key_queue1&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4323-创建消费者2&#34;&gt;4.3.2.3 创建消费者2
&lt;/h4&gt;&lt;p&gt;创建RoutingKeyConsumer2，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RoutingKeyConsumer2 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;routing_key_queue2&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者2获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;routing_key_queue2&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;433-测试&#34;&gt;4.3.3 测试
&lt;/h3&gt;&lt;p&gt;启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达&lt;strong&gt;按照需要接收&lt;/strong&gt;的效果。&lt;/p&gt;
&lt;p&gt;消费者1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564500966364.png&#34;
	width=&#34;1167&#34;
	height=&#34;125&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564500966364&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;933&#34;
		data-flex-basis=&#34;2240px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;消费者2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564501008020.png&#34;
	width=&#34;1215&#34;
	height=&#34;229&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564501008020&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;530&#34;
		data-flex-basis=&#34;1273px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在执行完测试代码后，其实到RabbitMQ的管理后台找到&lt;code&gt;Exchanges&lt;/code&gt;选项卡，点击 &lt;code&gt;direct_exchange&lt;/code&gt; 的交换机，可以查看到如下的绑定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564501086365.png&#34;
	width=&#34;680&#34;
	height=&#34;412&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564501086365&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;434-小结&#34;&gt;4.3.4 小结
&lt;/h3&gt;&lt;p&gt;Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。&lt;/p&gt;
&lt;h2 id=&#34;44-topics通配符模式&#34;&gt;4.4 Topics通配符模式
&lt;/h2&gt;&lt;h3 id=&#34;441-模式说明&#34;&gt;4.4.1 模式说明
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1562524697140.png&#34;
	width=&#34;1286&#34;
	height=&#34;346&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1562524697140&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;371&#34;
		data-flex-basis=&#34;892px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Topic&lt;/code&gt;类型与&lt;code&gt;Direct&lt;/code&gt;相比，都是可以根据&lt;code&gt;RoutingKey&lt;/code&gt;把消息路由到不同的队列。只不过&lt;code&gt;Topic&lt;/code&gt;类型&lt;code&gt;Exchange&lt;/code&gt;可以让队列在绑定&lt;code&gt;Routing key&lt;/code&gt; 的时候&lt;strong&gt;使用通配符&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Routingkey&lt;/code&gt; 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： &lt;code&gt;item.insert&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通配符规则：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;：匹配一个或多个词&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;：匹配不多&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;item.#&lt;/code&gt;：能够匹配&lt;code&gt;item.insert.abc&lt;/code&gt; 或者 &lt;code&gt;item.insert&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;item.*&lt;/code&gt;：只能匹配&lt;code&gt;item.insert&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1562524972321.png&#34;
	width=&#34;880&#34;
	height=&#34;311&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1562524972321&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;282&#34;
		data-flex-basis=&#34;679px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红色Queue：绑定的是&lt;code&gt;usa.#&lt;/code&gt; ，因此凡是以 &lt;code&gt;usa.&lt;/code&gt;开头的&lt;code&gt;routing key&lt;/code&gt; 都会被匹配到&lt;/li&gt;
&lt;li&gt;黄色Queue：绑定的是&lt;code&gt;#.news&lt;/code&gt; ，因此凡是以 &lt;code&gt;.news&lt;/code&gt;结尾的 &lt;code&gt;routing key&lt;/code&gt; 都会被匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;442-代码&#34;&gt;4.4.2 代码
&lt;/h3&gt;&lt;h4 id=&#34;4421-创建生产者&#34;&gt;4.4.2.1 创建生产者
&lt;/h4&gt;&lt;p&gt;创建TopicProducer实现消息生产者，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TopicProducer {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;topic_queue1&amp;quot;, true, false, false, null);
        channel.queueDeclare(&amp;quot;topic_queue2&amp;quot;, true, false, false, null);
        // 创建交换机：arg0,交换机名称  arg1,交换机类型（广播）
        channel.exchangeDeclare(&amp;quot;topic_exchange&amp;quot;, BuiltinExchangeType.TOPIC);
        // 将队列绑定到交换机
        channel.queueBind(&amp;quot;topic_queue1&amp;quot;, &amp;quot;topic_exchange&amp;quot;, &amp;quot;*.orange.*&amp;quot;);
        channel.queueBind(&amp;quot;topic_queue2&amp;quot;, &amp;quot;topic_exchange&amp;quot;, &amp;quot;*.*.rabbit&amp;quot;);
        channel.queueBind(&amp;quot;topic_queue2&amp;quot;, &amp;quot;topic_exchange&amp;quot;, &amp;quot;lazy.#&amp;quot;);
        // 发送消息
        String msg = &amp;quot;欢迎来到黑马学习quick.orange.rabbit&amp;quot;;
        byte[] body = msg.getBytes(&amp;quot;UTF-8&amp;quot;);
        channel.basicPublish(&amp;quot;topic_exchange&amp;quot;, &amp;quot;quick.orange.rabbit&amp;quot;, null, body);  // 1/2

        String msg2 = &amp;quot;欢迎来到黑马学习lazy.pink.rabbit&amp;quot;;
        byte[] body2 = msg2.getBytes(&amp;quot;UTF-8&amp;quot;);
        channel.basicPublish(&amp;quot;topic_exchange&amp;quot;, &amp;quot;lazy.pink.rabbit&amp;quot;, null, body2);     // 1
        // 关闭资源
        channel.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4422-创建消费者1&#34;&gt;4.4.2.2 创建消费者1
&lt;/h4&gt;&lt;p&gt;创建TopicConsumer1，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TopicConsumer1 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;topic_queue1&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者1获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;topic_queue1&amp;quot;, true, consumer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4423-创建消费者2&#34;&gt;4.4.2.3 创建消费者2
&lt;/h4&gt;&lt;p&gt;创建TopicConsumer2，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TopicConsumer2 {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 获取连接
        Connection connection = ConnectionUtils.getConnection();
        // 创建消息通道
        Channel channel = connection.createChannel();
        // 创建队列
        channel.queueDeclare(&amp;quot;topic_queue2&amp;quot;, true, false, false, null);
        // 创建消费者，并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 路由
                String routingKey = envelope.getRoutingKey();
                // 交换机
                String exchange = envelope.getExchange();
                // 消息id
                long deliveryTag = envelope.getDeliveryTag();
                // 消息体
                String message = new String(body, &amp;quot;UTF-8&amp;quot;);
                System.out.println(&amp;quot;消费者2获取的数据：&amp;quot; + &amp;quot;路由：&amp;quot; + routingKey + &amp;quot;,交换机：&amp;quot; + exchange + &amp;quot;,消息id：&amp;quot; + deliveryTag + &amp;quot;,消息体：&amp;quot; + message);
            }
        };
        // 11.消息监听 arg0：监听的队列名称
        channel.basicConsume(&amp;quot;topic_queue2&amp;quot;, true, consumer);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;443-测试&#34;&gt;4.4.3 测试
&lt;/h3&gt;&lt;p&gt;启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达&lt;strong&gt;按照需要接收&lt;/strong&gt;的效果；并且这些routing key可以使用通配符。&lt;/p&gt;
&lt;p&gt;消费者1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1576679250472.png&#34;
	width=&#34;1145&#34;
	height=&#34;136&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1576679250472&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;841&#34;
		data-flex-basis=&#34;2020px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;消费者2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1576679268274.png&#34;
	width=&#34;1126&#34;
	height=&#34;149&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1576679268274&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;755&#34;
		data-flex-basis=&#34;1813px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在执行完测试代码后，其实到RabbitMQ的管理后台找到&lt;code&gt;Exchanges&lt;/code&gt;选项卡，点击 &lt;code&gt;topic_exchange&lt;/code&gt; 的交换机，可以查看到如下的绑定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564502526555.png&#34;
	width=&#34;714&#34;
	height=&#34;382&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564502526555&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;186&#34;
		data-flex-basis=&#34;448px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;444-小结&#34;&gt;4.4.4 小结
&lt;/h3&gt;&lt;p&gt;Topic主题模式可以实现 &lt;code&gt;Publish/Subscribe发布与订阅模式&lt;/code&gt; 和 &lt;code&gt; Routing路由模式&lt;/code&gt; 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。&lt;/p&gt;
&lt;h2 id=&#34;45-rabbitmq工作模式总结&#34;&gt;4.5 RabbitMQ工作模式总结
&lt;/h2&gt;&lt;p&gt;RabbitMQ工作模式：
&lt;strong&gt;1、简单模式 HelloWorld&lt;/strong&gt;
一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、工作队列模式 Work Queue&lt;/strong&gt;
一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、发布订阅模式 Publish/subscribe&lt;/strong&gt;
需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、路由模式 Routing&lt;/strong&gt;
需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、通配符模式 Topic&lt;/strong&gt;
需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列&lt;/p&gt;
&lt;h1 id=&#34;5-spring-boot集成rabbitmq&#34;&gt;5 Spring Boot集成RabbitMQ
&lt;/h1&gt;&lt;h2 id=&#34;51-简介&#34;&gt;5.1 简介
&lt;/h2&gt;&lt;p&gt;在Spring项目中，可以使用Spring-Rabbit去操作RabbitMQ
&lt;a class=&#34;link&#34; href=&#34;https://github.com/spring-projects/spring-amqp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spring-projects/spring-amqp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;尤其是在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一般在开发过程中&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者工程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;application.yml文件配置RabbitMQ相关信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;消费者工程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;application.yml文件配置RabbitMQ相关信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建消息处理类，用于接收队列中的消息并进行处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;52-搭建生产者工程&#34;&gt;5.2 搭建生产者工程
&lt;/h2&gt;&lt;h3 id=&#34;521-创建工程&#34;&gt;5.2.1 创建工程
&lt;/h3&gt;&lt;p&gt;创建生产者工程springboot-rabbitmq-producer：略。&lt;/p&gt;
&lt;h3 id=&#34;522-添加依赖&#34;&gt;5.2.2 添加依赖
&lt;/h3&gt;&lt;p&gt;修改pom.xml文件内容为如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;523-启动类&#34;&gt;5.2.3 启动类
&lt;/h3&gt;&lt;p&gt;创建启动类com.itheima.ProducerApplication，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class RabbitMqProviderApplication {

	public static void main(String[] args) {
		SpringApplication.run(RabbitMqProviderApplication.class, args);
	}

	// 创建队列
	@Bean
	public Queue topicQueue(){
		return new Queue(&amp;quot;topic_queue_spring_boot&amp;quot;);
	}

	// 创建交换机
	@Bean
	public Exchange topicExchange(){
		return new TopicExchange(&amp;quot;topic_exchange_spring_boot&amp;quot;);
	}

	// 将队列绑定到交换机
	@Bean
	public Binding topicQueueBind(Queue topicQueue, Exchange topicExchange){
		return BindingBuilder.bind(topicQueue).to(topicExchange).with(&amp;quot;item.#&amp;quot;).noargs();
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;524-配置rabbitmq&#34;&gt;5.2.4 配置RabbitMQ
&lt;/h3&gt;&lt;p&gt;application.yml配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    virtual-host: /sz_itcast
    username: admin
    password: 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53-搭建消费者工程&#34;&gt;5.3 搭建消费者工程
&lt;/h2&gt;&lt;h3 id=&#34;531-创建工程&#34;&gt;5.3.1 创建工程
&lt;/h3&gt;&lt;p&gt;创建消费者工程springboot-rabbitmq-consumer,工程坐标如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;springboot-rabbitmq-consumer&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;532-添加依赖&#34;&gt;5.3.2 添加依赖
&lt;/h3&gt;&lt;p&gt;修改pom.xml文件内容为如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;533-启动类&#34;&gt;5.3.3 启动类
&lt;/h3&gt;&lt;p&gt;创建启动类com.itheima.ConsumerApplication，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class ConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;534-配置rabbitmq&#34;&gt;5.3.4 配置RabbitMQ
&lt;/h3&gt;&lt;p&gt;创建application.yml，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring:
  rabbitmq:
    host: localhost
    port: 5672
    virtual-host: /sz_itcast
    username: admin
    password: 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;535-消息监听处理类&#34;&gt;5.3.5 消息监听处理类
&lt;/h3&gt;&lt;p&gt;编写消息监听器com.itheima.listener.MessageListener，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class MessageListener {

    /**
     * 监听某个队列的消息
     * @param message 接收到的消息
     */
    @RabbitListener(queues = &amp;quot;topic_queue_spring_boot&amp;quot;)
    public void myListener1(String message){
        System.out.println(&amp;quot;消费者接收到的消息为：&amp;quot; + message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54-测试&#34;&gt;5.4 测试
&lt;/h2&gt;&lt;p&gt;在生产者工程rabbitmq-producer中创建测试类com.itheima.test.RabbitMQTest，发送消息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class RabbitMqProviderApplicationTests {

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@Test
	public void contextLoads() {
		rabbitTemplate.convertAndSend(&amp;quot;topic_exchange_spring_boot&amp;quot;,&amp;quot;item.update&amp;quot;, &amp;quot;更新&amp;quot;);
		rabbitTemplate.convertAndSend(&amp;quot;topic_exchange_spring_boot&amp;quot;,&amp;quot;item.brand.insert&amp;quot;, &amp;quot;插入&amp;quot;);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先运行上述测试程序（交换机和队列才能先被声明和绑定），然后启动消费者；在消费者工程springboot-rabbitmq-consumer中控制台查看是否接收到对应消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564504900674.png&#34;
	width=&#34;866&#34;
	height=&#34;383&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564504900674&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;542px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;另外；也可以在RabbitMQ的管理控制台中查看到交换机与队列的绑定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1564504920414.png&#34;
	width=&#34;746&#34;
	height=&#34;325&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1564504920414&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;550px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-安装问题&#34;&gt;6 安装问题
&lt;/h1&gt;&lt;p&gt;计算机名称是中文无法启动RabbitMQ解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1、管理员运行cmd然后打开RabbitMQ安装目录
2、rabbitmq-service.bat remove
3、set RABBITMQ_BASE=D:\rabbitmq_server\data
4、rabbitmq-service.bat install
5、rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1589959806808.png&#34;
	width=&#34;787&#34;
	height=&#34;553&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589959806808&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;341px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rabbitmq_1/assets/1589959826016.png&#34;
	width=&#34;630&#34;
	height=&#34;91&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1589959826016&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;692&#34;
		data-flex-basis=&#34;1661px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结
&lt;/h1&gt;&lt;p&gt;1、对MQ介绍以及使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MQ：在消息传输过程中用来保存消息的容器   Message Queue&lt;/li&gt;
&lt;li&gt;使用场景：
&lt;ul&gt;
&lt;li&gt;业务解耦&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;li&gt;流量削峰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MQ的产品有很多：略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、RabbitMQ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍：略&lt;/li&gt;
&lt;li&gt;安装：略&lt;/li&gt;
&lt;li&gt;客户端工具：配置用户  +  配置虚拟主机【数据库】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、编写RabbitMQ程序：5种通信方式【&lt;strong&gt;重点&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单模式&lt;/li&gt;
&lt;li&gt;工作模式&lt;/li&gt;
&lt;li&gt;广播模式&lt;/li&gt;
&lt;li&gt;路由模式&lt;/li&gt;
&lt;li&gt;主题模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、SpringBoot集成RabbitMQ：代码简化了。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
