<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>并发编程 on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
        <description>Recent content in 并发编程 on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Sat, 03 Sep 2022 18:14:03 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>ForkJoin</title>
        <link>https://mikeLing-qx.github.io/p/forkjoin/</link>
        <pubDate>Sat, 03 Sep 2022 18:14:03 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/forkjoin/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;java RecursiveTask 类中的示例 为什么是f1.fork, f2.compute, + f1. join 而不是 f1.fork, f2.fork?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Fibonacci extends RecursiveTask&amp;lt;Integer&amp;gt; {

    final int n;

    Fibonacci(int n) {
        this.n = n;
    }

    protected Integer compute() {
        if (n &amp;lt;= 1) {
            return n;
        }
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();
        Fibonacci f2 = new Fibonacci(n - 2);
        return f2.compute() + f1.join();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两种方式的具体执行差异：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;f1.fork(); f2.compute() + f1.join();&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是通常推荐的正确使用方式。在这种做法中，f1被放入ForkJoinPool以异步执行；然后当前线程执行f2.compute()方法，这是个阻塞调用，并等待其完成；最后，调用f1.join()获取结果，如果此时f1已经计算完成，join()立即返回，否则会等待f1计算完毕。这样f1和f2都有并发执行的机会，可以充分利用CPU资源。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;f1.fork(); f2.fork(); f1.join() + f2.join();&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这种情况下，f1和f2都被放入ForkJoinPool以异步执行，然后当前线程没有进行任何计算，而是等待f1和f2结束，意味着f1和f2都得等待一个可用的线程去执行，如果ForkJoinPool中没有空闲线程或其线程数已达上限，那么f2会被阻塞在队列中等待。这消除了一部分并发性，相比第一种方式可能性能更低一些。&lt;/p&gt;
&lt;p&gt;所以，基于以上解说，第一种方式更被推荐，能更有效利用多核CPU并发计算的优势。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class RecursiveTaskTest {

    static class Fibonacci extends RecursiveTask&amp;lt;Integer&amp;gt; {

        final int n;

        Fibonacci(int n) { this.n = n; }

        protected Integer compute() {
            if (n &amp;lt;= 1)
                return n;
            Fibonacci f1 = new Fibonacci(n - 1);
            f1.fork();
            Fibonacci f2 = new Fibonacci(n - 2);
            return f2.compute() + f1.join();
        }
    }

    static class Fibonacci2 extends RecursiveTask&amp;lt;Integer&amp;gt; {

        final int n;

        Fibonacci2(int n) { this.n = n; }

        protected Integer compute() {
            if (n &amp;lt;= 1)
                return n;
            Fibonacci2 f1 = new Fibonacci2(n - 1);
            Fibonacci2 f2 = new Fibonacci2(n - 2);
            f1.fork();
            f2.fork();
            return f1.join() + f2.join();
        }
    }

    public static void main(String[] args) {
        int n = 30;

        long start1 = System.currentTimeMillis();
        Fibonacci fib = new Fibonacci(n);
        Integer result1 = new ForkJoinPool().invoke(fib);
        long end1 = System.currentTimeMillis();
        System.out.println(&amp;quot;Method1 result: &amp;quot; + result1 + &amp;quot;. Time: &amp;quot; + (end1 - start1) + &amp;quot;ms&amp;quot;);

        long start2 = System.currentTimeMillis();
        Fibonacci2 fib2 = new Fibonacci2(n);
        Integer result2 = new ForkJoinPool().invoke(fib2);
        long end2 = System.currentTimeMillis();
        System.out.println(&amp;quot;Method2 result: &amp;quot; + result2 + &amp;quot;. Time: &amp;quot; + (end2 - start2) + &amp;quot;ms&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>分布式锁</title>
        <link>https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
        <pubDate>Wed, 03 Aug 2022 19:53:40 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
        <description>&lt;h1 id=&#34;分布式锁&#34;&gt;分布式锁
&lt;/h1&gt;&lt;h2 id=&#34;学习目标&#34;&gt;学习目标
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是分布式&lt;/li&gt;
&lt;li&gt;什么是锁&lt;/li&gt;
&lt;li&gt;什么是分布式锁&lt;/li&gt;
&lt;li&gt;分布式锁的使用场景-为什么要使用分布式锁&lt;/li&gt;
&lt;li&gt;分布式锁需要具备哪些功能/条件&lt;/li&gt;
&lt;li&gt;分布式锁的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-分布式锁介绍&#34;&gt;1 分布式锁介绍
&lt;/h2&gt;&lt;h3 id=&#34;11-什么是分布式&#34;&gt;1.1 什么是分布式
&lt;/h3&gt;&lt;p&gt;一个大型的系统往往被分为几个子系统来做，一个子系统可以部署在一台机器的多个 JVM(java虚拟机) 上，也可以部署在多台机器上。但是每一个系统不是独立的，不是完全独立的。需要相互通信，共同实现业务功能。&lt;/p&gt;
&lt;p&gt;一句话来说：分布式就是通过计算机网络将后端工作分布到多台主机上，多个主机一起协同完成工作。&lt;/p&gt;
&lt;h3 id=&#34;12-什么是锁--作用安全&#34;&gt;1.2 什么是锁&amp;ndash;作用安全
&lt;/h3&gt;&lt;p&gt;现实生活中，当我们需要保护一样东西的时候，就会使用锁。例如门锁，车锁等等。很多时候可能许多人会共用这些资源，就会有很多个钥匙。但是有些时候我们希望使用的时候是独自不受打扰的，那么就会在使用的时候从里面反锁，等使用完了再从里面解锁。这样其他人就可以继续使用了。&lt;/p&gt;
&lt;p&gt;JAVA程序中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量，而同步的本质是通过锁来实现的。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改&lt;/p&gt;
&lt;h3 id=&#34;14-什么是分布式锁&#34;&gt;1.4 什么是分布式锁
&lt;/h3&gt;&lt;p&gt;任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。CAP&lt;/p&gt;
&lt;p&gt;当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;: 在分布式环境下，多个程序/线程都需要对某一份(或有限制)的数据进行修改时，针对程序进行控制，保证同一时间节点下，只有一个程序/线程对数据进行操作的技术。&lt;/p&gt;
&lt;h3 id=&#34;15-分布式锁的真实使用场景&#34;&gt;1.5 分布式锁的真实使用场景
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;场景一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/1.png&#34;
	width=&#34;1036&#34;
	height=&#34;702&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;354px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/2.png&#34;
	width=&#34;1221&#34;
	height=&#34;619&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;473px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;15-分布式锁的执行流程&#34;&gt;1.5 分布式锁的执行流程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/3.png&#34;
	width=&#34;1182&#34;
	height=&#34;624&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;454px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;16-分布式锁具备的条件&#34;&gt;1.6 分布式锁具备的条件
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥性&lt;/strong&gt;：同一时刻只能有一个服务(或应用)访问资源，特殊情况下有读写锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;：一致性要求保证加锁和解锁的行为是原子性的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：锁只能被持有该锁的服务(或应用)释放&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：在持有锁的服务崩溃时，锁仍能得到释放避免死锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重用性&lt;/strong&gt;：同一个客户端获得锁后可递归调用&amp;mdash;重入锁和不可重入锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公平性&lt;/strong&gt;：看业务是否需要公平，避免饿死&amp;ndash;公平锁和非公平锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持阻塞和非阻塞&lt;/strong&gt;：和 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock(long timeOut)&amp;mdash;阻塞锁和非阻塞锁==PS:::自选锁==&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用&lt;/strong&gt;：获取锁和释放锁 要高可用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;：获取锁和释放锁的性能要好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt;：锁按业务需要自动续约/自动延期&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2分布式锁的解决方案&#34;&gt;2.分布式锁的解决方案
&lt;/h2&gt;&lt;h3 id=&#34;21-数据库实现分布式锁&#34;&gt;2.1 数据库实现分布式锁
&lt;/h3&gt;&lt;h4 id=&#34;211-基于数据库表实现&#34;&gt;2.1.1 基于数据库表实现
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;：创建tb_program表，用于记录当前哪个程序正在使用数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `tb_program` (
  `program_no` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;程序的编号&#39;
  PRIMARY KEY (`program_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序访问数据时，将程序的编号（insert）存入tb_program表；&lt;/li&gt;
&lt;li&gt;当insert成功，代表该程序获得了锁，即可执行逻辑；&lt;/li&gt;
&lt;li&gt;当program_no相同的其他程序进行insert是，由于主键冲突会导致insert失败，则代表获取锁失败；&lt;/li&gt;
&lt;li&gt;获取锁成功的程序在逻辑执行完以后，删除该数据,代表释放锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;212-基于数据库的排他锁实现&#34;&gt;2.1.2 基于数据库的排他锁实现
&lt;/h4&gt;&lt;p&gt;除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。我们还用刚刚创建的那张数据库表，基于MySql的InnoDB引擎(MYSQL的引擎种类)可以通过数据库的排他锁来实现分布式锁。&lt;/p&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在查询语句后面增加&lt;code&gt;for update&lt;/code&gt;，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁&lt;/li&gt;
&lt;li&gt;获得排它锁的线程即可获得分布式锁，执行方法的业务逻辑&lt;/li&gt;
&lt;li&gt;执行完方法之后，再通过&lt;code&gt;connection.commit();&lt;/code&gt;操作来释放锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-demo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;!--依赖包--&amp;gt;
    &amp;lt;dependencies&amp;gt;
      
        &amp;lt;!-- MySql --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Test dependencies --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Book&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Book {

    // 图书ID
    private Integer id;
    // 图书名称
    private String name;
    // 图书价格
    private Float price;
    // 图书图片
    private String pic;
    // 图书描述
    private String desc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BookDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BookDao {

    /**
     * 查询所有的book数据
     * @return
     */
    List&amp;lt;Book&amp;gt; queryBookList(String name) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BookDaoImpl实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BookDaoImpl implements BookDao {

    /***
     * 查询数据库数据
     * @return
     * @throws Exception
     */
    public List&amp;lt;Book&amp;gt; queryBookList(String name) throws Exception{

        // 数据库链接
        Connection connection = null;
        // 预编译statement
        PreparedStatement preparedStatement = null;
        // 结果集
        ResultSet resultSet = null;
        // 图书列表
        List&amp;lt;Book&amp;gt; list = new ArrayList&amp;lt;Book&amp;gt;();

        try {
            // 加载数据库驱动
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            // 连接数据库
            connection = DriverManager.getConnection(&amp;quot;jdbc:mysql://39.108.189.37:3306/lucene&amp;quot;, &amp;quot;ybbmysql&amp;quot;, &amp;quot;ybbmysql&amp;quot;);
            //关闭自动提交
            connection.setAutoCommit(false);
            // SQL语句
            String sql = &amp;quot;SELECT * FROM book where id = 1 for update&amp;quot;;
            // 创建preparedStatement
            preparedStatement = connection.prepareStatement(sql);
            // 获取结果集
            resultSet = preparedStatement.executeQuery();
            // 结果集解析
            while (resultSet.next()) {
                Book book = new Book();
                book.setId(resultSet.getInt(&amp;quot;id&amp;quot;));
                book.setName(resultSet.getString(&amp;quot;name&amp;quot;));
                list.add(book);
            }
            System.out.println(name + &amp;quot;执行了for update&amp;quot;);
            System.out.println(&amp;quot;结果为:&amp;quot; + list);
            //锁行后休眠5秒
            Thread.sleep(5000);

            //休眠结束释放
            connection.commit();
            System.out.println(name + &amp;quot;结束&amp;quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {

    private BookDao bookDao = new BookDaoImpl();

    @org.junit.Test
    public void testLock() throws Exception  {
        new Thread(new LockRunner(&amp;quot;线程1&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程2&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程3&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程4&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程5&amp;quot;)).start();
        Thread.sleep(200000L);
    }

    class LockRunner implements Runnable {

        private String name;

        public LockRunner(String name) {
            this.name = name;
        }

        public void run() {
            try {
                bookDao.queryBookList(name);
            }catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/10.png&#34;
	width=&#34;870&#34;
	height=&#34;370&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;10&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;235&#34;
		data-flex-basis=&#34;564px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;213-优点及缺点&#34;&gt;2.1.3 优点及缺点
&lt;/h4&gt;&lt;p&gt;**优点：**简单，方便，快速实现&lt;/p&gt;
&lt;p&gt;**缺点：**基于数据库，开销比较大，对数据库性能可能会存在影响，服务数量比较多的情况下，数据库也要做集群，使用数据库加锁，锁状态不能同步到其他机器上面，使用insert的方式有一个同步的过程，如果访问从机是可以加到锁的。&lt;/p&gt;
&lt;h3 id=&#34;22-redis实现分布式锁&#34;&gt;2.2 Redis实现分布式锁
&lt;/h3&gt;&lt;h4 id=&#34;221-基于-redis-的-setnxexpire-getset方法做分布式锁&#34;&gt;2.2.1 基于 REDIS 的 SETNX()、EXPIRE() 、GETSET()方法做分布式锁
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setnx():setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;expire():expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;getset():这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：

getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1
getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/7.png&#34;
	width=&#34;812&#34;
	height=&#34;610&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;319px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁。&lt;/li&gt;
&lt;li&gt;get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取。&lt;/li&gt;
&lt;li&gt;计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。&lt;/li&gt;
&lt;li&gt;在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。
&lt;ol&gt;
&lt;li&gt;思路: 如果处理时间大于锁设置的超时时间, 需要先去拿到锁的预期的超时时间 和现在的锁的超时时间, 如果不一致, 说明业务处理超时的时候 锁被别的程序获取了, 所以这次的操作只能进行rollback&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在Linux虚拟机中创建redis容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker run -di &amp;ndash;name=tensquare_redis -p 6379:6379 redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pom.xml文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    
     &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;redis&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;redis实现分布式锁测试&amp;lt;/description&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
   

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RedisUtil工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class RedisUtil {
    //定义默认超时时间:单位毫秒
    private static final Integer LOCK_TIME_OUT = 10000;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 外部调用加锁方法
     */
    public Boolean tryLock(String key, Long timeout) throws Exception{

        //获取当前系统时间设置为开始时间
        Long startTime = System.currentTimeMillis();

        //设置返回默认值-false:加锁失败
        boolean flag = false;

        //死循环获取锁:1.获取锁成功退出 2.获取锁超时退出
        while(true){
            //判断是否超时
            if((System.currentTimeMillis() - startTime) &amp;gt;= timeout){
                break;
            }else{
                //获取锁
                flag = lock(key);
                //判断是否获取成功
                if(flag){
                    break;
                }else{
                    //休息0.1秒重试,降低服务压力
                    Thread.sleep(100);
                }
            }
        }
        return flag;
    }

    /**
     * 加锁实现
     * @param key
     * @return
     */
    private Boolean lock(String key){
        return (Boolean) stringRedisTemplate.execute((RedisCallback) redisConnection -&amp;gt; {
            //获取当前系统时间
            Long time = System.currentTimeMillis();

            //设置锁超时时间
            Long timeout = time + LOCK_TIME_OUT + 1;

            //setnx加锁并获取解锁结果
            Boolean result = redisConnection.setNX(key.getBytes(), String.valueOf(timeout).getBytes());

            //加锁成功返回true
            if(result){
                return true;
            }

            //加锁失败判断锁是否超时
            if(checkLock(key, timeout)){
                //getset设置值成功后,会返回旧的锁有效时间
                byte[] newtime = redisConnection.getSet(key.getBytes(), String.valueOf(timeout).getBytes());
                if(time &amp;gt; Long.valueOf(new String(newtime))){
                    return true;
                }
            }
            //默认加锁失败
            return false;
        });

    }

    /**
     * 释放锁
     */
    public Boolean release(String key){
        return (Boolean) stringRedisTemplate.execute((RedisCallback) redisConnection -&amp;gt; {
            Long del = redisConnection.del(key.getBytes());
            if (del &amp;gt; 0){
                return true;
            }
            return false;
        });
    }

    /**
     * 判断锁是否超时
     */
    private Boolean checkLock(String key, Long timeout){

        return (Boolean) stringRedisTemplate.execute((RedisCallback) redisConnection -&amp;gt; {
            //获取锁的超时时间
            byte[] bytes = redisConnection.get(key.getBytes());

            try {
                //判断锁的有效时间是否大与当前时间
                if(timeout &amp;gt; Long.valueOf(new String(bytes))){
                    return true;
                }
            }catch (Exception e){
                e.printStackTrace();
                return false;
            }
            return false;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RedisController测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(value = &amp;quot;/redis&amp;quot;)
public class RedisController {

    @Autowired
    private RedisUtil redisUtil;

    /**
     * 获取锁
     * @return
     */
    @GetMapping(value = &amp;quot;/lock/{name}&amp;quot;)
    public String lock(@PathVariable(value = &amp;quot;name&amp;quot;)String name) throws Exception{
        Boolean result = redisUtil.tryLock(name, 3000L);
        if(result){
            return &amp;quot;获取锁成功&amp;quot;;
        }
        return &amp;quot;获取锁失败&amp;quot;;
    }

    /**
     * 释放锁
     * @param name
     */
    @GetMapping(value = &amp;quot;/unlock/{name}&amp;quot;)
    public String unlock(@PathVariable(value = &amp;quot;name&amp;quot;)String name){
        Boolean result = redisUtil.release(name);
        if(result){
            return &amp;quot;释放锁成功&amp;quot;;
        }
        return &amp;quot;释放锁失败&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;222-redis锁的key键如何选择&#34;&gt;2.2.2 redis锁的key键如何选择
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果锁的key是一个定值，意味着所有加锁的线程访问同一把锁，效率非常低下&lt;/li&gt;
&lt;li&gt;所以锁的key最好不要是定值而是和业务相关的
&lt;ul&gt;
&lt;li&gt;ex：
&lt;ul&gt;
&lt;li&gt;业务逻辑是和商品相关的，加锁的目的是为了保证商品数据修改的原子性&lt;/li&gt;
&lt;li&gt;锁的key应该是和商品id相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁得名称应该如何设计
&lt;ul&gt;
&lt;li&gt;应该是和当前的服务还有业务逻辑相关联的
&lt;ul&gt;
&lt;li&gt;ex：
&lt;ul&gt;
&lt;li&gt;商品服务下的商品加锁：锁的key可以设计为=&amp;gt;shop:mer:ID:1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;223-优点及缺点&#34;&gt;2.2.3 优点及缺点
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：性能极高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：失效时间设置没有定值。设置的失效时间太短，方法没等执行完锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，如果加锁的服务奔溃了，其他获取锁的线程就可能要平白的多等一段时间，用户体验会降低。&lt;/p&gt;
&lt;h3 id=&#34;23-zookeeper实现分布式锁&#34;&gt;2.3 zookeeper实现分布式锁
&lt;/h3&gt;&lt;h4 id=&#34;231-zookeeper-锁相关基础知识&#34;&gt;2.3.1 zookeeper 锁相关基础知识
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;zookeeper 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。&lt;/li&gt;
&lt;li&gt;zookeeper  的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。&lt;/li&gt;
&lt;li&gt;子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。&lt;/li&gt;
&lt;li&gt;Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;232-zookeeper-分布式锁的原理&#34;&gt;2.3.2 zookeeper 分布式锁的原理
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取和释放锁原理&lt;/strong&gt;：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取锁的顺序原理&lt;/strong&gt;：上锁为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;232-zookeeper实现分布式锁流程&#34;&gt;2.3.2 zookeeper实现分布式锁流程
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;简易流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/5.jpg&#34;
	width=&#34;600&#34;
	height=&#34;245&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;5&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;587px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取锁流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先有一个锁根节点，lockRootNode，这可以是一个永久的节点&lt;/li&gt;
&lt;li&gt;客户端获取锁，先在 lockRootNode 下创建一个顺序的临时节点，保证客户端断开连接，节点也自动删除&lt;/li&gt;
&lt;li&gt;调用 lockRootNode 父节点的 getChildren() 方法，获取所有的节点，并从小到大排序，如果创建的最小的节点是当前节点，则返回 true,获取锁成功，否则，关注比自己序号小的节点的释放动作(exist watch)，这样可以保证每一个客户端只需要关注一个节点，不需要关注所有的节点，避免羊群效应。&lt;/li&gt;
&lt;li&gt;如果有节点释放操作，重复步骤 3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;释放锁流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要删除步骤 2 中创建的节点即可&lt;/p&gt;
&lt;h4 id=&#34;232-优点及缺点&#34;&gt;2.3.2 优点及缺点
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端如果出现宕机故障的话，锁可以马上释放&lt;/li&gt;
&lt;li&gt;可以实现阻塞式锁，通过 watcher 监听，实现起来也比较简单&lt;/li&gt;
&lt;li&gt;集群模式，稳定性比较高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一旦网络有任何的抖动，Zookeeper 就会认为客户端已经宕机，就会断掉连接，其他客户端就可以获取到锁。&lt;/li&gt;
&lt;li&gt;性能不高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。(zookeeper对外提供服务的只有leader)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-consul实现分布式锁eurekaregister保存服务的ip-端口-服务列表&#34;&gt;2.4 consul实现分布式锁(eureka/Register:保存服务的IP 端口 服务列表)
&lt;/h3&gt;&lt;h4 id=&#34;241-实现原理及流程&#34;&gt;2.4.1 实现原理及流程
&lt;/h4&gt;&lt;p&gt;基于Consul注册中心的Key/Value存储来实现分布式锁以及信号量的方法主要利用Key/Value存储API中的acquire和release操作来实现。acquire和release操作是类似Check-And-Set的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acquire操作只有当锁不存在持有者时才会返回true，并且set设置的Value值，同时执行操作的session会持有对该Key的锁，否则就返回false

release操作则是使用指定的session来释放某个Key的锁，如果指定的session无效，那么会返回false，否则就会set设置Value值，并返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/6.png&#34;
	width=&#34;1402&#34;
	height=&#34;1374&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;6&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;102&#34;
		data-flex-basis=&#34;244px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端创建会话session，得到sessionId；&lt;/li&gt;
&lt;li&gt;使用acquire设置value的值，若acquire结果为false，代表获取锁失败；&lt;/li&gt;
&lt;li&gt;acquire结果为true，代表获取锁成功，客户端执行业务逻辑；&lt;/li&gt;
&lt;li&gt;客户端业务逻辑执行完成后，执行release操作释放锁；&lt;/li&gt;
&lt;li&gt;销毁当前session，客户端连接断开。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;docker安装consul&lt;/p&gt;
&lt;p&gt;下载镜像&lt;/p&gt;
&lt;p&gt;docker pull consul&lt;/p&gt;
&lt;p&gt;开启容器&lt;/p&gt;
&lt;p&gt;docker run -p 8500:8500/tcp consul agent -server -ui -bootstrap-expect=1 -client=0.0.0.0&lt;/p&gt;
&lt;p&gt;启动consul命令: consul agent -dev&lt;/p&gt;
&lt;p&gt;pom.xml文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;demo-consul&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;demo-consul&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR3&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConsulUtil {

    private ConsulClient consulClient;

    private String sessionId = null;

    /**
     * 构造函数
     */
    public ConsulUtil(ConsulClient consulClient) {
        this.consulClient = consulClient;
    }

    /**
     * 创建session
     */
    private String createSession(String name, Integer ttl){
        NewSession newSession = new NewSession();
        //设置锁有效时长
        newSession.setTtl(ttl + &amp;quot;s&amp;quot;);
        //设置锁名字
        newSession.setName(name);
        String value = consulClient.sessionCreate(newSession, null).getValue();
        return value;
    }

    /**
     * 获取锁
     */
    public Boolean lock(String name, Integer ttl){
        //定义获取标识
        Boolean flag = false;
        //创建session
        sessionId = createSession(name, ttl);
        //死循环获取锁
        while (true){
            //执行acquire操作
            PutParams putParams = new PutParams();
            putParams.setAcquireSession(sessionId);
            flag = consulClient.setKVValue(name, &amp;quot;local&amp;quot; + System.currentTimeMillis(), putParams).getValue();
            if(flag){
                break;
            }
        }
        return flag;
    }

    /**
     * 释放锁
     */
    public Boolean release(String name){
        //执行acquire操作
        PutParams putParams = new PutParams();
        putParams.setReleaseSession(sessionId);
        Boolean value = consulClient.setKVValue(name, &amp;quot;local&amp;quot; + System.currentTimeMillis(), putParams).getValue();
        return value;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
class DemoApplicationTests {

    @Test
    public void testLock() throws Exception  {
         LoggerContext loggerContext= (LoggerContext) LoggerFactory.getILoggerFactory();
        //设置全局日志级别
        ch.qos.logback.classic.Logger logger=loggerContext.getLogger(&amp;quot;root&amp;quot;);
        logger.setLevel(Level.toLevel(&amp;quot;info&amp;quot;));
        new Thread(new LockRunner(&amp;quot;线程1&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程2&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程3&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程4&amp;quot;)).start();
        new Thread(new LockRunner(&amp;quot;线程5&amp;quot;)).start();
        Thread.sleep(200000L);
    }

    class LockRunner implements Runnable {

        private String name;

        public LockRunner(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            ConsulUtil lock = new ConsulUtil(new ConsulClient());
            try {
                if (lock.lock(&amp;quot;test&amp;quot;, 10)) {

                    System.out.println(name + &amp;quot;获取到了锁&amp;quot;);
                    //持有锁5秒
                    Thread.sleep(5000);
                    //释放锁
                    lock.release(&amp;quot;test&amp;quot;);
                    System.out.println(name + &amp;quot;释放了锁&amp;quot;);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/8.png&#34;
	width=&#34;1812&#34;
	height=&#34;523&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;8&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;346&#34;
		data-flex-basis=&#34;831px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/images/9.png&#34;
	width=&#34;1920&#34;
	height=&#34;979&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;9&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;470px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;242-优点及缺点&#34;&gt;2.4.2 优点及缺点
&lt;/h4&gt;&lt;p&gt;**优点：**基于consul注册中心即可实现分布式锁，实现简单、方便、快捷&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lock delay&lt;/strong&gt;：consul实现分布式锁存在延迟，一个节点释放锁了，另一个节点不能立马拿到锁。需要等待lock delay时间后才可以拿到锁。&lt;/li&gt;
&lt;li&gt;高负载的场景下，不能及时的续约，导致session timeout, 其他节点拿到锁。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>分布式事务</title>
        <link>https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
        <pubDate>Wed, 13 Jul 2022 19:53:40 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
        <description>&lt;h1 id=&#34;分布式事务&#34;&gt;分布式事务
&lt;/h1&gt;&lt;h2 id=&#34;学习目标&#34;&gt;学习目标
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是事务&lt;/li&gt;
&lt;li&gt;什么是分布式事务&lt;/li&gt;
&lt;li&gt;分布式事务的产生过程&lt;/li&gt;
&lt;li&gt;==什么是CAP定理（面试）==&lt;/li&gt;
&lt;li&gt;==分布式事务解决方案（面试）==&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-分布式事务介绍&#34;&gt;1 分布式事务介绍
&lt;/h2&gt;&lt;h3 id=&#34;11-什么是事务&#34;&gt;1.1 什么是事务
&lt;/h3&gt;&lt;p&gt;数据库事务(简称：事务，Transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成[由当前业务逻辑多个不同操作构成]。&lt;/p&gt;
&lt;p&gt;事务拥有以下四个特性，习惯上被称为ACID特性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性(Atomicity)&lt;/strong&gt;：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。==记录之前的版本，允许回滚。==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性(Consistency)&lt;/strong&gt;：一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。==事务开始和结束之间的中间状态不会被其他事务看到。==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性(Isolation)&lt;/strong&gt;：多个事务并发执行时，并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。==适当的破坏一致性来提升性能与并行度==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性(Durability)&lt;/strong&gt;：已被提交的事务对数据库的修改应该永久保存在数据库中。==每一次的事务提交后就会保证不会丢失。==&lt;/p&gt;
&lt;p&gt;延申拓展：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务隔离性(面试)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏读&lt;/strong&gt;：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读&lt;/strong&gt;：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A==新增==提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A==更新或删除==提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这会导致锁竞争加剧，影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事务的隔离级别(面试)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read Uncommitted&lt;/strong&gt;(读未提交)：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;(读已提交)：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeated Read&lt;/strong&gt;(可重复读)：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serialization&lt;/strong&gt;：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自行复习/了解：spring事务的传播机制(spring事务面试必问)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-什么是分布式事务&#34;&gt;1.2 什么是分布式事务
&lt;/h3&gt;&lt;p&gt;分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上，且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。&lt;/p&gt;
&lt;h3 id=&#34;13-事务的演变&#34;&gt;1.3 事务的演变
&lt;/h3&gt;&lt;h4 id=&#34;131-单服务单数据库的本地事务&#34;&gt;1.3.1 单服务单数据库的本地事务
&lt;/h4&gt;&lt;p&gt;事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1553290426650.png&#34;
	width=&#34;1164&#34;
	height=&#34;279&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1553290426650&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;417&#34;
		data-flex-basis=&#34;1001px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;132-单一服务多数据库的分布式事务&#34;&gt;1.3.2 单一服务多数据库的分布式事务
&lt;/h4&gt;&lt;p&gt;最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1553290753247.png&#34;
	width=&#34;1149&#34;
	height=&#34;432&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1553290753247&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;265&#34;
		data-flex-basis=&#34;638px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;133-多服务多数据库的分布式事务&#34;&gt;1.3.3 多服务多数据库的分布式事务
&lt;/h4&gt;&lt;p&gt;当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1553291001209.png&#34;
	width=&#34;1267&#34;
	height=&#34;412&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1553291001209&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;307&#34;
		data-flex-basis=&#34;738px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;134-多服务多数据源的分布式事务&#34;&gt;1.3.4 多服务多数据源的分布式事务
&lt;/h4&gt;&lt;p&gt;如果将上面这两种场景(一个服务可以调用多个数据库资源，也可以调用其他服务)结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1553291217001.png&#34;
	width=&#34;1261&#34;
	height=&#34;589&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1553291217001&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;214&#34;
		data-flex-basis=&#34;513px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。&lt;/p&gt;
&lt;p&gt;事务的作用：==保证每个事务的数据一致性。==&lt;/p&gt;
&lt;h3 id=&#34;14-cap定理面试&#34;&gt;1.4 CAP定理（面试）
&lt;/h3&gt;&lt;p&gt;CAP 定理，又被叫作布鲁尔定理。对于设计分布式系统(不仅仅是分布式事务)的架构师来说，CAP 就是你的入门理论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/cap.png&#34;
	width=&#34;559&#34;
	height=&#34;537&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;104&#34;
		data-flex-basis=&#34;249px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;**C (一致性)：**对某个指定的客户端来说，读操作能返回最新的写操作。&lt;/p&gt;
&lt;p&gt;对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。&lt;/p&gt;
&lt;p&gt;**A (可用性)：**非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。&lt;/p&gt;
&lt;p&gt;合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回 50，而不是返回 40。&lt;/p&gt;
&lt;p&gt;**P (网络分区容错性)：**当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。&lt;/p&gt;
&lt;p&gt;CAP定理中: 所有架构只能够满足C A P 三个中间的两个!&lt;/p&gt;
&lt;h2 id=&#34;2-分布式事务解决方案面试&#34;&gt;2 分布式事务解决方案（面试）
&lt;/h2&gt;&lt;p&gt;1.XA两段提交(强一致)&lt;/p&gt;
&lt;p&gt;2.TCC三段提交(强一致)&lt;/p&gt;
&lt;p&gt;3.本地消息表(MQ+Table)(最终一致)&lt;/p&gt;
&lt;p&gt;4.事务消息(RocketMQ[alibaba])(最终一致)&lt;/p&gt;
&lt;p&gt;==5.Seata(alibaba)==&lt;/p&gt;
&lt;p&gt;6.RabbitMQ的ACK机制实现分布式事务(拓展)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一致性拓展：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强一致性&lt;/strong&gt;：只要系统提供服务，那么数据一定一致的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弱一致性&lt;/strong&gt;：系统提供服务的时候，数据有可能不是一致的，而是要等待一段时间才能一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;：是弱一致性的特例，数据最终总会一致的，但是需要一定时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21--基于xa协议的两阶段提交2pc&#34;&gt;2.1  基于XA协议的两阶段提交(2PC)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XA协议&lt;/strong&gt;：XA 是 X/Open 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等， XA 接口函数由数据库厂商提供。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两阶段提交协议(Two Phase Commitment Protocol)中，涉及到两种角色&lt;/p&gt;
&lt;p&gt;一个事务协调者（coordinator）：负责协调多个参与者进行事务投票及提交(回滚)
多个事务参与者（participants）：即本地事务执行者&lt;/p&gt;
&lt;p&gt;总共处理步骤有两个
（1）投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）；
（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565819561657.png&#34;
	width=&#34;1128&#34;
	height=&#34;474&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565819561657&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;571px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565819640025.png&#34;
	width=&#34;1187&#34;
	height=&#34;461&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565819640025&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;257&#34;
		data-flex-basis=&#34;617px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果任一资源管理器在第一阶段返回准备失败，那么事务管理器会要求所有资源管理器在第二阶段执行回滚操作。通过事务管理器的两阶段协调，最终所有资源管理器要么全部提交，要么全部回滚，最终状态都是一致的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 尽量保证了数据的强一致（无法完全保证），适合对数据强一致要求很高的关键领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**同步阻塞问题：**执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。&lt;/li&gt;
&lt;li&gt;**单点故障：**由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）&lt;/li&gt;
&lt;li&gt;**数据不一致：**在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。&lt;/li&gt;
&lt;li&gt;**==二阶段无法解决的问题：==**协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-三段提交3pc&#34;&gt;2.2 三段提交（3PC）
&lt;/h3&gt;&lt;p&gt;三段提交是两段提交的升级版&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CanCommit阶段：询问阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/555.png&#34;
	width=&#34;876&#34;
	height=&#34;262&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;334&#34;
		data-flex-basis=&#34;802px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;类似2PC的准备阶段，协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待参与者的响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PreCommit阶段：事务执行但不提交阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/666.png&#34;
	width=&#34;996&#34;
	height=&#34;281&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;354&#34;
		data-flex-basis=&#34;850px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协调者从所有的参与者获得的反馈都是Yes响应
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送预提交请求协调者向参与者发送PreCommit请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参与者接收到PreCommit请求后，执行事务操作，并将undo（执行前数据）和redo（执行后数据）信息记录到事务日志中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参与者成功的执行了事务操作，则返回ACK（确认机制：已确认执行）响应，同时开始等待最终指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;有任何一个参与者向协调者发送了No响应，或者等待超时
&lt;ol&gt;
&lt;li&gt;协调者向所有参与者发送中断请求请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;参与者收到来自协调者的中断请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;doCommit阶段：事务提交阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/444.png&#34;
	width=&#34;996&#34;
	height=&#34;297&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;335&#34;
		data-flex-basis=&#34;804px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行提交&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;协调接收到所有参与者返回的ACK响应后，协调者向所有参与者发送doCommit请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参与者接收到doCommit请求之后，执行最终事务提交，事务提交完之后，向协调者发送Ack响应并释放所有事务资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协调者接收到所有参与者的ACK响应之后，完成事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），协调者向所有参与者发送中断请求；&lt;/li&gt;
&lt;li&gt;参与者接收到中断请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后，向协调者发送ACK消息，释放所有的事务资源。&lt;/li&gt;
&lt;li&gt;协调者接收到参与者反馈的ACK消息之后，执行事务的中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**优点：**相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。&lt;/p&gt;
&lt;p&gt;**缺点：**会导致数据一致性问题。由于网络原因，协调者发送的中断响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到中断命令并执行回滚的参与者之间存在数据不一致的情况。&lt;/p&gt;
&lt;h3 id=&#34;23-tcc补偿机制&#34;&gt;2.3 TCC补偿机制
&lt;/h3&gt;&lt;p&gt;TCC 其实就是采用的补偿机制，其核心思想是：==针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作==。三个阶段如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;操作方法&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Try&lt;/td&gt;
          &lt;td&gt;预留业务资源/数据效验-尝试检查当前操作是否可执行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Confirm&lt;/td&gt;
          &lt;td&gt;确认执行业务操作，实际提交数据，不做任何业务检查。try成功，confirm必定成功&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Cancel&lt;/td&gt;
          &lt;td&gt;执行业务出错时，需要回滚数据的状态下执行的业务逻辑&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其核心在于将业务分为两个操作步骤完成。==不依赖事务协调器对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务==。&lt;/p&gt;
&lt;img src=&#34;images\1565819838546.png&#34; alt=&#34;1565819838546&#34; style=&#34;zoom:200%;&#34; /&gt;
&lt;p&gt;例如： 小红要向小白转账100元，执行流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在 Try 阶段，要先调用远程接口检查小红的账户余额是否大于等于100元，若足够则对余额进行冻结，检查小白的账户状态是否正常。&lt;/li&gt;
&lt;li&gt;在 Confirm 阶段，执行远程调用的转账的操作，扣除小红账户100元，小白账户加100元。&lt;/li&gt;
&lt;li&gt;如果第2步执行成功，那么转账成功，小红账户解冻，流程结束。&lt;/li&gt;
&lt;li&gt;如果第二步执行失败，则调用服务A的Cancel方法，账户余额回滚100元及解冻小红账户，同时调用服务B的Cancel方法，账户扣除100元。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 跟2PC比起来，实现以及流程相对简单了一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在2 3 4步中都有可能失败，从而导致数据不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCC属于应用层的一种补偿方式，需要程序员在实现的时候多写很多补偿的代码，复杂业务场景下代码逻辑非常复杂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幂等性无法确保。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-本地消息表异步确保&#34;&gt;2.4 本地消息表（异步确保）
&lt;/h3&gt;&lt;p&gt;本地消息表这种实现方式应该是业界使用最多的，其核心思想是将==分布式事务拆分成本地事务进行处理==，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1553321000110.png&#34;
	width=&#34;801&#34;
	height=&#34;367&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1553321000110&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;523px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;==消息生产方，需要额外建一个消息表==，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。&lt;/li&gt;
&lt;li&gt;==消息消费方，需要处理这个消息==，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败， 果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。&lt;/li&gt;
&lt;li&gt;生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 一种非常经典的实现，避免了分布式事务，实现了最终一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。&lt;/p&gt;
&lt;h3 id=&#34;25-mq-事务消息&#34;&gt;2.5 MQ 事务消息
&lt;/h3&gt;&lt;p&gt;有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持（RabbitMQ、Kafka基于ACK机制）。&lt;/p&gt;
&lt;p&gt;以阿里的 RocketMQ 中间件为例，流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，注意此时这条消息消费者是无法消费到的。&lt;/li&gt;
&lt;li&gt;执行业务代码逻辑。&lt;/li&gt;
&lt;li&gt;确认发送消息，RocketMQ将消息状态标记为可消费，这个时候消费者才能真正消费到这条消息。&lt;/li&gt;
&lt;li&gt;如果步骤3确认消息发送失败，RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;正常流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/111.png&#34;
	width=&#34;800&#34;
	height=&#34;363&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;528px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;images\1.jpg&#34; style=&#34;zoom:200%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 实现了最终一致性，不需要依赖本地数据库事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 目前主流MQ中只有RocketMQ支持事务消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延申拓展：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;MQ非事务消息实现：&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;方案一：创建独立消息服务&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;&lt;u&gt;方案二：使用非事务MQ（RabbitMQ/Kafka）的ACK机制&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;26-seata&#34;&gt;2.6 Seata
&lt;/h3&gt;&lt;h4 id=&#34;261-seata简介&#34;&gt;2.6.1 Seata简介
&lt;/h4&gt;&lt;p&gt;2019 年 1 月，阿里巴巴中间件团队发起了开源项目 &lt;a class=&#34;link&#34; href=&#34;https://www.oschina.net/p/fescar&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;em&gt;Fescar&lt;/em&gt;&lt;/a&gt;&lt;em&gt;（Fast &amp;amp; Easy Commit And Rollback）&lt;/em&gt;，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fescar 开源后，蚂蚁金服加入 Fescar 社区参与共建，并在 Fescar 0.4.0 版本中贡献了 TCC 模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 Fescar 进行品牌升级，并更名为 &lt;strong&gt;Seata&lt;/strong&gt;，意为：&lt;strong&gt;Simple Extensible Autonomous Transaction Architecture&lt;/strong&gt;，是一套一站式分布式事务解决方案。&lt;/p&gt;
&lt;p&gt;Seata 融合了阿里巴巴和蚂蚁金服在分布式事务技术上的积累，并沉淀了新零售、云计算和新金融等场景下丰富的实践经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心组件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。&lt;/li&gt;
&lt;li&gt;Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。&lt;/li&gt;
&lt;li&gt;Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的事务ID（XID），XID 在微服务调用链路的上下文中传播。&lt;/li&gt;
&lt;li&gt;RM 向 TC 注册分支事务，接着执行这个分支事务并提交事务（==重点：RM在此阶段就已经执行了本地事务的提交/回滚==），最后将执行结果汇报给TC。&lt;/li&gt;
&lt;li&gt;TM 根据 TC 中所有的分支事务的执行情况，发起全局提交或回滚决议。&lt;/li&gt;
&lt;li&gt;TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/333.png&#34;
	width=&#34;960&#34;
	height=&#34;551&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;262-seata支持的模式&#34;&gt;2.6.2 Seata支持的模式
&lt;/h4&gt;&lt;p&gt;seata中有两种常见分布式事务实现方案，AT及TCC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AT模式：赖于RM拥有本地数据库事务的能力，对于客户业务无侵入性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/222.png&#34;
	width=&#34;721&#34;
	height=&#34;260&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;277&#34;
		data-flex-basis=&#34;665px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCC 模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;263-seata的优点&#34;&gt;2.6.3 Seata的优点
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;对业务无侵入&lt;/strong&gt;：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入
&lt;strong&gt;高性能&lt;/strong&gt;：减少分布式事务解决方案所带来的性能消耗(2PC)&lt;/p&gt;
&lt;h4 id=&#34;264-at模式&#34;&gt;2.6.4 AT模式
&lt;/h4&gt;&lt;p&gt;Seata AT模式是基于XA事务演进而来的一个分布式事务中间件，XA是一个基于数据库实现的分布式事务协议，本质上和两阶段提交一样，需要数据库支持，Mysql5.6以上版本支持XA协议，其他数据库如Oracle，DB2也实现了XA接口。&lt;/p&gt;
&lt;p&gt;AT模式分为两个阶段，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一阶段：本地数据备份阶段&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Seata 的 JDBC 数据源代理通过对业务 SQL 的解析，把==业务数据在变化前后的数据镜像组织成回滚日志==（XID/分支事务ID（Branch ID/变化前的数据/变化后的数据）。&lt;/li&gt;
&lt;li&gt;将回滚日志存入一张日志表UNDO_LOG（==需要手动创建==）,并对UNDO_LOG表中的这条数据形成行锁（for update）。&lt;/li&gt;
&lt;li&gt;若锁定失败，说明有其他事务在操作这条数据，它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，可以保证：&lt;strong&gt;任何提交的业务数据的更新一定有相应的回滚日志存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565820909345.png&#34;
	width=&#34;1132&#34;
	height=&#34;378&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565820909345&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;718px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于这样的机制，分支的本地事务便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。&lt;/li&gt;
&lt;li&gt;有了回滚日志之后，可以在第一阶段释放对资源的锁定，降低了锁范围，提高效率，即使第二阶段发生异常需要回滚，只需找对undolog中对应数据并反解析成sql来达到回滚目的。&lt;/li&gt;
&lt;li&gt;Seata通过代理数据源（DataSource-&amp;gt;DataSourceProxy）将业务sql的执行解析成undolog来与业务数据的更新同时入库，达到了对业务无侵入的效果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：全局事务提交/回滚&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局提交&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;所有分支事务此时已经完成提交，所有分支事务提交都正常。&lt;/li&gt;
&lt;li&gt;==TM从TC获知后会决议执行====全局提交====，TC异步通知所有的RM释放UNDO_LOG表中的行锁==，同时清理掉UNDO_LOG表中刚才释放锁的那条数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565821037492.png&#34;
	width=&#34;1218&#34;
	height=&#34;525&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565821037492&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;556px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局回滚&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;若任何一个RM一阶段事务提交失败，通知TC提交失败。&lt;/li&gt;
&lt;li&gt;==TM从TC获知后会决议执行全局回滚====，====TC向所有的RM发送回滚请求==。&lt;/li&gt;
&lt;li&gt;RM通过XID和Branch ID找到相应的回滚日志记录，&lt;strong&gt;通过回滚记录生成反向的更新 SQL 并执行&lt;/strong&gt;，以完成分支的回滚，同时释放锁，清除UNDO_LOG表中释放锁的那条数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565821069728.png&#34;
	width=&#34;1207&#34;
	height=&#34;564&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565821069728&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;214&#34;
		data-flex-basis=&#34;513px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;265-tcc模式&#34;&gt;2.6.5 TCC模式
&lt;/h4&gt;&lt;p&gt;seata也针对TCC做了适配兼容，支持TCC事务方案，原理前面已经介绍过，基本思路就是使用侵入业务上的补偿及事务管理器的协调来达到全局事务的一起提交及回滚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/1565821173446.png&#34;
	width=&#34;1223&#34;
	height=&#34;615&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565821173446&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;477px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;27-跨mysql-ip测试&#34;&gt;2.7 跨mysql ip测试
&lt;/h2&gt;&lt;p&gt;插入数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/seata-16312535244541.png&#34;
	width=&#34;1204&#34;
	height=&#34;610&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;seata&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;473px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;undo_log 表&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/seata_undo_log.png&#34;
	width=&#34;1750&#34;
	height=&#34;438&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;seata_undo_log&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;399&#34;
		data-flex-basis=&#34;958px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;发生异常&amp;ndash;回滚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/images/seata%E5%9B%9E%E6%BB%9A.png&#34;
	width=&#34;1724&#34;
	height=&#34;747&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;seata回滚&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;230&#34;
		data-flex-basis=&#34;553px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;数据库可以看到之前被修改的数据被回滚了&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CompleteableFuture</title>
        <link>https://mikeLing-qx.github.io/p/completeablefuture/</link>
        <pubDate>Fri, 03 Jun 2022 18:12:07 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/completeablefuture/</guid>
        <description>&lt;h1 id=&#34;1-概述&#34;&gt;1. 概述
&lt;/h1&gt;&lt;p&gt;常见lamda 函数式接口:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/completeablefuture/images/image-20221222102339817.png&#34;
	width=&#34;560&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221222102339817&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;273&#34;
		data-flex-basis=&#34;655px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;runAsync：异步执行没有返回值；
supplyAsync：异步执行有返回值；
thenApply：继续执行当前线程future完成的函数，不需要阻塞等待其处理完成；
thenApplyAsync：在不同线程池异步地应用参数中的函数；
thenCompose：用于多个彼此依赖的futrue进行串联起来, 串行
thenCombine：并联起两个独立的future，注意，这些future都是在长时间计算都完成以后, 并行关系 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个变种函数的第三个方法也许会发现里面都有一个 ==Executor 类型的参数==，用于指定线程池&lt;/p&gt;
&lt;p&gt;如果没有指定线程池，那自然就会有一个默认的线程池，也就是 ForkJoinPool&lt;/p&gt;
&lt;p&gt;ForkJoinPool 的线程数默认是==CPU 的核心数==&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不要所有业务共用一个线程池&lt;/strong&gt;，因为，一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成线程饥饿，进而影响整个系统的性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jdk9 升级内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加了新的工厂方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持延迟和超时处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;orTimeout()
completeOnTimeout()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-类结构&#34;&gt;2. 类结构
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/completeablefuture/images/image-20221222102610060.png&#34;
	width=&#34;475&#34;
	height=&#34;173&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221222102610060&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;274&#34;
		data-flex-basis=&#34;658px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-future&#34;&gt;1. Future
&lt;/h2&gt;&lt;p&gt;实现了 Future 接口，那就具有 Future 接口的相关特性，请脑补 Future 那少的可怜的 5 个方法，这里不再赘述，具体请查看 不会用Java Future，我怀疑你泡茶没我快&lt;/p&gt;
&lt;h2 id=&#34;2-completionstage&#34;&gt;2. CompletionStage
&lt;/h2&gt;&lt;p&gt;CompletionStage 这个接口还是挺陌生的，中文直译过来是【竣工阶段】，如果将烧水泡茶比喻成一项大工程，他们的竣工阶段体现是不一样的&lt;/p&gt;
&lt;h1 id=&#34;3-线程关系&#34;&gt;3. 线程关系
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/completeablefuture/images/image-20221222105010286.png&#34;
	width=&#34;618&#34;
	height=&#34;133&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221222105010286&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;464&#34;
		data-flex-basis=&#34;1115px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单看线程1 或单看线程 2 就是一种串行关系，做完一步之后做下一步&lt;/li&gt;
&lt;li&gt;一起看线程1 和 线程 2，它们彼此就是并行关系，两个线程做的事彼此独立互补干扰&lt;/li&gt;
&lt;li&gt;泡茶就是线程1 和 线程 2 的汇总/组合，也就是线程 1 和 线程 2 都完成之后才能到这个阶段（当然也存在线程1 或 线程 2 任意一个线程竣工就可以开启下一阶段的场景）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CompletionStage 所有函数都是用于描述任务的时序关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/completeablefuture/images/image-20221222105056465.png&#34;
	width=&#34;463&#34;
	height=&#34;255&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221222105056465&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-completeablefutute-方法总览&#34;&gt;4. CompleteableFutute 方法总览
&lt;/h1&gt;&lt;h2 id=&#34;0-常用api-概述&#34;&gt;0. 常用api 概述
&lt;/h2&gt;&lt;p&gt;参考资料: &lt;a class=&#34;link&#34; href=&#34;https://blog.51cto.com/zhangzhixi/5626288&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.51cto.com/zhangzhixi/5626288&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;==提交任务==：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;supplyAsync 需要返回值时使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;runAsync&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;==接力处理==：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;thenRun thenRunAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thenAccept thenAcceptAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thenApply thenApplyAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;handle handleAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;applyToEither applyToEitherAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;acceptEither acceptEitherAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;runAfterEither runAfterEitherAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thenCombine thenCombineAsync&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thenAcceptBoth thenAcceptBothAsync&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==获取结果==：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;join 阻塞等待，不会抛异常&lt;/li&gt;
&lt;li&gt;get 阻塞等待，会抛异常&lt;/li&gt;
&lt;li&gt;complete(T value) 不阻塞，如果任务已完成，返回处理结果。如果没完成，则返回传参value。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==总结分类==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带run的方法，无入参，无返回值。&lt;/li&gt;
&lt;li&gt;带accept的方法，有入参，无返回值。&lt;/li&gt;
&lt;li&gt;带supply的方法，无入参，有返回值。&lt;/li&gt;
&lt;li&gt;带apply的方法，有入参，有返回值。&lt;/li&gt;
&lt;li&gt;带handle的方法，有入参，有返回值，并且带异常处理。&lt;/li&gt;
&lt;li&gt;以Async结尾的方法，都是异步的，否则是同步的。&lt;/li&gt;
&lt;li&gt;以Either结尾的方法，只需完成任意一个。&lt;/li&gt;
&lt;li&gt;以Both/Combine结尾的方法，必须所有都完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;completeExceptionally(Throwable ex) 不阻塞，如果任务已完成，返回处理结果。如果没完成，抛异常。&lt;/p&gt;
&lt;h2 id=&#34;1-串行关系&#34;&gt;1. 串行关系
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;then&lt;/code&gt; 直译【然后】，也就是表示下一步，所以通常是一种串行关系体现, then 后面的单词（比如 run /apply/accept）就是上面说的函数式接口中的抽象方法名称了，它的作用和那几个函数式接口的作用是一样一样滴&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// run 是没有返回值的 
CompletableFuture&amp;lt;Void&amp;gt; thenRun(Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; thenRunAsync(Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; thenRunAsync(Runnable action, Executor executor)
  
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenApply(Function&amp;lt;? super T,? extends U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenApplyAsync(Function&amp;lt;? super T,? extends U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenApplyAsync(Function&amp;lt;? super T,? extends U&amp;gt; fn, Executor executor)
  
CompletableFuture&amp;lt;Void&amp;gt; thenAccept(Consumer&amp;lt;? super T&amp;gt; action) 
CompletableFuture&amp;lt;Void&amp;gt; thenAcceptAsync(Consumer&amp;lt;? super T&amp;gt; action)
CompletableFuture&amp;lt;Void&amp;gt; thenAcceptAsync(Consumer&amp;lt;? super T&amp;gt; action, Executor executor)
  
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenCompose(Function&amp;lt;? super T, ? extends CompletionStage&amp;lt;U&amp;gt;&amp;gt; fn)  
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenComposeAsync(Function&amp;lt;? super T, ? extends CompletionStage&amp;lt;U&amp;gt;&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; thenComposeAsync(Function&amp;lt;? super T, ? extends CompletionStage&amp;lt;U&amp;gt;&amp;gt; fn, Executor executor)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-聚合关系-and&#34;&gt;2. 聚合关系 and
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;combine... with...&lt;/code&gt; 和 &lt;code&gt;both...and...&lt;/code&gt; 都是要求两者都满足，也就是 and 的关系了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt; thenCombine(CompletionStage&amp;lt;? extends U&amp;gt; other, BiFunction&amp;lt;? super T,? super U,? extends V&amp;gt; fn)
&amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt; thenCombineAsync(CompletionStage&amp;lt;? extends U&amp;gt; other, BiFunction&amp;lt;? super T,? super U,? extends V&amp;gt; fn)
&amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt; thenCombineAsync(CompletionStage&amp;lt;? extends U&amp;gt; other, BiFunction&amp;lt;? super T,? super U,? extends V&amp;gt; fn, Executor executor)

&amp;lt;U&amp;gt; CompletableFuture&amp;lt;Void&amp;gt; thenAcceptBoth(CompletionStage&amp;lt;? extends U&amp;gt; other, BiConsumer&amp;lt;? super T, ? super U&amp;gt; action)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;Void&amp;gt; thenAcceptBothAsync(CompletionStage&amp;lt;? extends U&amp;gt; other, BiConsumer&amp;lt;? super T, ? super U&amp;gt; action)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;Void&amp;gt; thenAcceptBothAsync( CompletionStage&amp;lt;? extends U&amp;gt; other, BiConsumer&amp;lt;? super T, ? super U&amp;gt; action, Executor executor)
  
CompletableFuture&amp;lt;Void&amp;gt; runAfterBoth(CompletionStage&amp;lt;?&amp;gt; other, Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; runAfterBothAsync(CompletionStage&amp;lt;?&amp;gt; other, Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; runAfterBothAsync(CompletionStage&amp;lt;?&amp;gt; other, Runnable action, Executor executor)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-or或-关系&#34;&gt;3. or或 关系
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Either...or...&lt;/code&gt; 表示两者中的一个，自然也就是 Or 的体现了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; applyToEither(CompletionStage&amp;lt;? extends T&amp;gt; other, Function&amp;lt;? super T, U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; applyToEitherAsync(、CompletionStage&amp;lt;? extends T&amp;gt; other, Function&amp;lt;? super T, U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; applyToEitherAsync(CompletionStage&amp;lt;? extends T&amp;gt; other, Function&amp;lt;? super T, U&amp;gt; fn, Executor executor)

CompletableFuture&amp;lt;Void&amp;gt; acceptEither(CompletionStage&amp;lt;? extends T&amp;gt; other, Consumer&amp;lt;? super T&amp;gt; action)
CompletableFuture&amp;lt;Void&amp;gt; acceptEitherAsync(CompletionStage&amp;lt;? extends T&amp;gt; other, Consumer&amp;lt;? super T&amp;gt; action)
CompletableFuture&amp;lt;Void&amp;gt; acceptEitherAsync(CompletionStage&amp;lt;? extends T&amp;gt; other, Consumer&amp;lt;? super T&amp;gt; action, Executor executor)

CompletableFuture&amp;lt;Void&amp;gt; runAfterEither(CompletionStage&amp;lt;?&amp;gt; other, Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; runAfterEitherAsync(CompletionStage&amp;lt;?&amp;gt; other, Runnable action)
CompletableFuture&amp;lt;Void&amp;gt; runAfterEitherAsync(CompletionStage&amp;lt;?&amp;gt; other, Runnable action, Executor executor)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-异常处理&#34;&gt;4. 异常处理
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CompletableFuture&amp;lt;T&amp;gt; exceptionally(Function&amp;lt;Throwable, ? extends T&amp;gt; fn)
CompletableFuture&amp;lt;T&amp;gt; exceptionallyAsync(Function&amp;lt;Throwable, ? extends T&amp;gt; fn)
CompletableFuture&amp;lt;T&amp;gt; exceptionallyAsync(Function&amp;lt;Throwable, ? extends T&amp;gt; fn, Executor executor)
        
CompletableFuture&amp;lt;T&amp;gt; whenComplete(BiConsumer&amp;lt;? super T, ? super Throwable&amp;gt; action)
CompletableFuture&amp;lt;T&amp;gt; whenCompleteAsync(BiConsumer&amp;lt;? super T, ? super Throwable&amp;gt; action)
CompletableFuture&amp;lt;T&amp;gt; whenCompleteAsync(BiConsumer&amp;lt;? super T, ? super Throwable&amp;gt; action, Executor executor)
        
       
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; handle(BiFunction&amp;lt;? super T, Throwable, ? extends U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; handleAsync(BiFunction&amp;lt;? super T, Throwable, ? extends U&amp;gt; fn)
&amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; handleAsync(BiFunction&amp;lt;? super T, Throwable, ? extends U&amp;gt; fn, Executor executor)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;==exceptionally 和 whenComplete, handle 的区别==&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/completeablefuture/images/image-20221222112307270.png&#34;
	width=&#34;519&#34;
	height=&#34;241&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221222112307270&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;516px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-性能&#34;&gt;5. 性能
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;任务巨多, 如何保证性能&lt;/li&gt;
&lt;li&gt;如何观察任务的调度情况 (存在线程复用的情况)
&lt;ol&gt;
&lt;li&gt;可以使用线程池. 设置核心线程数为0, 线程存活时间为0, 保证每个任务都在新线程上执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Disruptor</title>
        <link>https://mikeLing-qx.github.io/p/disruptor/</link>
        <pubDate>Wed, 23 Mar 2022 18:14:03 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/disruptor/</guid>
        <description>&lt;h1 id=&#34;1-概述&#34;&gt;1. 概述
&lt;/h1&gt;&lt;p&gt;​    传统阻塞的队列使用锁保证线程安全，而锁通过操作系统内核上下文切换实现，会暂停线程去等待 锁，直到锁释放。&lt;/p&gt;
&lt;p&gt;​	执行这样的上下文切换，会丢失之前保存的数据和指令。由于消费者和生产者之间的速度差异，队 列总是接近满或者空的状态，这种状态会导致高水平的写入争用。&lt;/p&gt;
&lt;p&gt;==传统队列的==&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240812093605620.png&#34;
	width=&#34;912&#34;
	height=&#34;378&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240812093605620&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;579px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Disruptor其实就像一个队列一样，用于在不同的线程之间迁移数据，但是Disruptor也实现了一些&lt;/p&gt;
&lt;p&gt;其他队列没有的特性，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个“事件”可以有多个消费者，==消费者之间既可以并行处理，也可以相互依赖形成处理的先后次序==(形成一个依赖图)；&lt;/li&gt;
&lt;li&gt;预分配用于存储事件内容的内存空间；&lt;/li&gt;
&lt;li&gt;针对极高的性能目标而实现的极度优化和无锁的设计；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-核心概念&#34;&gt;2. 核心概念
&lt;/h1&gt;&lt;h2 id=&#34;1-ringbuffer&#34;&gt;1. RingBuffer
&lt;/h2&gt;&lt;p&gt;Disruptor中的数据结构，用于存储生产者生产的数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;环形的缓冲区，曾经 RingBuffer 是 Disruptor 中的最主要的对象，但从3.0版本开始，其职责被简化为仅仅负责对通过 Disruptor 进行交换的数据（事件）进行存储和更新。在一些更高级的应 用场景中，Ring Buffer 可以由用户的自定义实现来完全替代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-sequence&#34;&gt;2. Sequence
&lt;/h2&gt;&lt;p&gt;序号，在Disruptor框架中，任何地方都有序号&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;==生产者生产的数据放在RingBuffer中的哪个位置，消费者应该消费哪个位置的数据==，RingBuffer中&lt;/p&gt;
&lt;p&gt;的某个位置的数据是什么，这些==都是由这个序号来决定的==。这个序号可以简单的理解为一个AtomicLong&lt;/p&gt;
&lt;p&gt;类型的变量。==其使用了padding的方法去消除缓存的伪共享问题==。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-sequencer&#34;&gt;3. Sequencer
&lt;/h2&gt;&lt;p&gt;序号生成器，这个类主要是用来协调生产者的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在生产者生产数据的时候，Sequencer会产生一个可用的序号（Sequence），然后生产者就就知道&lt;/p&gt;
&lt;p&gt;数据放在环形队列的那个位置了。&lt;/p&gt;
&lt;p&gt;==Sequencer是Disruptor的真正核心，此接口有两个实现类 SingleProducerSequencer、 MultiProducerSequencer== ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-sequence-barrier&#34;&gt;4. &lt;strong&gt;Sequence Barrier&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;序号屏障&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们都知道，消费者在消费数据的时候，需要知道消费哪个位置的数据。消费者总不能自己想取哪&lt;/p&gt;
&lt;p&gt;个数据消费，就取哪个数据消费吧。这个SequencerBarrier起到的就是这样一个“栅栏”般的阻隔作用。&lt;/p&gt;
&lt;p&gt;你消费者想消费数据，得，我告诉你一个序号（Sequence），你去消费那个位置上的数据。要是没有数&lt;/p&gt;
&lt;p&gt;据，就好好等着吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-wait-strategy&#34;&gt;5. Wait Strategy
&lt;/h2&gt;&lt;p&gt;Wait Strategy决定了==一个消费者怎么等待生产者==将事件（Event）放入Disruptor中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设想一种这样的情景：生产者生产的非常慢，而消费者消费的非常快。那么必然会出现数据不够的&lt;/p&gt;
&lt;p&gt;情况，这个时候消费者怎么进行等待呢？WaitStrategy就是为了解决问题而诞生的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-event&#34;&gt;6. Event
&lt;/h2&gt;&lt;p&gt;​	从生产者到消费者传递的数据叫做Event。它不是一个被 Disruptor 定义的特定类型，而是由&lt;/p&gt;
&lt;p&gt;Disruptor 的使用者定义并指定&lt;/p&gt;
&lt;h2 id=&#34;7-eventhandler&#34;&gt;7. EventHandler
&lt;/h2&gt;&lt;p&gt;​	Disruptor 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现。&lt;/p&gt;
&lt;h2 id=&#34;8-producer&#34;&gt;8. Producer
&lt;/h2&gt;&lt;p&gt;​	即生产者，只是泛指调用 Disruptor 发布事件的用户代码，Disruptor 没有定义特定接口或类型。&lt;/p&gt;
&lt;h1 id=&#34;3-disruptor-入门&#34;&gt;3. Disruptor 入门
&lt;/h1&gt;&lt;p&gt;添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.lmax&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;disruptor&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;3.4.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Event 事件&lt;/li&gt;
&lt;li&gt;EventFactory 事件工厂&lt;/li&gt;
&lt;li&gt;EventHandler 事件消费者&lt;/li&gt;
&lt;li&gt;wait strategy 等待策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-创建事件&#34;&gt;1. 创建事件
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;首先创建一个 LongEvent 类，这个类将会被放入环形队列中作为消息内容。&lt;/p&gt;
&lt;p&gt;事件(Event)就是通过 Disruptor 进行交换的数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LongEvent {
    private long value;

    public void set(long value) {
        this.value = value;
    }

    public long getValue() {
        return value;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-定义事件工厂&#34;&gt;2. 定义事件工厂
&lt;/h2&gt;&lt;p&gt;==为了使用Disruptor的内存预分配event，我们需要定义一个EventFactory==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事件工厂(Event Factory)定义了==如何实例化前面第1步中定义的事件(Event)==，需要实现接口 com.lmax.disruptor.EventFactory&lt;T&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Disruptor 通过 EventFactory 在 RingBuffer 中预创建 Event 的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 Event 实例实际上被用作一个“数据槽”，发布者发布前，先从 RingBuffer 获得一个 Event 的实&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例，然后往 Event 实例中填充数据，之后再发布到 RingBuffer 中，之后由 Consumer 获得该 Event 实&lt;/p&gt;
&lt;p&gt;例并从中读取数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; {
    public LongEvent newInstance() {
        return new LongEvent();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-定义事件处理的-handler&#34;&gt;3. 定义事件处理的 handler
&lt;/h2&gt;&lt;p&gt;为了让消费者处理这些事件，所以我们这里定义一个事件处理器，负责打印event&lt;/p&gt;
&lt;p&gt;通过实现接口 com.lmax.disruptor.EventHandler&lt;T&gt; 定义事件处理的具体实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LongEventHandler implements EventHandler&amp;lt;LongEvent&amp;gt; {
    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) {
        CommonUtils.calculation();
        //  System.out.println(&amp;quot;consumer:&amp;quot; + Thread.currentThread().getName() + &amp;quot; Event: value=&amp;quot; + event.getValue() + &amp;quot;,sequence=&amp;quot; + sequence + &amp;quot;,endOfBatch=&amp;quot; + endOfBatch);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-等待策略&#34;&gt;4. 等待策略
&lt;/h2&gt;&lt;p&gt;Disruptor 定义了 com.lmax.disruptor.WaitStrategy 接口用于抽象 Consumer 如何等待新事件， 这是策略模式的应用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WaitStrategy YIELDING_WAIT = new YieldingWaitStrategy();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-启动disruptor&#34;&gt;5. 启动Disruptor
&lt;/h2&gt;&lt;p&gt;RingBuffer 必须是2的n次方&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
        // 指定事件工厂
        LongEventFactory factory = new LongEventFactory();

        // 指定 ring buffer字节大小, 必须是2的N次方
        int bufferSize = 1024;

        //单线程模式，获取额外的性能
        Disruptor&amp;lt;LongEvent&amp;gt; disruptor = new Disruptor&amp;lt;LongEvent&amp;gt;(factory,
                bufferSize, Executors.defaultThreadFactory(),
                ProducerType.SINGLE,
                new YieldingWaitStrategy());

        //设置事件业务处理器---消费者
        disruptor.handleEventsWith(new LongEventHandler());

        //启动disruptor线程
        disruptor.start();
        // 获取 ring buffer环，用于接取生产者生产的事件
        RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer = disruptor.getRingBuffer();

        //为 ring buffer指定事件生产者
        LongEventProducerWithTranslator producer = new LongEventProducerWithTranslator(ringBuffer);
        //循环遍历
        for (int i = 0; i &amp;lt; 100; i++) {
            //获取一个随机数
            long value = (long) ((Math.random() * 1000000) + 1);
            //发布数据
            producer.onData(value);
        }
        //停止disruptor线程
        disruptor.shutdown();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6--使用translators发布事件&#34;&gt;6.  使用Translators发布事件
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于加入了丰富的Lambda风格的API，可以用来帮组开发人员简化流 程。所以在3.0版本后==首选使用Event Publisher/Event Translator来发布事件==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Event Publisher&lt;/strong&gt; 负责将事件发布到 Disruptor 的 &lt;code&gt;RingBuffer&lt;/code&gt; 中。它的主要任务是将新的事件放入 &lt;code&gt;RingBuffer&lt;/code&gt; 中，以供消费者线程进行处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Translator&lt;/strong&gt; 是一个用于将外部数据转换为 Disruptor 事件的接口。它负责将传入的数据转换为 Disruptor 内部的事件对象，并将其放入 &lt;code&gt;RingBuffer&lt;/code&gt; 中进行处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EventTranslator&lt;/code&gt; 是一个接口，通常通过实现 &lt;code&gt;EventTranslatorOneArg&lt;/code&gt;, &lt;code&gt;EventTranslatorTwoArg&lt;/code&gt;, 或 &lt;code&gt;EventTranslatorThreeArg&lt;/code&gt; 接口来创建。不同的接口支持不同数量的参数传递。&lt;/li&gt;
&lt;li&gt;在发布事件时，==Event Publisher 会使用 Event Translator 来进行数据转换==。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class LongEventProducerWithTranslator {
    private final RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer;

    public LongEventProducerWithTranslator(RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer) {
        this.ringBuffer = ringBuffer;
    }

    private static final EventTranslatorOneArg&amp;lt;LongEvent, Long&amp;gt; TRANSLATOR =
            new EventTranslatorOneArg&amp;lt;LongEvent, Long&amp;gt;() {
                public void translateTo(LongEvent event, long sequence, Long data) {
                    event.set(data);
                }
            };

    public void onData(Long data) {
        ringBuffer.publishEvent(TRANSLATOR, data);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-高性能原理&#34;&gt;4. 高性能原理
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引入环形的数组结构：数组元素不会被回收，避免频繁的GC，&lt;/li&gt;
&lt;li&gt;无锁的设计：采用CAS无锁方式，保证线程的安全性&lt;/li&gt;
&lt;li&gt;属性填充：通过添加额外的无用信息，避免伪共享问题&lt;/li&gt;
&lt;li&gt;元素位置的定位：采用跟一致性哈希一样的方式，一个索引，进行自增&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240812182506385.png&#34;
	width=&#34;781&#34;
	height=&#34;400&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240812182506385&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;195&#34;
		data-flex-basis=&#34;468px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;0-mesi-协议&#34;&gt;0. MESI 协议
&lt;/h2&gt;&lt;p&gt;​	 &lt;strong&gt;MESI 协议&lt;/strong&gt;（Modified, Exclusive, Shared, Invalid）是一种缓存一致性协议，用于确保多核处理器系统中的缓存数据的一致性。它确保各个核心的缓存中保存的数据保持同步，避免数据冲突和不一致。下面是 MESI 协议的四种状态及其简单解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Modified（修改）&lt;/strong&gt;：数据在该缓存中是修改过的，并且是唯一的拷贝。其他缓存没有这块数据。这个缓存中的数据已被更改，但尚未写回主内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exclusive（独占）&lt;/strong&gt;：数据在该缓存中是唯一的拷贝，并且与主内存中的数据一致。该缓存中的数据没有被修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared（共享）&lt;/strong&gt;：数据可能存在于一个或多个缓存中，并且与主内存中的数据一致。这意味着其他缓存也有这块数据的拷贝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Invalid（无效）&lt;/strong&gt;：数据在该缓存中是无效的，不可靠。缓存中的数据可能已被其他缓存修改或更新，不能再使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==类比解释==&lt;/p&gt;
&lt;p&gt;想象你和你的朋友在一个图书馆里读书，你们都有一个笔记本记录书中的内容。这就像是缓存的工作，每个人都有自己的“缓存”（笔记本）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Modified（修改）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;你在笔记本上写下了一些新的笔记，并且这些笔记是你自己写的，没有别人写过。你笔记本上的内容与图书馆的原书（主内存）不一致，因为你做了修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exclusive（独占）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;你有一本独特的书，只有你拥有。这本书的内容完全和图书馆的原书一致，没有人修改过它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared（共享）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;你和你的朋友都有相同的笔记内容，你们都在各自的笔记本上记录了这些内容。这些内容和图书馆的原书一致，但有多个人都有这些笔记。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Invalid（无效）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;你发现你的笔记本上有一些过时的内容，这些内容已经不再准确了，因为图书馆的原书已经更新了，你的笔记需要更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-缓存行&#34;&gt;1. 缓存行
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;缓存行（Cache Line）是现代计算机体系结构中缓存的基本单位。它是处理器缓存（如 L1、L2、L3 缓存）中的一个数据块，用于提高内存访问的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理器缓存中的数据块，通常大小为 64 字节&lt;/p&gt;
&lt;h2 id=&#34;2-伪共享&#34;&gt;2. 伪共享
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;当多个==线程操作的变量位于同一个缓存行中时，即使这些变量并不相互干扰，也可能导致性能问题==。这种现象称为伪共享。伪共享会导致==处理器频繁地更新缓存行，增加缓存一致性协议的开销，从而降低性能==。 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	 解决伪共享的一种方法是将每个线程的变量放在不同的缓存行中，从而避免它们位于同一个缓存行中。另一个方法是==使用缓存行填充技术==，将==相关的数据放置在缓存行的不同部分==。&lt;/p&gt;
&lt;h2 id=&#34;3-无锁设计&#34;&gt;3. 无锁设计
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题，而且在上 下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失，用户态的锁虽然避 免了这些问题，但是其实它们只是在没有真实的竞争时才有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个线程持有锁会导致其它所有需要此锁的线程挂起直至该锁释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个优先级高的线程等待一个优先级低的线程释放锁会导致导致优先级反转(Priority&lt;/p&gt;
&lt;p&gt;Inversion)，引起性能风险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-cas-比较与交换&#34;&gt;1. CAS 比较与交换
&lt;/h3&gt;&lt;p&gt;CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，  否则不修改并告诉V的值实际为多少”, 乐观锁 技术，当多个线程尝试使用CAS同时更新同一 个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被 告知这次竞争中失败，并可以再次尝试&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813094611390.png&#34;
	width=&#34;719&#34;
	height=&#34;400&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813094611390&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-disruptor-的无锁设计&#34;&gt;2. Disruptor 的无锁设计
&lt;/h3&gt;&lt;p&gt;多线程环境下，多个生产者通过do/while循环的条件CAS，来判断每次申请的空间是否已经被其他 生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;do {
    current = cursor.get();
    next = current + n;
    if (!hasAvailableCapacity(gatingSequences, n, current)) {
    	throw InsufficientCapacityException.INSTANCE;
	}
}
while (!cursor.compareAndSet(current, next));
//next 类比于ArrayBlockQueue的数组索引index
return next;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-环形数组&#34;&gt;3. 环形数组
&lt;/h3&gt;&lt;p&gt;​	为数组预先分配内存，使得数组对象一直存在, 这样就 不需要花大量的时间用于垃圾回收。  数组的大小为2的n次方，这样==元素定位可以通过位运算效率会更高==&lt;/p&gt;
&lt;h1 id=&#34;5-等待策略&#34;&gt;5. 等待策略
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;BlockingWaitStrategy&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Disruptor的==默认策略==是BlockingWaitStrategy，在BlockingWaitStrategy内部是使用锁和condition 来控制线程的唤醒 ==BlockingWaitStrategy是最低效的策略==，==但其对CPU的消耗最小并且在各种不同部署环境中能提供 更加一致的性能表现==。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;SleepingWaitStrategy&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其 对生产者线程的影响最小，通过使用 LockSupport.parkNanos(1) 来实现循环等待，适合用于异步日志&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;YieldingWaitStrategy&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;YieldingWaitStrategy是可以使用在低延迟系统的策略之一，YieldingWaitStrategy将自旋以等待序 列增加到适当的值。在循环体内，将调用 Thread.yield() 以允许其他排队的线程运行。在要求极高性 能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;BusySpinWaitStrategy&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;性能最好，适合用于低延迟的系统，在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景 中，推荐使用此策略；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;PhasedBackoffWaitStrategy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不的场景。&lt;/p&gt;
&lt;h1 id=&#34;6-生产和消费模式&#34;&gt;6. 生产和消费模式
&lt;/h1&gt;&lt;p&gt;==在Disruptor中生产者分为单生产者和多生产者，而消费者并没有区分==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单生产者情况下，就是普通的生产者向RingBuffer中放置数据，消费者获取最大可消费的位置，并 进行消费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多生产者时候，又多出了一个跟RingBuffer同样大小的Buffer，==称为AvailableBuffer==。 在多生产者中，每个生产者==首先通过CAS竞争获取可以写的空间，然后再进行慢慢往里放数据==，如 果正好这个时候消费者要消费数据，那么==每个消费者都需要获取最大可消费的下标==，这个下标是在 AvailableBuffer进行获取得到的最长连续的序列下标。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-单生产者生产数据&#34;&gt;1. 单生产者生产数据
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;申请写入m个元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是返回的正确，则生产者开始写入元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813175746936.png&#34;
	width=&#34;609&#34;
	height=&#34;822&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813175746936&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;74&#34;
		data-flex-basis=&#34;177px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-多生产者生产数据&#34;&gt;2. 多生产者生产数据
&lt;/h2&gt;&lt;p&gt;​	多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法 是，==每个线程获取不同的一段数组空间进行操作==。这个通过CAS很容易达到。==只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去==即可。&lt;/p&gt;
&lt;p&gt;但是会遇到一个新问题：&lt;/p&gt;
&lt;p&gt;==如何防止读取的时候，读到还未写的元素==。Disruptor在多个生产者的情况&lt;/p&gt;
&lt;p&gt;下，引入了一个与Ring Buffer大小相同的buffer：==available Buffer。当某个位置写入成功的时候，便把 availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素 是否已经就绪==。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;申请写入m个元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已 经写入成功的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下 标3到下表5的空间，Writer2被分配了下标6到下标9的空间。&lt;/p&gt;
&lt;p&gt;Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后 移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813180738850.png&#34;
	width=&#34;1112&#34;
	height=&#34;812&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813180738850&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;136&#34;
		data-flex-basis=&#34;328px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-多生产者消费数据&#34;&gt;3. 多生产者消费数据
&lt;/h2&gt;&lt;p&gt;​    假设三个生产者在写中，==还没有置位AvailableBuffer，那么消费者可获取的消费下标只能获取到 6==然后等生产者都写OK后，通知到消费者，消费者继续重复上面的步骤&lt;/p&gt;
&lt;p&gt;==消费流程==&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;申请读取到序号n；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若writer cursor &amp;gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;消费者读取元素&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相&lt;/p&gt;
&lt;p&gt;应位置写数据，==写线程被分配到的最大元素下标是11==。&lt;/p&gt;
&lt;p&gt;==读线程申请读取到下标从3到11的元素，判断writer cursor&amp;gt;=11。然后开始读取 availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回 6==。&lt;/p&gt;
&lt;p&gt;然后，消费者读取下标从3到6共计4个元素。 ==也就是只能读到写线程最小的下标==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;7-高级使用&#34;&gt;7. 高级使用
&lt;/h1&gt;&lt;h2 id=&#34;1-单一写者模式&#34;&gt;1. 单一写者模式
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在并发系统中==提高性能最好的方式之一就是单一写者原则==，对Disruptor也是适用的。如果在你的代&lt;/p&gt;
&lt;p&gt;码中仅仅有一个事件生产者，那么可以设置为单一生产者模式来提高系统的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813182722192.png&#34;
	width=&#34;849&#34;
	height=&#34;430&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813182722192&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;473px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-串行消费&#34;&gt;2. 串行消费
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;比如：现在触发一个注册Event，需要有一个Handler来存储信息，一个Hanlder来发邮件等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813182837661.png&#34;
	width=&#34;993&#34;
	height=&#34;188&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813182837661&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;528&#34;
		data-flex-basis=&#34;1267px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 串行依次执行
* &amp;lt;br/&amp;gt;
* p --&amp;gt; c11 --&amp;gt; c21
* @param disruptor
*/
public static void serial(Disruptor&amp;lt;LongEvent&amp;gt; disruptor){
	disruptor.handleEventsWith(new C11EventHandler()).then(new
		C21EventHandler());
	disruptor.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-菱形消费&#34;&gt;3. 菱形消费
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813182938505.png&#34;
	width=&#34;950&#34;
	height=&#34;391&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813182938505&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;242&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void diamond(Disruptor&amp;lt;LongEvent&amp;gt; disruptor){
	disruptor.handleEventsWith(new C11EventHandler(),new
	C12EventHandler()).then(new C21EventHandler());
	disruptor.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-链式并行&#34;&gt;4. 链式并行
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813183002057.png&#34;
	width=&#34;1018&#34;
	height=&#34;439&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813183002057&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;556px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void chain(Disruptor&amp;lt;LongEvent&amp;gt; disruptor){
	disruptor.handleEventsWith(new C11EventHandler()).then(new
	C12EventHandler());
	disruptor.handleEventsWith(new C21EventHandler()).then(new
	C22EventHandler());
	disruptor.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-相互隔离&#34;&gt;5. 相互隔离
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/disruptor/images/image-20240813190405817.png&#34;
	width=&#34;1036&#34;
	height=&#34;451&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240813190405817&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;551px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void parallelWithPool(Disruptor&amp;lt;LongEvent&amp;gt; disruptor){
	disruptor.handleEventsWithWorkerPool(new C11EventHandler(),new
C11EventHandler());
	disruptor.handleEventsWithWorkerPool(new C21EventHandler(),new
C21EventHandler());
	disruptor.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-航道模式&#34;&gt;6. 航道模式
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 串行依次执行,同时C11，C21分别有2个实例
* &amp;lt;br/&amp;gt;
* p --&amp;gt; c11 --&amp;gt; c21
* @param disruptor
*/
public static void serialWithPool(Disruptor&amp;lt;LongEvent&amp;gt; disruptor){
	disruptor.handleEventsWithWorkerPool(new C11EventHandler(),new
		C11EventHandler()).then(new C21EventHandler(),new C21EventHandler());
	disruptor.start();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>JUC_01</title>
        <link>https://mikeLing-qx.github.io/p/juc_01/</link>
        <pubDate>Tue, 23 Jun 2020 10:53:40 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/juc_01/</guid>
        <description>&lt;h1 id=&#34;jucjavautilcurrent多线程-一&#34;&gt;JUC（java.util.current）多线程 (一)
&lt;/h1&gt;&lt;h2 id=&#34;1-多线程基础&#34;&gt;1. 多线程基础
&lt;/h2&gt;&lt;h3 id=&#34;11-目标&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;p&gt;​	理解多线程技术的一些基本概念。&lt;/p&gt;
&lt;h3 id=&#34;12-路径&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;多线程的概念及作用&lt;/li&gt;
&lt;li&gt;线程和进程的介绍&lt;/li&gt;
&lt;li&gt;多线程的创建&lt;/li&gt;
&lt;li&gt;
&lt;h6 id=&#34;用户线程和守护线程&#34;&gt;用户线程和守护线程
&lt;/h6&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;h4 id=&#34;131-多线程的概念及作用&#34;&gt;1.3.1 多线程的概念及作用
&lt;/h4&gt;&lt;p&gt;​	    一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。&lt;/p&gt;
&lt;p&gt;​	   更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。&lt;/p&gt;
&lt;p&gt;​	   &lt;strong&gt;简单说，多线程就是以空间（cpu的占用）换时间(响应时间)，期望以更多的资源消耗（cpu）来减少响应时间，提高执行速度的技术。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;132-线程和进程&#34;&gt;1.3.2 线程和进程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	是指一个内存中运行的应用程序，每个进程都有一个&lt;strong&gt;独立的内存空间&lt;/strong&gt;，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为一个进程便相当于一个单 CPU 操作系统，而线程便是这个系统中运行的多个任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程与线程的区别：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。&lt;/p&gt;
&lt;p&gt;​	线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆空间:   存储对象实例和数组的内存区域&lt;/li&gt;
&lt;li&gt;栈空间:  用于存储局部变量、函数参数和返回地址,  栈的大小通常在线程创建时确定，并在线程生命周期内保持不变&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于
CPU 的调度，程序员是不能完全控制的（可以设置线程优先级）。而这也就造成的多线程的随机性。&lt;/li&gt;
&lt;li&gt;Java 程序的进程里面至少包含两个线程，==主线程也就是 main()方法线程，另外一个是垃圾回收机制线程==。每
当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个
线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。&lt;/li&gt;
&lt;li&gt;由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建
多线程，而不是创建多进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;133-多线程的创建&#34;&gt;1.3.3 多线程的创建
&lt;/h4&gt;&lt;p&gt;创建Maven工程，编写测试类&lt;/p&gt;
&lt;h5 id=&#34;1继承thread类&#34;&gt;1.继承Thread类
&lt;/h5&gt;&lt;p&gt;​	第一种继承Thread类 重写run方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo1CreateThread extends Thread {

    public static void main(String[] args) throws InterruptedException {

        System.out.println(&amp;quot;-----多线程创建开始-----&amp;quot;);
        // 1.创建一个线程
        CreateThread createThread1 = new CreateThread();
        CreateThread createThread2 = new CreateThread();
        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法
        System.out.println(&amp;quot;-----多线程创建启动-----&amp;quot;);
        createThread1.start();
        createThread2.start();
        System.out.println(&amp;quot;-----多线程创建结束-----&amp;quot;);
    }

    static class CreateThread extends Thread {
        public void run() {
            String name = Thread.currentThread().getName();
            for (int i = 0; i &amp;lt; 5; i++) {
                System.out.println(name + &amp;quot;打印内容是:&amp;quot; + i);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2实现runnable接口&#34;&gt;2.实现Runnable接口
&lt;/h5&gt;&lt;p&gt;​	实现Runnable接口,重写run方法&lt;/p&gt;
&lt;p&gt;​	实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo2CreateRunnable {

    public static void main(String[] args) {
        System.out.println(&amp;quot;-----多线程创建开始-----&amp;quot;);
        // 1.创建线程
        CreateRunnable createRunnable = new CreateRunnable();
        Thread thread1 = new Thread(createRunnable);
        Thread thread2 = new Thread(createRunnable);
        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法
        System.out.println(&amp;quot;-----多线程创建启动-----&amp;quot;);
        thread1.start();
        thread2.start();
        System.out.println(&amp;quot;-----多线程创建结束-----&amp;quot;);
    }

    static class CreateRunnable implements Runnable {

        public void run() {
            String name = Thread.currentThread().getName();
            for (int i = 0; i &amp;lt; 5; i++) {
                System.out.println(name + &amp;quot;的内容:&amp;quot; + i);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;实现Runnable接口比继承Thread类所具有的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;==适合多个相同的程序代码的线程去共享同一个资源==。&lt;/li&gt;
&lt;li&gt;==可以避免java中的单继承的局限性==。&lt;/li&gt;
&lt;li&gt;增加程序的健壮性，实现解耦操作，==代码可以被多个线程共享，代码和数据独立==。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3匿名内部类方式&#34;&gt;3.匿名内部类方式
&lt;/h5&gt;&lt;p&gt;​	使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo3Runnable {
    public static boolean exit = true;

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            public void run() {
                String name = Thread.currentThread().getName();
                for (int i = 0; i &amp;lt; 5; i++) {
                    System.out.println(name + &amp;quot;执行内容：&amp;quot; + i);
                }
            }
        }).start();

        new Thread(new Runnable() {
            public void run() {
                String name = Thread.currentThread().getName();
                for (int i = 0; i &amp;lt; 5; i++) {
                    System.out.println(name + &amp;quot;执行内容：&amp;quot; + i);
                }
            }
        }).start();

        Thread.sleep(1000l);
    }
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面我们介绍了创建多线程的两种方式实现Runnable接口和继承Thread类，接下来看这个demo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	static Integer num = 0;
    public static void main(String[] args) {
     	Runnable runnable = new Runnable() {
            @Override
            public void run() {
                while (num&amp;lt;10000){
                    num++;
                }
            }
        };
        new Thread(runnable).start();
        //TODO。。。。。。。
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想要获取该线程执行完毕之后num的值，但是我们如何确定线程已经执行完毕了呢,当然我们可以等待一段时间让线程执行完毕，但是等待多久呢，很难估计一个准确的时间，那么有没有更好的办法。当然有，可以使用Callable接口和FutureTask来解决。&lt;/p&gt;
&lt;h5 id=&#34;4实现callable接口使用futuretask&#34;&gt;4.实现Callable接口，使用FutureTask
&lt;/h5&gt;&lt;p&gt;改造上面的案例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	static Integer num = 0;
    public static void main(String[] args) {
       Callable&amp;lt;String&amp;gt; callableTask = new Callable(){
            @Override
            public String call() throws Exception {
                while (num&amp;lt;10000){
                    num++;
                }
                return &amp;quot;ok&amp;quot;;
            }
        };
        FutureTask&amp;lt;String&amp;gt; stringFutureTask = new FutureTask(callableTask);

        new Thread(stringFutureTask).start();

        try {
            if(&amp;quot;ok&amp;quot;.equals(stringFutureTask.get())){
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println(num);
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们可以优雅的拿到一个线程执行的结果了，但是如果是多个线程呢，又该如何解决线程执行完毕的通知行为呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    static Integer num = 0;
    public static void main(String[] args) {
        Callable&amp;lt;String&amp;gt; callableTask = new Callable(){
            @Override
            public String call() throws Exception {
                while (num&amp;lt;10000){
                    //System.out.println(Thread.currentThread().getName());
                    num++;
                }
                return &amp;quot;ok&amp;quot;;
            }
        };
        FutureTask&amp;lt;String&amp;gt; stringFutureTask = new FutureTask(callableTask);

        for (int i = 0; i &amp;lt; 10; i++) {
            new Thread(stringFutureTask).start();
        }

        try {
            if(&amp;quot;ok&amp;quot;.equals(stringFutureTask.get())){
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println(num);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用10个线程模拟获取多线程情况下的执行结果，看起来代码好像没有问题，但是如果取消System.out.println(Thread.currentThread().getName());的注释，你会发现，一直是同一个线程在执行，说好的多线程呢？那么为什么会出现这种情况，我们翻开FutureTask的源码，能够作为Thread的参数，那么它必是一个runnable接口的实现类，我们直接找它的run方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void run() {
        if (state != NEW ||
            //这里是一个cas方法，意味着同时只有一个线程会执行callable的call方法。
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable&amp;lt;V&amp;gt; c = callable;
            if (c != null &amp;amp;&amp;amp; state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s &amp;gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们发现futureTask并不能支持多个线程同时执行，它只能支持&lt;strong&gt;一个线程等待另一个线程执行的结果&lt;/strong&gt;时使用，那么我们又该如何解决多线程的异步通知问题呢，这个我们到之后学习了juc的CAS，AQS以及一些工具类之后再回来思考，先挖一个坑在这里。&lt;/p&gt;
&lt;h4 id=&#34;134-用户线程和守护线程&#34;&gt;1.3.4 用户线程和守护线程
&lt;/h4&gt;&lt;p&gt;Java中有两种线程，一种是用户线程，另一种是守护线程。&lt;/p&gt;
&lt;p&gt;用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止。&lt;/p&gt;
&lt;p&gt;守护线程当进程不存在或主线程停止，守护线程也会被停止。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo4Daemon {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i &amp;lt; 10; i++) {
                    try {
                        Thread.sleep(10);
                    } catch (Exception e) {
                    }
                    System.out.println(&amp;quot;子线程...&amp;quot; + i);
                }
            }
        });
		
        // 设置线程为守护线程
        //thread.setDaemon(true);
        thread.start();

        for (int i = 0; i &amp;lt; 5; i++) {
            try {
                Thread.sleep(10);
                System.out.println(&amp;quot;主线程&amp;quot; + i);
            } catch (Exception e) {

            }
        }

        System.out.println(&amp;quot;主线程执行完毕!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-小结&#34;&gt;1.4 小结
&lt;/h3&gt;&lt;p&gt;多线程：通过空间（cpu的时间片的利用）换取响应时间&lt;/p&gt;
&lt;p&gt;线程和进程的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程：程序的一次执行，进程之间内存是独立的，无法共享内存空间，至少有一个线程。&lt;/li&gt;
&lt;li&gt;线程：进程内部的最小执行单元，线程之间是共享堆内存，栈内存是独立的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建线程的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类，重写run方法&lt;/li&gt;
&lt;li&gt;实现Runnable接口，实现里面的run方法&lt;/li&gt;
&lt;li&gt;匿名内部类实现Runnable接口，New Thread(()-&amp;gt;执行内容)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的执行：一定要用Start方法执行线程，如果run方法执行是直接执行类的方法，不会以线程的方式执行&lt;/p&gt;
&lt;p&gt;用户线程和守护线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户线程：一般是用户创建的，不会随着主线程的终止而终止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;守护线程：一般是系统创建的，会随着主线的终止而终止，垃圾回收线程就是守护线程，可以使用Thread::setDaemon方法将用户线程转化为守护线程&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-线程安全&#34;&gt;2 线程安全
&lt;/h2&gt;&lt;h3 id=&#34;11-目标-1&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;p&gt;​	理解多线程技术的一些基本概念。&lt;/p&gt;
&lt;h3 id=&#34;12-路径-1&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;通过案例演示理解线程安全的重要性&lt;/li&gt;
&lt;li&gt;保证线程安全的方案&lt;/li&gt;
&lt;li&gt;死锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解-1&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;p&gt;线程安全：当多个线程执行一段程序的时候，如果可能发生和预期结果不一致的情况，就是线程不安全的。如果一致就是线程安全，一般线程安全的问题都是伴随着共享变量发生的，只有代码满足了原子性，可见性，有序性才是线程安全的，有一个不满足就不是线程安全。&lt;/p&gt;
&lt;h4 id=&#34;131卖票案例&#34;&gt;1.3.1.卖票案例
&lt;/h4&gt;&lt;p&gt;​	如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的，反之则是线程不安全的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo5Ticket {

    public static void main(String[] args) {
        //创建线程任务对象
        Ticket ticket = new Ticket();
        //创建三个窗口对象
        Thread t1 = new Thread(ticket, &amp;quot;窗口1&amp;quot;);
        Thread t2 = new Thread(ticket, &amp;quot;窗口2&amp;quot;);
        Thread t3 = new Thread(ticket, &amp;quot;窗口3&amp;quot;);

        //卖票
        t1.start();
        t2.start();
        t3.start();
    }

    static class Ticket implements Runnable {

        //Object lock = new Object();
        ReentrantLock lock = new ReentrantLock();
        private int ticket = 10;

        public void run() {
            String name = Thread.currentThread().getName();
            while (true) {
                sell(name);
                if (ticket &amp;lt;= 0) {
                    break;
                }
            }
        }

        private void sell(String name) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (ticket &amp;gt; 0) {
                System.out.println(name + &amp;quot;卖票：&amp;quot; + ticket);
                ticket--;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写
操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，
否则的话就可能影响线程安全。&lt;/p&gt;
&lt;h4 id=&#34;132线程同步&#34;&gt;1.3.2.线程同步
&lt;/h4&gt;&lt;p&gt;当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。
要解决上述多线程并发访问一个资源的安全问题，Java中提供了同步机制(synchronized)来解决。&lt;/p&gt;
&lt;p&gt;synchronized都是对象锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步代码块&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object lock = new Object(); //创建锁
synchronized(lock){
     //可能会产生线程安全问题的代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同步方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//同步方法 this对象
public synchronized void method(){
   //可能会产生线程安全问题的代码 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步方法使用的是this锁&lt;/p&gt;
&lt;p&gt;证明方式: 一个线程使用同步代码块(this明锁),另一个线程使用同步函数。如果两个线程抢票不能实现同步，那么会出现数据错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用this锁的同步代码块
synchronized(this){
     //需要同步操作的代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.synchronized(lock)，对lock加锁&lt;/p&gt;
&lt;p&gt;2.同步方法：this锁&lt;/p&gt;
&lt;p&gt;3.静态同步方法：当前类的class对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lock锁&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Lock lock = new ReentrantLock();
lock.lock();
	//需要同步操作的代码
lock.unlock();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133死锁&#34;&gt;1.3.3.死锁
&lt;/h4&gt;&lt;p&gt;多线程死锁：同步中嵌套同步,导致锁无法释放。&lt;/p&gt;
&lt;p&gt;死锁解决办法：不要在同步中嵌套同步&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo6DeadLock {

    public static void main(String[] args) {
        //创建线程任务对象
        Ticket ticket = new Ticket();
        //创建三个窗口对象
        Thread t1 = new Thread(ticket, &amp;quot;窗口1&amp;quot;);
        Thread t2 = new Thread(ticket, &amp;quot;窗口2&amp;quot;);
        Thread t3 = new Thread(ticket, &amp;quot;窗口3&amp;quot;);

        //卖票
        t1.start();
        t2.start();
        t3.start();
    }

    static class Ticket implements Runnable {

        Object lock = new Object();
        private int ticket = 100;

        public void run() {
            String name = Thread.currentThread().getName();
            while (true) {
                if (&amp;quot;窗口1&amp;quot;.equals(name)) {
                    synchronized (lock) {
                        sell(name);
                    }
                } else {
                    sell(name);
                }
                if (ticket &amp;lt;= 0) {
                    break;
                }
            }
        }

        private synchronized void sell(String name) {
            synchronized (lock) {
                if (ticket &amp;gt; 0) {
                    System.out.println(name + &amp;quot;卖票：&amp;quot; + ticket);
                    ticket--;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;死锁案例二&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DeadLockDemo {
    static Object obj1 = new Object();
    static Object obj2 = new Object();

    public static void fun01(){
        System.out.println(Thread.currentThread().getId()+&amp;quot;尝试获取obj1的锁&amp;quot;);
        synchronized (obj1){
            System.out.println(Thread.currentThread().getId()+&amp;quot;获取到了ob1的锁&amp;quot;);
            try {
                Thread.sleep(30);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            fun02();
        }
    }

    public static void fun02(){
        System.out.println(Thread.currentThread().getId()+&amp;quot;尝试获取obj2的锁&amp;quot;);
        synchronized (obj2){
            System.out.println(Thread.currentThread().getId()+&amp;quot;获取到了ob2的锁&amp;quot;);
            try {
                Thread.sleep(30);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            fun01();
        }
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&amp;gt; fun01());
        Thread thread2 = new Thread(() -&amp;gt; fun02());
        thread1.start();
        thread2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-小结-1&#34;&gt;1.4 小结
&lt;/h3&gt;&lt;p&gt;线程安全：当多线程执行同一段程序的时候，如果发生了和预期结果不一致的情况，就是线程不安全的，如果和预期结果一致就是线程安全的，可以加锁解决(把并行运行的线程变成串行化执行)。&lt;/p&gt;
&lt;p&gt;同步锁的几种方式(锁对象):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步代码块加锁：sync&amp;hellip;.(obj)&lt;/li&gt;
&lt;li&gt;同步方法加锁：等价于sync&amp;hellip;.(this)&lt;/li&gt;
&lt;li&gt;静态同步方法加锁:等价于sync&amp;hellip;.(this.getClass())&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死锁：线程之间互相等待对方释放锁，就产生了死锁，尽量不要同步中嵌套同步。&lt;/p&gt;
&lt;h2 id=&#34;3-线程状态&#34;&gt;3 线程状态
&lt;/h2&gt;&lt;h3 id=&#34;11-目标-2&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;p&gt;​	掌握线程在运行期间状态的变化。&lt;/p&gt;
&lt;h3 id=&#34;12-路径-2&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程状态介绍&lt;/li&gt;
&lt;li&gt;wait()和notify()&lt;/li&gt;
&lt;li&gt;wait()和sleep的区别&lt;/li&gt;
&lt;li&gt;线程停止&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解-2&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;h4 id=&#34;131线程状态介绍&#34;&gt;1.3.1.线程状态介绍
&lt;/h4&gt;&lt;p&gt;查看Thread源码，能够看到java的线程有六种状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum State {
        NEW,
        RUNNABLE,
        BLOCKED,
        WAITING,
        TIMED_WAITING,
        TERMINATED;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**NEW(新建) **
&lt;code&gt;线程刚被创建，但是并未启动。&lt;/code&gt;
&lt;strong&gt;RUNNABLE(可运行)&lt;/strong&gt;
&lt;code&gt;线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。&lt;/code&gt;
&lt;strong&gt;BLOCKED(锁阻塞)&lt;/strong&gt;
&lt;code&gt;当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。&lt;/code&gt;
&lt;strong&gt;WAITING(无限等待)&lt;/strong&gt;
&lt;code&gt;一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。&lt;/code&gt;
&lt;strong&gt;TIMED_WAITING(计时等待)&lt;/strong&gt;
&lt;code&gt;同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。&lt;/code&gt;
&lt;strong&gt;TERMINATED(被终止)&lt;/strong&gt;
&lt;code&gt;因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;线程状态图&#34;&gt;线程状态图
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/1536601656694.png&#34;
	width=&#34;733&#34;
	height=&#34;507&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;346px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;132waitnotify&#34;&gt;1.3.2.wait()、notify()
&lt;/h4&gt;&lt;p&gt;wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。&lt;/p&gt;
&lt;p&gt;wait		方法会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
notify	方法会通知&lt;strong&gt;某个&lt;/strong&gt;正在等待这个对象的控制权的线程继续运行，能否继续运行取决于是否获取到锁。
notifyAll	方法会通知&lt;strong&gt;所有&lt;/strong&gt;正在等待这个对象的控制权的线程继续运行，能否继续运行取决于是否获取到锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：一定要在线程同步中使用,并且是同一个锁的资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wait和notify方法例子，打开关闭开关：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DemoSwitch {

    static class Switch{
        //开关状态
        Boolean state = false;

        public Boolean getState() {
            return state;
        }

        public void setState(Boolean state) throws Exception {
            String s = state?&amp;quot;打开&amp;quot;:&amp;quot;关闭&amp;quot;;
            System.out.println(s);
            if(this.state==state){
                throw new Exception(&amp;quot;开关不能连续&amp;quot;+s);
            }
            this.state = state;
        }
    }

    static abstract class ActionThread implements Runnable{
        //开关
        Switch aSwitch;

        public ActionThread(Switch aSwitch) {
            this.aSwitch = aSwitch;
        }

        @Override
        public void run() {
            //循环
            while (true){
                //同步
                synchronized (aSwitch){
                    try {
                        action();
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
                }
            }
        }

        protected abstract void action() throws Exception;
    }

    public static void main(String[] args) {
        //1.创建开关
        Switch aSwitch = new Switch();
        //2.关闭线程
        Thread thread1 = new Thread(new ActionThread(aSwitch){
            @Override
            protected void action() throws Exception {
                //RUNNABLE
                System.out.println(&amp;quot;thread1获取到aSwitch对象的锁后:&amp;quot;+Thread.currentThread().getState().name());
                //如果开关是关闭的
                if(!this.aSwitch.getState()){
                    try {
                        //让当前线程释放锁，进入等待
                        this.aSwitch.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //关闭开关
                this.aSwitch.setState(false);
                //唤醒等待中的一个线程
                this.aSwitch.notify();
            }
        });
        //new
        System.out.println(&amp;quot;创建thread1未运行时的状态是:&amp;quot;+thread1.getState().name());
        //2.打开线程
        Thread thread2 = new Thread(new ActionThread(aSwitch){
            @Override
            protected void action() throws Exception {
                //BLOCKED
                System.out.println(&amp;quot;thread2获取到aSwitch对象的锁后:&amp;quot;+thread1.getState().name());
                //如果开关是打开的
                if(this.aSwitch.getState()){
                    try {
                        //让当前线程释放锁，进入等待
                        this.aSwitch.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //打开开关
                this.aSwitch.setState(true);
                //wait
                System.out.println(&amp;quot;thread2线程在调用notify之前:&amp;quot;+thread1.getState().name());
                //唤醒等待中的一个线程
                this.aSwitch.notify();

            }
        });

        thread1.start();
        thread2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133wait与sleep区别&#34;&gt;1.3.3.wait与sleep区别
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于sleep()方法，首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sleep()方法导致了程序暂停执行指定的时间，让出cpu调度其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。&lt;/p&gt;
&lt;p&gt;wait()是把控制权交出去，然后进入等待此对象的等待锁定池处于等待状态，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;134线程停止&#34;&gt;1.3.4.线程停止
&lt;/h4&gt;&lt;p&gt;结束线程有以下三种方法：
（1）自定义退出标志，使线程正常退出。
（2）使用interrupt()方法中断线程，使用线程内部的退出标志。
（3）&lt;del&gt;使用stop方法强行终止线程&lt;/del&gt;（不推荐使用Thread.stop, 这种终止线程运行的方法已经被废弃，使用它们是极端不安全的！）&lt;/p&gt;
&lt;h5 id=&#34;151-自定义退出标志&#34;&gt;1.5.1 自定义退出标志 
&lt;/h5&gt;&lt;p&gt;       一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo8Exit {

    public static boolean exit = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new Runnable() {
            public void run() {
                while (exit) {
                    try {
                        System.out.println(&amp;quot;线程执行！&amp;quot;);
                        Thread.sleep(100l);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        t.start();

        Thread.sleep(1000l);
        exit = false;
        System.out.println(&amp;quot;退出标识位设置成功&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;152-使用interrupt方法&#34;&gt;1.5.2 使用interrupt()方法
&lt;/h5&gt;&lt;p&gt;使用interrupt()方法来中断线程有两种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)线程处于阻塞状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	如使用了sleep,同步锁的wait,socket中的receiver,accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)线程未处于阻塞状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo9Interrupt {

    public static boolean exit = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new Runnable() {
            public void run() {
                while (exit) {
                    try {
                        System.out.println(&amp;quot;线程执行！&amp;quot;);

                        //判断线程的中断标志来退出循环
                        if (Thread.currentThread().isInterrupted()) {
                            break;
                        }

                        Thread.sleep(100l);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        //线程处于阻塞状态,当调用线程的interrupt()方法时，
                        //会抛出InterruptException异常,跳出循环
                        break;
                    }
                }
            }
        });
        t.start();

        Thread.sleep(1000l);
        //中断线程
        t.interrupt();
        System.out.println(&amp;quot;线程中断了&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-小结-2&#34;&gt;1.4 小结
&lt;/h3&gt;&lt;p&gt;线程状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NEW：线程被创建但是没有start运行&lt;/li&gt;
&lt;li&gt;RUNABLE:线程可以运行，是否运行取决于cpu是否调度该线程，如果没有调度就是ready，如调度到就是running&lt;/li&gt;
&lt;li&gt;WAITING：当锁对象调用wait方法，会让持有该锁对象的线程进入无限等待状态，这个状态只有被同一个锁对象的notify才能解除，解除后进入RUNABLE状态。&lt;/li&gt;
&lt;li&gt;TIMED_WAITING：sleep(time),wait(time)的时候进入计时等待，当时间到了，继续运行&lt;/li&gt;
&lt;li&gt;BLOCKED：在线程获取不到锁对象的时候，就会进入阻塞状态，当其他线程释放锁，本线程获取到锁才能够继续运行。&lt;/li&gt;
&lt;li&gt;TERMINATED：run方法执行完毕之后，进入终止状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;wait和sleep的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wait是属于object对象的方法，sleep是属于Thread类的方法&lt;/li&gt;
&lt;li&gt;wait会让当前持有该对象锁的线程停止运行，进入waiting状态，并且会释放锁，只有同一个对象的notify/notifyAll方法才能够唤醒,sleep不会释放锁，让线程等待一段时间继续运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程终止：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自定义退出标识：缺点是线程在sleep的时候是无法立刻退出，必须等线程执行到了判断标识的地方才能够停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用线程自己的退出标识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果线程正常运行，可以通过Thread.currentThread().isInterrupted()判断退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前线程正在sleep，通过‘t.interrupt();’会抛出异常，可以通过捕获异常立刻线程的运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-线程优先级&#34;&gt;4 线程优先级
&lt;/h2&gt;&lt;h3 id=&#34;11-目标-3&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;p&gt;​	理解多线程技术的一些基本概念。&lt;/p&gt;
&lt;h3 id=&#34;12-路径-3&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置并理解线程的优先级priority&lt;/li&gt;
&lt;li&gt;理解并掌握join()方法的使用&lt;/li&gt;
&lt;li&gt;理解yield()方法的概念&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解-3&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;h5 id=&#34;1优先级priority&#34;&gt;1.优先级priority
&lt;/h5&gt;&lt;p&gt;​	现今操作系统基本采用分时的形式调度运行的线程，线程分配得到时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。&lt;/p&gt;
&lt;p&gt;​	在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo10Priorityt {

    public static void main(String[] args) {
        PrioritytThread prioritytThread = new PrioritytThread();

        // 如果8核CPU处理3线程，无论优先级高低，每个线程都是单独一个CPU执行，就无法体现优先级
        // 开启10个线程，让8个CPU处理，这里线程就需要竞争CPU资源，优先级高的能分配更多的CPU资源
        for (int i = 0; i &amp;lt; 10; i++) {
            Thread t = new Thread(prioritytThread, &amp;quot;线程&amp;quot; + i);
            if (i == 1) {
                t.setPriority(10);
            }
            if (i == 2) {
                t.setPriority(1);
            }
            t.setDaemon(true);
            t.start();
        }

        try {
            Thread.sleep(1000l);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(&amp;quot;线程1总计：&amp;quot; + PrioritytThread.count1);
        System.out.println(&amp;quot;线程2总计：&amp;quot; + PrioritytThread.count2);
    }

    static class PrioritytThread implements Runnable {
        public static Integer count1 = 0;
        public static Integer count2 = 0;

        public void run() {
            while (true) {
                if (&amp;quot;线程1&amp;quot;.equals(Thread.currentThread().getName())) {
                    count1++;
                }
                if (&amp;quot;线程2&amp;quot;.equals(Thread.currentThread().getName())) {
                    count2++;
                }

                if (Thread.currentThread().isInterrupted()) {
                    break;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2join方法&#34;&gt;2.join()方法
&lt;/h5&gt;&lt;p&gt;join作用是让其他线程变为等待。thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo11Join {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 10; i++) {
                    String name = Thread.currentThread().getName();
                    System.out.println(name+&amp;quot;执行&amp;quot;+i);
                }
            }
        }, &amp;quot;线程1&amp;quot;);
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    thread1.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                for (int i = 0; i &amp;lt; 10; i++) {
                    String name = Thread.currentThread().getName();
                    System.out.println(name+&amp;quot;执行&amp;quot;+i);
                }
            }
        }, &amp;quot;线程2&amp;quot;);
        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    thread2.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                for (int i = 0; i &amp;lt; 10; i++) {
                    String name = Thread.currentThread().getName();
                    System.out.println(name+&amp;quot;执行&amp;quot;+i);
                }
            }
        }, &amp;quot;线程3&amp;quot;);
        thread1.start();
        thread2.start();
        thread3.start();

       /* try {
            thread3.join();
        } catch (Exception e) {

        }*/
        for (int i = 0; i &amp;lt; 5; i++) {
            System.out.println(&amp;quot;main ---i:&amp;quot; + i);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3yield方法running-ready&#34;&gt;3.yield方法（running-&amp;gt;ready）
&lt;/h5&gt;&lt;p&gt;Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）
yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。&lt;/p&gt;
&lt;p&gt;查看源码介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/1558669569583.png&#34;
	width=&#34;760&#34;
	height=&#34;413&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1558669569583&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。&lt;/p&gt;
&lt;h3 id=&#34;14-小结-3&#34;&gt;1.4 小结
&lt;/h3&gt;&lt;p&gt;优先级：从1-10，默认值是5，表示线程被cpu调度的概率，值越大优先级越高就越有可能被cpu调度到去执行，从宏观角度来说，不同优先级的线程在运行一段时间后，它们的优先级表示的就是线程占用cpu时间片的多少。&lt;/p&gt;
&lt;p&gt;join方法：线程a里面调用线程b.join方法，就是让线程b先执行，b执行完了在执行线程a&lt;/p&gt;
&lt;p&gt;yield方法：就是让当前线程让出cpu资源（running-&amp;gt;ready切换）,可能没有效果，因为cpu有可能再度调度到该线程执行&lt;/p&gt;
&lt;h2 id=&#34;5-多线程并发的3个特性&#34;&gt;5. 多线程并发的3个特性
&lt;/h2&gt;&lt;h3 id=&#34;11-目标-4&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;p&gt;​	理解多线程并发的3个特性。&lt;/p&gt;
&lt;h3 id=&#34;12-路径-4&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;原子性&lt;/li&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;li&gt;有序性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解-4&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;p&gt;​	多线程并发开发中，要知道什么是多线程的原子性，可见性和有序性，以避免相关的问题产生。&lt;/p&gt;
&lt;h4 id=&#34;131-原子性不可分割的最小单位&#34;&gt;1.3.1 原子性（不可分割的最小单位）
&lt;/h4&gt;&lt;p&gt;原子性：&lt;code&gt;即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个很经典的例子就是银行账户转账问题：&lt;/p&gt;
&lt;p&gt;比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。&lt;/p&gt;
&lt;p&gt;试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。&lt;/p&gt;
&lt;p&gt;所以这2个操作&lt;strong&gt;必须要具备原子性&lt;/strong&gt;才能保证不出现一些意外的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回顾之前的买票案例&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;132-可见性&#34;&gt;1.3.2 可见性
&lt;/h4&gt;&lt;p&gt;可见性：&lt;code&gt;当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前面讲过多线程的内存可见性，现在我们写一个内存不可见的问题。&lt;/p&gt;
&lt;p&gt;案例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DemoVisible {

    public static void main(String[] args) throws InterruptedException {

        JmmDemo demo = new JmmDemo();
        Thread t = new Thread(demo);
        t.start();
        Thread.sleep(100);
        demo.flag = false;
        System.out.println(&amp;quot;已经修改为false&amp;quot;);
        System.out.println(demo.flag);
    }

    static class JmmDemo implements Runnable {
        public boolean flag = true;

        public void run() {
            System.out.println(&amp;quot;子线程执行。。。&amp;quot;);
            while (flag) {
            }
            System.out.println(&amp;quot;子线程结束。。。&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/1558602652109.png&#34;
	width=&#34;240&#34;
	height=&#34;140&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1558602652109&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;411px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	按照main方法的逻辑，我们已经把flag设置为false，那么从逻辑上讲，子线程就应该跳出while死循环，因为这个时候条件不成立，但是我们可以看到，程序仍旧执行中，并没有停止。&lt;/p&gt;
&lt;p&gt;​	原因:&lt;/p&gt;
&lt;p&gt;​		1.和&lt;strong&gt;java内存模型&lt;/strong&gt;有关，多线程访问共享变量时会创建副本变量，修改后再写回主变量，其他线程副本变量的值没有及时更新，导致可见性的问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//线程1执行的代码
int i = 0;
i = 10;

//线程2执行的代码
j = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当线程1执行&lt;code&gt;int i = 0&lt;/code&gt;这句时，&lt;code&gt;i&lt;/code&gt;的初始值0加载到内存中，然后再执行&lt;code&gt;i = 10&lt;/code&gt;，那么在内存中&lt;code&gt;i&lt;/code&gt;的值变为10了。&lt;/p&gt;
&lt;p&gt;如果当线程1执行到&lt;code&gt;int i = 0&lt;/code&gt;这句时，此时线程2执行 j = i，它读取&lt;code&gt;i&lt;/code&gt;的值并加载到内存中，注意此时内存当中i的值是0，那么就会使得&lt;code&gt;j&lt;/code&gt;的值也为0，而不是10。&lt;/p&gt;
&lt;p&gt;这就是可见性问题，线程1对变量&lt;code&gt;i&lt;/code&gt;修改了之后，线程2没有立即看到线程1修改的值。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;解决方案：一般使用volatile或同步锁保证其内存的可见性&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;133-有序性&#34;&gt;1.3.3 有序性
&lt;/h4&gt;&lt;p&gt;有序性：&lt;code&gt;程序执行的顺序按照代码的先后顺序执行&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean flag = false;
int count = 0;
count = 1; //语句1
flag = true; //语句2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	以上代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生&lt;strong&gt;指令重排序&lt;/strong&gt;（Instruction Reorder）。&lt;/p&gt;
&lt;p&gt;​	什么是重排序？一般来说，处理器为了&lt;strong&gt;提高程序运行效率&lt;/strong&gt;，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致。&lt;/p&gt;
&lt;p&gt;​	as-if-serial:无论如何重排序，程序最终执行结果和代码顺序执行的结果是一致的。Java编译器、运行时和处理器都会保证Java在&lt;strong&gt;单线程&lt;/strong&gt;下遵循as-if-serial语意）&lt;/p&gt;
&lt;p&gt;​	 上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？&lt;/p&gt;
&lt;p&gt;再看下面一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a = 10; //语句1
int b = 2; //语句2
a = a + 3; //语句3
b = a*a; //语句4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码有4个语句，那么可能的一个执行顺序是：  语句2   语句1    语句3   语句4&lt;/p&gt;
&lt;p&gt;不可能是这个执行顺序： 语句2   语句1    语句4   语句3&lt;/p&gt;
&lt;p&gt;因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。==虽然重排序不会影响单个线程内程序执行的结果，但是多线程会有影响==&lt;/p&gt;
&lt;p&gt;下面看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//线程1:
init = false
context = loadContext(); //语句1
init = true; //语句2

//线程2:
while(!init){//如果初始化未完成，等待
  sleep();
}
execute(context);//初始化完成，执行逻辑
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，==由于语句1和语句2没有数据依赖性，因此可能会被重排序==。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行execute(context)方法，而此时context并没有被初始化，就会导致程序出错。&lt;/p&gt;
&lt;p&gt;从上面可以看出，&lt;strong&gt;重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;14-小结-4&#34;&gt;1.4 小结
&lt;/h3&gt;&lt;p&gt;​		要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。&lt;/p&gt;
&lt;p&gt;​		原子性：不可分割，说明这一段程序要么都执行，要么不执行，并且不能被其他线程影响，可以使用同步方法,同步块，锁解决。&lt;/p&gt;
&lt;p&gt;​		可见性：多线程对于共享变量的访问，必须每次都获取到主变量的值。可以使用volatile或者同步方法，同步块，锁解决。&lt;/p&gt;
&lt;p&gt;​		原因1：和内存模型有关，每次去读取内存中的值会加载到cpu缓存。&lt;/p&gt;
&lt;p&gt;​		原因2：jvm有时候会认为程序是单线程执行，或者执行的逻辑对变量没有影响，就会重复读取cpu缓存的变量，导致可见性的问题。&lt;/p&gt;
&lt;p&gt;​		有序性:由jvm指令重排导致的，指令重排的结果对于单线程来说是一致性，没有什么影响（在指令重排的过程中会考虑数据依赖的问题），多线程情况下避免指令重排带来程序执行错误的危害。有些情况可以使用volatile，或者使用synchronized同步块或者同步方法或者同步锁。&lt;/p&gt;
&lt;h2 id=&#34;6-java内存可见性&#34;&gt;6. Java内存可见性
&lt;/h2&gt;&lt;h3 id=&#34;11-目标-5&#34;&gt;1.1 目标
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;了解java内存模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解java内存可见性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-路径-5&#34;&gt;1.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;java内存模型介绍&lt;/li&gt;
&lt;li&gt;java内存可见性的介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-讲解-5&#34;&gt;1.3 讲解
&lt;/h3&gt;&lt;h3 id=&#34;31-了解java内存模型&#34;&gt;3.1 了解Java内存模型
&lt;/h3&gt;&lt;p&gt;​	JVM内存结构、Java对象模型和Java内存模型，这就是三个截然不同的概念，而这三个概念很容易混淆。这里详细区别一下&lt;/p&gt;
&lt;h4 id=&#34;311-jvm内存结构-运行时数据区&#34;&gt;3.1.1 JVM内存结构; 运行时数据区
&lt;/h4&gt;&lt;p&gt;​	我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。&lt;/p&gt;
&lt;p&gt;在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/QQ20180624-150918.png&#34;
	width=&#34;675&#34;
	height=&#34;350&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;QQ20180624-150918&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;462px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;312-java对象模型&#34;&gt;3.1.2 Java对象模型
&lt;/h4&gt;&lt;p&gt;​	Java是一种面向对象的语言，而&lt;strong&gt;Java对象&lt;/strong&gt;在JVM中的&lt;strong&gt;存储&lt;/strong&gt;也是有一定的&lt;strong&gt;结构&lt;/strong&gt;的。而这个关于Java对象自身的存储模型称之为Java对象模型。&lt;/p&gt;
&lt;p&gt;​	HotSpot虚拟机中（Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机），设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。&lt;/p&gt;
&lt;p&gt;​	每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个&lt;code&gt;instanceKlass&lt;/code&gt;对象，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个&lt;code&gt;instanceOopDesc&lt;/code&gt;对象，这个对象中包含了对象头以及实例数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/20170615230126453.jpeg&#34;
	width=&#34;1588&#34;
	height=&#34;712&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20170615230126453&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;535px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。&lt;/p&gt;
&lt;h4 id=&#34;313-内存模型&#34;&gt;3.1.3 内存模型
&lt;/h4&gt;&lt;p&gt;​	&lt;strong&gt;Java内存模型就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有兴趣详细了解Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题的学员，参考：&lt;a class=&#34;link&#34; href=&#34;https://www.hollischuang.com/archives/2550&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.hollischuang.com/archives/2550&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​	Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实&lt;strong&gt;JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念&lt;/strong&gt;。&lt;a class=&#34;link&#34; href=&#34;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JSR-133: Java Memory Model and Thread Specification&lt;/a&gt;中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。&lt;/p&gt;
&lt;p&gt;​	简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/11.png&#34;
	width=&#34;423&#34;
	height=&#34;377&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;11&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;269px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;JMM线程操作内存的基本的规则：&lt;/p&gt;
&lt;p&gt;==第一条关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存（本地内存）中进行，不能直接从主内存中读写==&lt;/p&gt;
&lt;p&gt;==第二条关于线程间本地内存：不同线程之间无法直接访问其他线程本地内存中的变量，线程间变量值的传递需要经过主内存来完成。==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;本地内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要存储当前方法的所有本地变量信息(本地内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的本地内存，即&lt;strong&gt;线程中的本地变量对其它线程是不可见的&lt;/strong&gt;，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;314-小结&#34;&gt;3.1.4 小结
&lt;/h4&gt;&lt;p&gt;​	JVM内存结构，和Java虚拟机的运行时区域有关。&lt;/p&gt;
&lt;p&gt;​	Java对象模型，和Java对象如何在jvm中存储的描述。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Java内存模型，和Java的并发编程有关&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;32-内存可见性&#34;&gt;3.2 内存可见性
&lt;/h3&gt;&lt;h4 id=&#34;321-内存可见性介绍&#34;&gt;3.2.1 内存可见性介绍
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;可见性：&lt;/code&gt;一个线程对共享变量值的修改，能够及时的被其他线程看到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;共享变量：&lt;/code&gt;如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量&lt;/p&gt;
&lt;p&gt;线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。&lt;/li&gt;
&lt;li&gt;然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/2c452d147bf0d09b14b770d3990740cb.png&#34;
	width=&#34;440&#34;
	height=&#34;334&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;131&#34;
		data-flex-basis=&#34;316px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。&lt;/p&gt;
&lt;p&gt;​	从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;回顾上面多线程并发的可见性问题的案例&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-volatile&#34;&gt;7 Volatile
&lt;/h2&gt;&lt;h3 id=&#34;71-目标&#34;&gt;7.1 目标
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;掌握volatile的使用方法和场景&lt;/li&gt;
&lt;li&gt;理解volatile的作用原理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;72-路径&#34;&gt;7.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解决内存可见性的问题&lt;/li&gt;
&lt;li&gt;原子性的问题&lt;/li&gt;
&lt;li&gt;volatile的适用场景&lt;/li&gt;
&lt;li&gt;synchronized和volatile的对比&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;73-讲解&#34;&gt;7.3 讲解
&lt;/h3&gt;&lt;p&gt;如果一个变量使用volatile，则它比使用synchronized的成本更加低，因为它不会引起线程上下文的切换和调度。&lt;/p&gt;
&lt;p&gt;Java语言规范对volatile的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	通俗点讲就是说一个变量如果用volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是内存可见性。&lt;/p&gt;
&lt;p&gt;volatile虽然看起来比较简单，使用起来无非就是在一个变量前面加上volatile即可，但是要用好并不容易。&lt;/p&gt;
&lt;h4 id=&#34;1-解决内存可见性问题&#34;&gt;1 解决内存可见性问题
&lt;/h4&gt;&lt;h5 id=&#34;11-缓存一致协议保证读到最新值&#34;&gt;1.1 缓存一致协议保证读到最新值
&lt;/h5&gt;&lt;p&gt;设置-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly 可以查看执行过程中的汇编码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;汇编代码：

0x01a3de1d: movb $0x0,0x1104800(%esi);

0x01a3de24: lock  addl $0x0,(%esp);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有volatile变量修饰的共享变量进行&lt;strong&gt;写操作&lt;/strong&gt;的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将当前处理器缓存行的数据会写回到系统内存。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现&lt;strong&gt;缓存一致性协议&lt;/strong&gt;，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是&lt;strong&gt;过期&lt;/strong&gt;了，当处理器发现自己缓存行对应的&lt;strong&gt;内存地址&lt;/strong&gt;被修改，就会将当前处理器的&lt;strong&gt;缓存行设置&lt;/strong&gt;成&lt;strong&gt;无效状态&lt;/strong&gt;，当处理器要对这个数据进行修改操作的时候，会&lt;strong&gt;强制&lt;/strong&gt;重新从&lt;strong&gt;系统内存&lt;/strong&gt;里把数据读到&lt;strong&gt;处理器缓存&lt;/strong&gt;里。&lt;/p&gt;
&lt;p&gt;这两件事情在IA-32软件开发者架构手册的第三册的多处理器管理章节（第八章）中有详细阐述。&lt;/p&gt;
&lt;p&gt;Lock前缀指令会引起处理器缓存回写到内存 。Lock前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在8.1.4章节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据 。&lt;/p&gt;
&lt;p&gt;一个处理器的缓存回写到内存会导致其他处理器的缓存无效 。IA-32处理器和Intel 64处理器使用MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。例如在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处理共享状态，那么正在嗅探的处理器将无效它的缓存行，在下次访问相同内存地址时，强制执行缓存行填充。&lt;/p&gt;
&lt;h5 id=&#34;12-内存屏障防止指令重排解决指令重排对volatile修饰的变量不会产生影响&#34;&gt;1.2 内存屏障防止指令重排（解决指令重排对volatile修饰的变量不会产生影响）
&lt;/h5&gt;&lt;p&gt;写操作时，通过在写操作指令后加入一条store屏障指令，让本地内存中变量的值能够刷新到主内存中&lt;/p&gt;
&lt;p&gt;读操作时，通过在读操作前加入一条load屏障指令，及时读取到变量在主内存的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PS: 内存屏障（Memory Barrier）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;==volatile的底层实现是通过插入内存屏障==，但是对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎是不可能的，所以，JMM采用了保守策略。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-原子性的问题&#34;&gt;2 原子性的问题
&lt;/h4&gt;&lt;p&gt;虽然Volatile 关键字可以让变量在多个线程之间可见，但是Volatile不能保证对修饰变量的操作是原子性的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo3Volatile {

    public static void main(String[] args) throws InterruptedException {
        VolatileDemo demo = new VolatileDemo();

        for (int i = 0; i &amp;lt; 5; i++) {
            Thread t = new Thread(demo);
            t.start();
        }

        Thread.sleep(1000);
        System.out.println(demo.count);
    }

    static class VolatileDemo implements Runnable {
        public volatile int count;
        //public volatile AtomicInteger count = new AtomicInteger(0);

        public void run() {
            addCount();
        }

        public void addCount() {
            for (int i = 0; i &amp;lt; 10000; i++) {
                count++;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上出现原子性问题的原因是count++并不是原子性操作。&lt;/p&gt;
&lt;p&gt;count = 5 开始，流程分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程1读取count的值为5&lt;/li&gt;
&lt;li&gt;线程2读取count的值为5&lt;/li&gt;
&lt;li&gt;线程2加1操作&lt;/li&gt;
&lt;li&gt;线程2最新count的值为6&lt;/li&gt;
&lt;li&gt;线程2写入值到主内存的最新值为6&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候，线程1的count为5，线程2的count为6&lt;/p&gt;
&lt;p&gt;如果切换到线程1执行，那么线程1得到的结果是6，写入到主内存的值还是6&lt;/p&gt;
&lt;p&gt;现在的情况是对count进行了两次加1操作，但是主内存实际上只是加1一次&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用synchronized&lt;/li&gt;
&lt;li&gt;使用ReentrantLock（可重入锁）&lt;/li&gt;
&lt;li&gt;使用AtomicInteger（原子操作）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用synchronized&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized void addCount() {
    for (int i = 0; i &amp;lt; 10000; i++) {
        count++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用ReentrantLock（可重入锁）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//可重入锁
private Lock lock = new ReentrantLock();

public void addCount() {
    for (int i = 0; i &amp;lt; 10000; i++) {
        lock.lock();
        count++;
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用AtomicInteger（原子操作）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static AtomicInteger count = new AtomicInteger(0);
public void addCount() {
    for (int i = 0; i &amp;lt; 10000; i++) {
        //count++;
        count.incrementAndGet();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-volatile-适合使用场景能够解决可见性和一定程度的有序性但是不能保证原子性&#34;&gt;3 Volatile 适合使用场景（能够解决可见性，和一定程度的有序性，但是不能保证原子性）
&lt;/h4&gt;&lt;p&gt;a）对变量的写入操作不依赖其当前值&lt;/p&gt;
&lt;p&gt;​    	不满足：number++、count=count*5等&lt;/p&gt;
&lt;p&gt;​    	满足：boolean变量、直接赋值的变量等&lt;/p&gt;
&lt;p&gt;b）该变量没有包含在具有其他变量的不变式中&lt;/p&gt;
&lt;p&gt;​	不满足：不变式 low&amp;lt;up&lt;/p&gt;
&lt;p&gt;总结：对变量的操作本身是原子性的操作，就可以使用volatile,如果不是原子操作使用了volitale也不能保证线程安全&lt;/p&gt;
&lt;p&gt;扩展：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Java中的原子操作包括：
1）除long和double之外的基本类型的赋值操作
2）所有引用reference的赋值操作
3）java.util.concurrent.Atomic.* 包中所有类的一切操作。
4）cas操作是原子操作。

但是java对long和double的赋值操作是非原子操作！！long和double占用的字节数都是8，也就是64bits。在32位操作系统上对64位的数据的读写要分两步完成，每一步取32位数据。这样对double和long的赋值操作就会有问题：如果有两个线程同时写一个变量内存，一个进程写低32位，而另一个写高32位，这样将导致获取的64位数据是失效的数据。因此需要使用volatile关键字来防止此类现象。volatile本身不保证获取和设置操作的原子性，仅仅保持修改的可见性。但是java的内存模型保证声明为volatile的long和double变量的get和set操作是原子的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-小结&#34;&gt;7.4 小结
&lt;/h3&gt;&lt;h2 id=&#34;8-synchronized&#34;&gt;8. synchronized
&lt;/h2&gt;&lt;h3 id=&#34;81-目标&#34;&gt;8.1 目标
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;理解synchronized实现可见性的过程&lt;/li&gt;
&lt;li&gt;理解同步原理&lt;/li&gt;
&lt;li&gt;理解jvm是如何进行锁优化的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;82-路径&#34;&gt;8.2 路径
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解决可见性问题&lt;/li&gt;
&lt;li&gt;同步原理&lt;/li&gt;
&lt;li&gt;锁优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;83-讲解&#34;&gt;8.3 讲解
&lt;/h3&gt;&lt;p&gt;​	synchronized可以保证方法或者代码块在运行时，同一时刻只有一个线程执行synchronized声明的代码块。还可以保证共享变量的内存可见性。同一时刻只有一个线程执行，这部分代码块的重排序也不会影响其执行结果。也就是说使用了synchronized可以保证并发的原子性，可见性，有序性。&lt;/p&gt;
&lt;h4 id=&#34;831-解决可见性问题&#34;&gt;8.3.1 解决可见性问题
&lt;/h4&gt;&lt;p&gt;JMM关于synchronized的两条规定：&lt;/p&gt;
&lt;p&gt;==线程加锁时（进入同步代码块时）：将清空本地内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁与解锁是同一把锁==）&lt;/p&gt;
&lt;p&gt;线程解锁前（退出同步代码块时）：必须把自己工作内存中共享变量的最新值刷新到主内存中&lt;/p&gt;
&lt;p&gt;做如下修改，在死循环中添加同步代码块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        while (flag) {
            synchronized (this) {
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;synchronized实现可见性的过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获得互斥锁（同步获取锁）&lt;/li&gt;
&lt;li&gt;清空本地内存&lt;/li&gt;
&lt;li&gt;执行代码&lt;/li&gt;
&lt;li&gt;将更改后的共享变量的值刷新到主内存&lt;/li&gt;
&lt;li&gt;释放互斥锁&lt;/li&gt;
&lt;li&gt;重新循环，从主内存拷贝变量的最新副本到本地内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;832-同步原理&#34;&gt;8.3.2 同步原理
&lt;/h4&gt;&lt;p&gt;synchronized的同步可以解决原子性、可见性和有序性的问题，那是如何实现同步的呢？&lt;/p&gt;
&lt;p&gt;Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通同步方法，锁是当前实例对象this&lt;/li&gt;
&lt;li&gt;静态同步方法，锁是当前类的class对象&lt;/li&gt;
&lt;li&gt;同步方法块，锁是括号里面的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁。&lt;/p&gt;
&lt;p&gt;synchronized的同步操作主要是monitorenter和monitorexit这两个jvm指令实现的，先写一段简单的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo2Synchronized {
    public void test2() {
        synchronized (this) {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在cmd命令行执行javac编译和javap -c Java 字节码的指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac Demo2Synchronized.java
javap -c Demo2Synchronized.class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果可以看出，同步代码块是使用monitorenter和monitorexit这两个jvm指令实现的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/1558750061740.png&#34;
	width=&#34;819&#34;
	height=&#34;625&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;50061740&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;131&#34;
		data-flex-basis=&#34;314px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	注意，本小节是解释synchronized性能低效的原因，只要能理解synchronized同步过程其实还需要做很多事，这些逻辑的执行都需要占用资源，从而导致性能较低。这部分分析过于深入JMM底层原理，不适合初级甚至中级程序员学习。synchronized是通过访问锁对象的monitor和mark word实现同步的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mark Word&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是synchronized实现轻量级锁和偏向锁的关键。
  
Mark Word用于存储对象自身的运行时数据，如**哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳**等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/201812081002.png&#34;
	width=&#34;560&#34;
	height=&#34;73&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;767&#34;
		data-flex-basis=&#34;1841px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/201812081003.png&#34;
	width=&#34;812&#34;
	height=&#34;204&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;398&#34;
		data-flex-basis=&#34;955px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;monitor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象都带了一把看不见的锁，它叫做内部锁或者Monitor锁。&lt;/p&gt;
&lt;p&gt;Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/juc_01/assets/201812081004.png&#34;
	width=&#34;347&#34;
	height=&#34;479&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;72&#34;
		data-flex-basis=&#34;173px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Owner&lt;/strong&gt;：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EntryQ&lt;/strong&gt;:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RcThis&lt;/strong&gt;:表示blocked或waiting在该monitor record上的所有线程的个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nest&lt;/strong&gt;:用来实现重入锁的计数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashCode&lt;/strong&gt;:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Candidate&lt;/strong&gt;:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;833-synchronized和volatile比较&#34;&gt;8.3.3 synchronized和volatile比较
&lt;/h4&gt;&lt;p&gt;a）volatile不需要加锁，比synchronized更轻便，不会阻塞线程&lt;/p&gt;
&lt;p&gt;b）synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性&lt;/p&gt;
&lt;p&gt;​	与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件（&lt;strong&gt;对变量的操作是原子性的&lt;/strong&gt; ） 在某些情况下可以使用 volatile 代替 synchronized 来优化代码提升效率。&lt;/p&gt;
&lt;h4 id=&#34;834-锁优化&#34;&gt;8.3.4 锁优化
&lt;/h4&gt;&lt;p&gt;​	synchronized是重量级锁，效率不高。但在jdk 1.6中对synchronize的实现进行了各种优化，使得它显得不是那么重了。jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。&lt;/p&gt;
&lt;p&gt;​	锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。&lt;/p&gt;
&lt;p&gt;==&lt;strong&gt;注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。&lt;/strong&gt;==&lt;/p&gt;
&lt;h5 id=&#34;1-偏向锁&#34;&gt;1 偏向锁
&lt;/h5&gt;&lt;p&gt;​	步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个线程去争用时，如果没有其他线程争用，则会尝试CAS去修改mark word中一个标记为偏向(mark word单独有一个bit表示是否可偏向，记录锁的位置依然为01)，这个CAS动作同时会修改mark word部分bit以保留线程的ID值。&lt;/li&gt;
&lt;li&gt;当线程不断发生重入时，只需要判定头部的线程ID是否是当前线程，若是，则无需任何操作。&lt;/li&gt;
&lt;li&gt;==如果同一个对象存在另一个线程发起了访问请求==，则首先会判定该对象是否已经被锁定了。如果已经被锁定，则会将锁修改为轻量级锁(00),也就是锁粒度上升了；而如果没有锁定，则会将对象的==是否可偏向的位置设置为不可偏向==。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，&lt;strong&gt;如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构&lt;/strong&gt;，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。&lt;/p&gt;
&lt;h5 id=&#34;2-轻量级锁&#34;&gt;2 轻量级锁
&lt;/h5&gt;&lt;p&gt;​	synchronized会在对象的头部打标记，这个加锁的动作是必须要做的，悲观锁通常还会做许多其他的指令动作，轻量级锁希望通过CAS实现，它认为通过CAS尝试修改对象头部的mark区域的内容就可以达到目的，由于mark区域的宽度通常是4~8字节，也就是相当于一个int或者long的宽度，适合于CAS操作。&lt;/p&gt;
&lt;p&gt;轻量级锁通常会做一下4个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;==在栈中分配一块空间用来做一份对象头部mark word的拷贝==，在mark word中将对象锁的二进制位设置为“未锁定”(在32位的JVM中通常有2位用于存储锁标记，未锁定的标记为01)，这个动作是==方便等到释放锁的时候将这份数据拷贝到对象头部。==&lt;/li&gt;
&lt;li&gt;通过CAS尝试将头部的二进制位修改为“线程私有栈中对mark区域拷贝存放的地址”，如果成功，则会将最后2位设置为00，代表已经被轻量级锁锁住了。&lt;/li&gt;
&lt;li&gt;如果没有成功，则判定对象头部是否已经指向了当前线程所在的栈当中，如果成立则代表当前线程已经是拥有着，可以继续执行。&lt;/li&gt;
&lt;li&gt;如果不是拥有着，则说明有多个线程在争用，那么此时会将==锁升级为悲观锁，线程进入BLOCKED状态。==&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    JVM发现在轻量级锁里面多次“重入”和“释放”时，需要做的判断和拷贝动作还是很多，而在某些应用程序中，锁就是被某一个线程一直使用，为了进一步减小锁的开销，JVM中出现了偏向锁，偏向锁希望记录的是一个线程ID，它比轻量级锁更加轻量，当再次重入判定时，首先判定对象头部的线程ID是不是当前线程，若是则表示当前线程已经是对象锁的OWNER，无须做其他任何动作。&lt;/p&gt;
&lt;h5 id=&#34;3-自旋锁&#34;&gt;3 自旋锁
&lt;/h5&gt;&lt;p&gt;​	 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于 在大多数情况下 对象锁的锁状态只会&lt;strong&gt;持续很短一段时间&lt;/strong&gt;，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。&lt;/p&gt;
&lt;p&gt;​	所谓==自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。==&lt;/p&gt;
&lt;p&gt;​	==自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销==，但是它占用了处理器的时间。==如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费==。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。&lt;/p&gt;
&lt;p&gt;​	自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；&lt;/p&gt;
&lt;p&gt;​	如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。&lt;/p&gt;
&lt;h5 id=&#34;4-适应自旋锁&#34;&gt;4 适应自旋锁
&lt;/h5&gt;&lt;p&gt;​	JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，==它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多==。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。&lt;/p&gt;
&lt;p&gt;有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。&lt;/p&gt;
&lt;h5 id=&#34;5-锁消除&#34;&gt;5 锁消除
&lt;/h5&gt;&lt;p&gt;​	为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，==JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。==&lt;/p&gt;
&lt;p&gt;​	如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。==变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定==，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test(){
    Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;Integer&amp;gt;();
    for(int i = 0 ; i &amp;lt; 10 ; i++){
        vector.add(i);
    }
    System.out.println(vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。&lt;/p&gt;
&lt;h5 id=&#34;6-锁粗化&#34;&gt;6 锁粗化
&lt;/h5&gt;&lt;p&gt;​	在使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。&lt;/p&gt;
&lt;p&gt;​	在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。&lt;/p&gt;
&lt;p&gt;​	锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;Integer&amp;gt;();
public void test(){
    //加锁
    for(int i = 0 ; i &amp;lt; 10 ; i++){
        vector.add(i);//1.加锁 2.解锁
    }
    //解锁
    System.out.println(vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;7-重量锁&#34;&gt;7 重量锁
&lt;/h5&gt;&lt;p&gt;​	  java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源，因为&lt;strong&gt;用户态与内核态&lt;/strong&gt;都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要&lt;strong&gt;传递给许多变量、参数给内核&lt;/strong&gt;，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。&lt;/p&gt;
&lt;p&gt;​    因为需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 :用户态 和 内核态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核态：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序&lt;/li&gt;
&lt;li&gt;用户态：只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等.，而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作（比如java的I/O操作底层都是通过native方法来调用操作系统）。这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令。这种机制叫系统调用, 在CPU中的实现称之为陷阱指令(Trap Instruction)。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程和进程区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程独享内存空间，线程之间是共享堆内存空间，独享栈内存空间&lt;/li&gt;
&lt;li&gt;进程是程序的一次运行，一个进程可能包含很多线程，线程是一次任务执行的最小单元。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多线程创建&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Thread类，重写run方法&lt;/li&gt;
&lt;li&gt;实现runable接口，实现run方法&lt;/li&gt;
&lt;li&gt;匿名内部类实现runable接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多线程创建方式注意的点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现runable接口可以让多个线程同时执行一个任务，继承Thread类方式不行&lt;/li&gt;
&lt;li&gt;线程创建后要通过start方法运行，通过本地native方法调用底层c同名方法创建线程执行，不要通过run方法，因为run方法相当于在主线程运行类的run方法而已，不会创建线程执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程安全（多线程执行同一段代码，如果发生和预期结果不一致的情况就是线程不安全的）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于不满足原子性，有序性，可见性导致线程安全问题&lt;/li&gt;
&lt;li&gt;解决方案：加锁解决&lt;/li&gt;
&lt;li&gt;死锁：线程之间互相等待对方释放锁产生死锁。解决方案：不要在同步中嵌套同步&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程同步方式Synchorized（Synchorized都是对对象加锁）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步代码块加锁 sync&amp;hellip;(obj)-&amp;gt;对obj对象加锁&lt;/li&gt;
&lt;li&gt;同步方法 sync fun01-&amp;gt;对this对象加锁&lt;/li&gt;
&lt;li&gt;静态同步方法 static sync fun02-&amp;gt;对当前类的class加锁&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程状态&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;new（新建线程未执行）&lt;/li&gt;
&lt;li&gt;runable（可运行）：由ready（就绪）和running（运行中）两个状态组成,状态的切换是由cpu调度切换的，cpu调度到该线程，就是running，没调度到就是ready&lt;/li&gt;
&lt;li&gt;waiting：由当前获取到锁的线程，锁对象.wait()方法引起的，只能由同一个对象的notify（）/nodifyAll()方法唤醒&lt;/li&gt;
&lt;li&gt;timed_waiting: sleep（时间），wait（时间），到达时间后自动唤醒&lt;/li&gt;
&lt;li&gt;blocked：线程获取不到锁就进入阻塞状态&lt;/li&gt;
&lt;li&gt;TERMINATED：线程终止&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wait和sleep区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;wait是属于Object类的，sleep是属于Thread类的&lt;/li&gt;
&lt;li&gt;wait会让持有锁的线程释放锁，并进入waiting状态，sleep是不会释放锁的，必须有等待时间，时间过后继续执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程停止&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过自定义标识：缺点是线程sleep情况下不能被立刻停止&lt;/li&gt;
&lt;li&gt;通过线程自带标识：
&lt;ol&gt;
&lt;li&gt;当前线程正常执行：Thread.currentThread().isInterrupt()判断为true退出&lt;/li&gt;
&lt;li&gt;当前线程sleep：会抛出异常，捕获后退出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程优先级&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从1-10，表示的是cpu调度到该线程的概率，值越大优先级越高，越有可能被调度到，默认值是5，在宏观角度来看就是占用cpu时间片的多少&lt;/li&gt;
&lt;li&gt;join：在线程b运行的时候执行线程a.join,a先执行执行完了执行b&lt;/li&gt;
&lt;li&gt;yield：将当前运行线程running-&amp;gt;ready，但是可能没效果，该线程可能被再次调度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证线程安全的三个特性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性：线程执行一段代码的过程中不能被其他的线程干扰对结果产生影响。&lt;/li&gt;
&lt;li&gt;可见性：线程修改了变量之后能够立刻被其他线程看见&lt;/li&gt;
&lt;li&gt;有序性：由jvm指令重排序导致的，jvm指令重排能够保证在单线程执行下结果一致，多线程不能保证。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jvm内存结构：jvm运行时的区域划分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java对象模型：对象在jvm内存中的存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存模型：jmm不是真实存在的是虚拟的，它的语法集映射在java语言中就是volidate，synchronized&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保证原子性：因为被synchronized包裹的代码，只能被一个线程执行，所以不会被其他线程干扰&lt;/li&gt;
&lt;li&gt;保证可见性：在加锁时，会清空本地内存变量，解锁的时候会把修改的本地内存变量刷到主内存里面去&lt;/li&gt;
&lt;li&gt;保证有序性：因为被synchronized包裹的代码，只能被一个线程执行,jvm指令重排的结果对单线程没有影响，就算发生了指令重排对synchronized包裹的代码也不会有影响&lt;/li&gt;
&lt;li&gt;加锁：对象的moniterEnter和moniterExit加锁和解锁&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁优化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自旋锁：循环&lt;/li&gt;
&lt;li&gt;适应自旋锁：循环，成功，给锁多循环几次的机会，失败则减少机会，如果多次失败就直接进入重量级锁&lt;/li&gt;
&lt;li&gt;锁消除：如果jvm检测到锁没有竞争就把锁消除了&lt;/li&gt;
&lt;li&gt;锁粗化：把一个个小的锁换成一个大锁&lt;/li&gt;
&lt;li&gt;偏向锁：在markWord中保存threadid，发生竞争就升级&lt;/li&gt;
&lt;li&gt;轻量级锁：通过cas实现&lt;/li&gt;
&lt;li&gt;重量级锁：加锁解锁会导致线程从用户态到核心态的切换，消耗比较大的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;i++为什么不是线程安全的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把变量读到cpu缓存&lt;/li&gt;
&lt;li&gt;操作缓存中的值++&lt;/li&gt;
&lt;li&gt;写回主内存&lt;/li&gt;
&lt;li&gt;由于上述三个步骤不是原子性的，所以会导致线程安全问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
