<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>DB on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/tags/db/</link>
        <description>Recent content in DB on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Sat, 07 Oct 2023 15:01:41 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/tags/db/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySql函数</title>
        <link>https://mikeLing-qx.github.io/p/mysql%E5%87%BD%E6%95%B0/</link>
        <pubDate>Sat, 07 Oct 2023 15:01:41 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/mysql%E5%87%BD%E6%95%B0/</guid>
        <description>&lt;h1 id=&#34;1-group_concat&#34;&gt;1. group_concat
&lt;/h1&gt;&lt;p&gt;统计name 相同的 user&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select name from `user`
group by name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想把 name 相同的 phone 拼接在一起, 存放到一列中可以使用这个group_concat 函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select name,group_concat(phone) from `user`
group by name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-char_length&#34;&gt;2. char_length
&lt;/h1&gt;&lt;p&gt;获取字符的&lt;code&gt;长度&lt;/code&gt;，然后根据字符的长度进行&lt;code&gt;排序&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from brand where name like &#39;%苏三%&#39; 
order by char_length(name) asc limit 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-locate&#34;&gt;3. locate
&lt;/h1&gt;&lt;p&gt;&lt;code&gt;LOCATE()&lt;/code&gt; 函数是 MySQL 中用于查找子串在一个字符串中的位置的函数。该函数返回第一次出现该子串的位置，如果该子串不存在于字符串中，则返回 0。&lt;/p&gt;
&lt;p&gt;该函数的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LOCATE(substr, str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;substr&lt;/code&gt;：需要查找的子串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;：包含该子串的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LOCATE(&#39;world&#39;, &#39;Hello, world!&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	该语句将返回 7，因为子串 &amp;lsquo;world&amp;rsquo; 第一次出现在字符串 &amp;lsquo;Hello, world!&amp;rsquo; 中的位置为 7。&lt;/p&gt;
&lt;h1 id=&#34;4-replace&#34;&gt;4. replace
&lt;/h1&gt;&lt;p&gt;​	&lt;code&gt;REPLACE()&lt;/code&gt; 函数是 MySQL 中用于在一个字符串中替换子串的函数。该函数将字符串中的所有出现的子串替换为指定的字符串，并返回替换后的字符串。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;：需要替换的字符串, 字段名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from_str&lt;/code&gt;：需要被替换的子串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;to_str&lt;/code&gt;：用于替换的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;#语法
REPLACE(str, from_str, to_str)

#例子
SELECT REPLACE(&#39;Hello, world!&#39;, &#39;world&#39;, &#39;friends&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-now&#34;&gt;5. now
&lt;/h1&gt;&lt;p&gt;MYSQL中获取&lt;code&gt;当前时间&lt;/code&gt;，可以使用&lt;code&gt;now()&lt;/code&gt;函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select now() from brand limit 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-insert-into--select&#34;&gt;6. insert into .. select
&lt;/h1&gt;&lt;p&gt;用来批量插入数据, 数据来源于其他表&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) 
select null,code,name,now(3) from `order` where code in (&#39;004&#39;,&#39;005&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-insert-into--ignore&#34;&gt;7. insert into &amp;hellip; ignore
&lt;/h1&gt;&lt;p&gt;场景:  在插入1000个品牌之前，需要先根据name，判断一下是否存在。如果存在，则不插入数据。如果不存在，才需要插入数据。&lt;/p&gt;
&lt;p&gt;brand表的name字段创建了唯一索引，同时该表中已经有一条name等于苏三的数据了, 直接执行会报错&lt;/p&gt;
&lt;p&gt;可以使用 insert into &amp;hellip; select 配合 not exists 语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) 
select null,&#39;108&#39;, &#39;苏三&#39;,now(3) 
from dual where  not exists (select * from `brand` where name=&#39;苏三&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 insert into &amp;hellip; ignore&lt;/p&gt;
&lt;p&gt;==&lt;code&gt;INSERT INTO ... IGNORE&lt;/code&gt; 语句是 MySQL 中用于在插入数据时忽略重复数据的语句。当该语句在插入数据时发现重复的数据时，它会忽略该数据并继续执行。==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target_table&lt;/code&gt;：接收数据的表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column1, column2, ...&lt;/code&gt;：要插入数据的目标列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value1, value2, ...&lt;/code&gt;：要插入的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;#语法
INSERT IGNORE INTO target_table (column1, column2, ...)
VALUES (value1, value2, ...);

#例子
INSERT IGNORE INTO employees (id, name, salary)
VALUES (100, &#39;John Doe&#39;, 50000);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT ignore INTO `brand`(`id`, `code`, `name`, `edit_date`) 
VALUES (123, &#39;108&#39;, &#39;苏三&#39;, now(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会忽略异常，返回的执行结果影响行数为0，它不会重复插入数据。&lt;/p&gt;
&lt;h1 id=&#34;8-select--for-update&#34;&gt;8. select &amp;hellip; for update
&lt;/h1&gt;&lt;h1 id=&#34;9-on-duplicate-key-update&#34;&gt;9. on duplicate key update
&lt;/h1&gt;&lt;p&gt;​	插入数据之前，一般会先查询一下，该数据是否存在。如果不存在，则插入数据。如果已存在，则不插入数据，而直接返回结果&lt;/p&gt;
&lt;p&gt;​    没啥并发量的场景中，这种做法是没有什么问题的。但如果插入数据的请求，有一定的==并发量==，这种做法就==可能会产生重复的数据==。&lt;/p&gt;
&lt;p&gt;​	解决重复数据的做法: ==加唯一索引&lt;code&gt;、&lt;/code&gt;加分布式锁==&lt;/p&gt;
&lt;p&gt;​	这些方案，都==没法做到让第二次请求也更新数据==，它们一般会判断已经存在就直接返回了。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT  INTO `brand`(`id`, `code`, `name`, `edit_date`) 
VALUES (123, &#39;108&#39;, &#39;苏三&#39;, now(3))
on duplicate key update name=&#39;苏三&#39;,edit_date=now(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		==高并发的场景==下使用&lt;code&gt;on duplicate key update&lt;/code&gt;语法，可能会==存在&lt;code&gt;死锁&lt;/code&gt;的问题==，所以要根据实际情况酌情使用。&lt;/p&gt;
&lt;h1 id=&#34;10--show-create-table&#34;&gt;10.  show create table
&lt;/h1&gt;&lt;p&gt;​	快速查看某张表的字段情况，通常会使用&lt;code&gt;desc&lt;/code&gt;命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;desc `user`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show create table `order`;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;非常完整的建表语句，表名、字段名、字段类型、字段长度、字符集、主键、索引、执行引擎等都能看到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;11-show-processlist&#34;&gt;11. show processlist
&lt;/h1&gt;&lt;p&gt;&lt;code&gt;show processlist&lt;/code&gt;命令查看&lt;code&gt;当前线程执行情况&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;12-mysql-dump&#34;&gt;12. mysql dump
&lt;/h1&gt;&lt;p&gt;​		mysqldump 数据量很大的情况 导出xxx.sql 文件占用空间会很大 dump参数支持压缩导出(gzip) 还有==不要在线上运行的数据库== 使用dump 会==锁表== 在线迁移数据库请使用 mysql tool&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
