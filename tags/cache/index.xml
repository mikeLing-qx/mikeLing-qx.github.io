<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Cache on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/tags/cache/</link>
        <description>Recent content in Cache on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Thu, 02 Nov 2023 15:08:41 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/tags/cache/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Spring_jetcache</title>
        <link>https://mikeLing-qx.github.io/p/spring_jetcache/</link>
        <pubDate>Thu, 02 Nov 2023 15:08:41 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/spring_jetcache/</guid>
        <description>&lt;p&gt;源项目文档: &lt;a class=&#34;link&#34; href=&#34;https://github.com/alibaba/jetcache/tree/master/docs/CN&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/alibaba/jetcache/tree/master/docs/CN&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-简介&#34;&gt;1. 简介
&lt;/h1&gt;&lt;p&gt;JetCache是一个基于==Java的缓存系统封装==，==提供统一的API和注解来简化缓存的使用==。 JetCache提供了==比SpringCache更加强大的注解==，可以原生的支持TTL、两级缓存、分布式自动刷新，还提供了&lt;code&gt;Cache&lt;/code&gt;接口用于手工缓存操作。 当前有四个实现，&lt;code&gt;RedisCache&lt;/code&gt;、&lt;code&gt;TairCache&lt;/code&gt;（此部分未在github开源）、&lt;code&gt;CaffeineCache&lt;/code&gt;(in memory)和一个简易的&lt;code&gt;LinkedHashMapCache&lt;/code&gt;(in memory)，要添加新的实现也是非常简单的。&lt;/p&gt;
&lt;p&gt;全部特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过统一的API访问Cache系统&lt;/li&gt;
&lt;li&gt;通过注解实现声明式的方法缓存，支持TTL和两级缓存&lt;/li&gt;
&lt;li&gt;通过注解创建并配置&lt;code&gt;Cache&lt;/code&gt;实例&lt;/li&gt;
&lt;li&gt;针对所有&lt;code&gt;Cache&lt;/code&gt;实例和方法缓存的自动统计&lt;/li&gt;
&lt;li&gt;Key的生成策略和Value的序列化策略是可以配置的&lt;/li&gt;
&lt;li&gt;分布式缓存自动刷新，分布式锁 (2.2+)&lt;/li&gt;
&lt;li&gt;异步Cache API (2.2+，使用Redis的lettuce客户端时)&lt;/li&gt;
&lt;li&gt;Spring Boot支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-使用&#34;&gt;2. 使用
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.alicp.jetcache&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;jetcache-starter-redis-lettuce&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动类上加 &lt;code&gt;@EnableMethodCache&lt;/code&gt; ， &lt;code&gt;@EnableCreateCacheAnnotation&lt;/code&gt; 这两个注解, 分别激活 &lt;code&gt;@Cached&lt;/code&gt; 和 &lt;code&gt;@CreateCache&lt;/code&gt; 注解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置详情参考: https://github.com/alibaba/jetcache/blob/master/docs/CN/Config.md
jetcache:
    statIntervalMinutes: 1 # 统计间隔，0表示不统计
    areaInCacheName: false
    #hiddenPackages: zx.service.visu  # @Cached和@CreateCache自动生成name的时候，为了不让name太长，hiddenPackages指定的包名前缀被截掉
    # @Cached和@CreateCache的area属性 local/remote
    local:
        default:
            type: linkedhashmap  # tair、redis为当前支持的远程缓存；linkedhashmap、caffeine为当前支持的本地缓存类型
            keyConvertor: fastjson2
        mike:
            type: caffeine
            keyConvertor: fastjson2
    remote:
        default:
            type: redis.lettuce  # tair、redis为当前支持的远程缓存；linkedhashmap、caffeine为当前支持的本地缓存类型
            uri: redis://daheng@redis.daheng.co:6379/0?timeout=10s
            keyConvertor: fastjson2
            valueEncoder: java
            valueDecoder: java
            poolConfig:
                minIdle: 5
                maxIdle: 20
                maxTotal: 50
        mike:
            type: redis.lettuce  # tair、redis为当前支持的远程缓存；linkedhashmap、caffeine为当前支持的本地缓存类型
            uri: redis://daheng@redis.daheng.co:6379/3?timeout=10s
            keyConvertor: fastjson2
            valueEncoder: java
            valueDecoder: java
            poolConfig:
                minIdle: 5
                maxIdle: 20
                maxTotal: 50
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    // 添加缓存
    @Cached(name=&amp;quot;userCache.&amp;quot;, key=&amp;quot;#userId&amp;quot;, expire = 3600)
    User getUserById(long userId);

	// 更新缓存
    @CacheUpdate(name=&amp;quot;userCache.&amp;quot;, key=&amp;quot;#user.userId&amp;quot;, value=&amp;quot;#user&amp;quot;)
    void updateUser(User user);

	// 移除缓存
    @CacheInvalidate(name=&amp;quot;userCache.&amp;quot;, key=&amp;quot;#userId&amp;quot;)
    void deleteUser(long userId);
    
    // CacheRefresh
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;==@Cache 注解==&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;属性&lt;/th&gt;
          &lt;th&gt;默认值&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;area&lt;/td&gt;
          &lt;td&gt;“default”&lt;/td&gt;
          &lt;td&gt;如果在配置中配置了多个缓存area，在这里指定使用哪个area&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;name&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;指定缓存的唯一名称，不是必须的，如果没有指定，会使用类名+方法名。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;key&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;使用&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpEL&lt;/a&gt;指定key，如果没有指定会根据所有参数自动生成。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;expire&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;timeUnit&lt;/td&gt;
          &lt;td&gt;TimeUnit.SECONDS&lt;/td&gt;
          &lt;td&gt;指定expire的单位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cacheType&lt;/td&gt;
          &lt;td&gt;CacheType.REMOTE&lt;/td&gt;
          &lt;td&gt;缓存的类型，包括CacheType.REMOTE、CacheType.LOCAL、CacheType.BOTH。如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;localLimit&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;localExpire&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;仅当cacheType为BOTH时适用，为内存中的Cache指定一个不一样的超时时间，通常应该小于expire&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;serialPolicy&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;指定远程缓存的序列化方式。可选值为SerialPolicy.JAVA和SerialPolicy.KRYO。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为SerialPolicy.JAVA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;keyConvertor&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，当前支持KeyConvertor.FASTJSON和KeyConvertor.NONE。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;enabled&lt;/td&gt;
          &lt;td&gt;true&lt;/td&gt;
          &lt;td&gt;是否激活缓存。例如某个dao方法上加缓存注解，由于某些调用场景下不能有缓存，所以可以设置enabled为false，正常调用不会使用缓存，在需要的地方可使用CacheContext.enableCache在回调中激活缓存，缓存激活的标记在ThreadLocal上，该标记被设置后，所有enable=false的缓存都被激活&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cacheNullValue&lt;/td&gt;
          &lt;td&gt;false&lt;/td&gt;
          &lt;td&gt;当方法返回值为null的时候是否要缓存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;condition&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;使用&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpEL&lt;/a&gt;指定条件，如果表达式返回true的时候才去缓存中查询&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;postCondition&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;使用&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpEL&lt;/a&gt;指定条件，如果表达式返回true的时候才更新缓存，该评估在方法执行后进行，因此可以访问到#result&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;==@CacheRefresh注解==&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;属性&lt;/th&gt;
          &lt;th&gt;默认值&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;refresh&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;刷新间隔&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;timeUnit&lt;/td&gt;
          &lt;td&gt;TimeUnit.SECONDS&lt;/td&gt;
          &lt;td&gt;时间单位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;stopRefreshAfterLastAccess&lt;/td&gt;
          &lt;td&gt;未定义&lt;/td&gt;
          &lt;td&gt;指定该key多长时间没有访问就停止刷新，如果不指定会一直刷新&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;refreshLockTimeout&lt;/td&gt;
          &lt;td&gt;60秒&lt;/td&gt;
          &lt;td&gt;类型为BOTH/REMOTE的缓存刷新时，同时只会有一台服务器在刷新，这台服务器会在远程缓存放置一个分布式锁，此配置指定该锁的超时时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​		key使用Spring的&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpEL&lt;/a&gt;脚本来指定。如果要使用参数名（比如这里的&lt;code&gt;key=&amp;quot;#userId&amp;quot;&lt;/code&gt;），项目编译设置target必须为1.8格式，并且指定javac的-parameters参数，否则就要使用&lt;code&gt;key=&amp;quot;args[0]&amp;quot;&lt;/code&gt;这样按下标访问的形式。&lt;/p&gt;
&lt;h1 id=&#34;3-配置详解&#34;&gt;3. 配置详解
&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jetcache:
  statIntervalMinutes: 15
  areaInCacheName: false
  hidePackages: com.alibaba
  local:
    default:
      type: caffeine
      limit: 100
      keyConvertor: fastjson2 #其他可选：fastjson/jackson
      expireAfterWriteInMillis: 100000
    otherArea:
      type: linkedhashmap
      limit: 100
      keyConvertor: none
      expireAfterWriteInMillis: 100000
  remote:
    default:
      type: redis
      keyConvertor: fastjson2 #其他可选：fastjson/jackson
      broadcastChannel: projectA
      valueEncoder: java #其他可选：kryo/kryo5
      valueDecoder: java #其他可选：kryo/kryo5
      poolConfig:
        minIdle: 5
        maxIdle: 20
        maxTotal: 50
      host: ${redis.host}
      port: ${redis.port}
    otherArea:
      type: redis
      keyConvertor: fastjson2 #其他可选：fastjson/jackson
      broadcastChannel: projectA
      valueEncoder: java #其他可选：kryo/kryo5
      valueDecoder: java #其他可选：kryo/kryo5
      poolConfig:
        minIdle: 5
        maxIdle: 20
        maxTotal: 50
      host: ${redis.host}
      port: ${redis.port}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;属性&lt;/th&gt;
          &lt;th&gt;默认值&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.statIntervalMinutes&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;统计间隔，0表示不统计&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.areaInCacheName&lt;/td&gt;
          &lt;td&gt;true(2.6-) false(2.7+)&lt;/td&gt;
          &lt;td&gt;jetcache-anno把cacheName作为远程缓存key前缀，2.4.3以前的版本总是把areaName加在cacheName中，因此areaName也出现在key前缀中。2.4.4以后可以配置，为了保持远程key兼容默认值为true，但是新项目的话false更合理些，2.7默认值已改为false。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.hiddenPackages&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;@Cached和@CreateCache自动生成name的时候，为了不让name太长，hiddenPackages指定的包名前缀被截掉&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.type&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;缓存类型。tair、redis为当前支持的远程缓存；linkedhashmap、caffeine为当前支持的本地缓存类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.keyConvertor&lt;/td&gt;
          &lt;td&gt;fastjson2&lt;/td&gt;
          &lt;td&gt;key转换器的全局配置，2.6.5+已经支持的keyConvertor：&lt;code&gt;fastjson2&lt;/code&gt;/&lt;code&gt;jackson&lt;/code&gt;； 2.6.5-只有一个已经实现的keyConvertor：&lt;code&gt;fastjson&lt;/code&gt;。仅当使用@CreateCache且缓存类型为LOCAL时可以指定为&lt;code&gt;none&lt;/code&gt;，此时通过equals方法来识别key。方法缓存必须指定keyConvertor&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.valueEncoder&lt;/td&gt;
          &lt;td&gt;java&lt;/td&gt;
          &lt;td&gt;序列化器的全局配置。仅remote类型的缓存需要指定，2.7+可选&lt;code&gt;java&lt;/code&gt;/&lt;code&gt;kryo&lt;/code&gt;/&lt;code&gt;kryo5&lt;/code&gt;；2.6-可选&lt;code&gt;java&lt;/code&gt;/&lt;code&gt;kryo&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.valueDecoder&lt;/td&gt;
          &lt;td&gt;java&lt;/td&gt;
          &lt;td&gt;序列化器的全局配置。仅remote类型的缓存需要指定，2.7+可选&lt;code&gt;java&lt;/code&gt;/&lt;code&gt;kryo&lt;/code&gt;/&lt;code&gt;kryo5&lt;/code&gt;；2.6-可选&lt;code&gt;java&lt;/code&gt;/&lt;code&gt;kryo&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.limit&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
          &lt;td&gt;每个缓存实例的最大元素的全局配置，仅local类型的缓存需要指定。注意是每个缓存实例的限制，而不是全部，比如这里指定100，然后用@CreateCache创建了两个缓存实例（并且注解上没有设置localLimit属性），那么每个缓存实例的限制都是100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.[local/remote].${area}.expireAfterWriteInMillis&lt;/td&gt;
          &lt;td&gt;无穷大&lt;/td&gt;
          &lt;td&gt;以毫秒为单位指定超时时间的全局配置(以前为defaultExpireInMillis)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.remote.${area}.broadcastChannel&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;==jetcahe2.7的两级缓存支持更新以后失效其他JVM中的local cache==，但多个服务共用redis同一个channel可能会造成广播风暴，需要在这里指定channel，你可以决定多个不同的服务是否共用同一个channel。如果没有指定则不开启。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;jetcache.local.${area}.expireAfterAccessInMillis&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;需要jetcache2.2以上，以毫秒为单位，指定多长时间没有访问，就让缓存失效，当前只有本地缓存支持。0表示不使用这个功能&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;缓存的超时时间，有多个地方指定&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;put等方法上指定了超时时间，则以此时间为准&lt;/li&gt;
&lt;li&gt;put等方法上未指定超时时间，使用Cache实例的默认超时时间&lt;/li&gt;
&lt;li&gt;Cache实例的默认超时时间，通过在@CreateCache和@Cached上的expire属性指定，如果没有指定，使用yml中定义的全局配置，例如@Cached(cacheType=local)使用jetcache.local.default.expireAfterWriteInMillis，如果仍未指定则是无穷大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
