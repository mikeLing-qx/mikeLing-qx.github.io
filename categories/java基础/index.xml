<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java基础 on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/categories/java%E5%9F%BA%E7%A1%80/</link>
        <description>Recent content in Java基础 on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Mon, 21 Dec 2020 19:21:43 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/categories/java%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Java基础</title>
        <link>https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Mon, 21 Dec 2020 19:21:43 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h1 id=&#34;概览&#34;&gt;概览
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.介绍一下 java 吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.java 有哪些数据类型？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.接口和抽象类有什么区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.重载和重写什么区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.常见的异常有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6.异常要怎么解决？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7.arrayList 和 linkedList 的区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8.hashMap 1.7 和 hashMap 1.8 的区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;9.hashMap 线程不安全体现在哪里？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10.那么 hashMap 线程不安全怎么解决？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;11.concurrentHashMap 1.7 和 1.8 有什么区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;12.介绍一下 hashset 吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;13.什么是泛型？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;14.泛型擦除是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;15.说说进程和线程的区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16.volatile 有什么作用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;17.什么是包装类？为什么需要包装类？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;18.Integer a = 1000，Integer b = 1000，a==b 的结果是什么？那如果 a，b 都为1，结果又是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;19.JMM 是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;20.创建对象有哪些方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;21.讲讲单例模式懒汉式吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;22.volatile 有什么作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;23.怎么保证线程安全？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;24.synchronized 锁升级的过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;25.cas 是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;26.聊聊 ReentrantLock 吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;27.多线程的创建方式有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;28.线程池有哪些参数？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;29.线程池的执行流程？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;30.线程池的拒绝策略有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;31.介绍一下四种引用类型?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;32.深拷贝、浅拷贝是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;33.聊聊 ThreadLocal 吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;34.一个对象的内存布局是怎么样的?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;35.方法参数传递&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-介绍一下java&#34;&gt;1. 介绍一下java
&lt;/h1&gt;&lt;p&gt;java 是一门==&lt;strong&gt;「开源的跨平台的面向对象的」&lt;/strong&gt;==计算机语言&lt;/p&gt;
&lt;p&gt;跨平台是因为 java 的 class 文件是运行在虚拟机上的,其实跨平台的,而**「虚拟机是不同平台有不同版本」**,所以说 java 是跨平台的.&lt;/p&gt;
&lt;p&gt;面向对象特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.&lt;strong&gt;「封装」&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;两层含义：一层含义是把对象的属性和行为看成一个密不可分的整体，将这两者&amp;rsquo;封装&amp;rsquo;在一个不可分割的**「独立单元」**(即对象)中&lt;/li&gt;
&lt;li&gt;另一层含义指&amp;rsquo;信息隐藏，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性或行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能**「隐藏对象的功能实现细节」**。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1.良好的封装能够**「减少耦合」&lt;strong&gt;，符合程序设计追求&amp;rsquo;高内聚，低耦合&amp;rsquo;
2.&lt;/strong&gt;「类内部的结构可以自由修改」**
3.可以对成员变量进行更**「精确的控制」**
4.**「隐藏信息」**实现细节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2.&lt;strong&gt;「继承」&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1.提高类代码的**「复用性」**
2.提高了代码的**「维护性」**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3.&lt;strong&gt;「多态」&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;1.&lt;strong&gt;「方法重载」&lt;/strong&gt;：在一个类中，允许多个方法使用同一个名字，但方法的参数不同，完成的功能也不同。&lt;/li&gt;
&lt;li&gt;2.&lt;strong&gt;「对象多态」&lt;/strong&gt;：子类对象可以与父类对象进行转换，而且根据其使用的子类不同完成的功能也不同（重写父类的方法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;多态是同一个行为具有多个不同表现形式或形态的能力。Java语言中含有方法重载与对象多态两种形式的多态：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;「消除类型之间的耦合关系」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「可替换性」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「可扩充性」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「接口性」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「灵活性」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「简化性」&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-java基础数据类型&#34;&gt;2. Java基础数据类型
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225104330769.png&#34;
	width=&#34;814&#34;
	height=&#34;503&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225104330769&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;161&#34;
		data-flex-basis=&#34;388px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-接口和抽象类的区别&#34;&gt;3. 接口和抽象类的区别
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.接口是抽象类的变体，&lt;strong&gt;「接口中所有的方法都是抽象的」&lt;/strong&gt;。而抽象类是声明方法的存在而不去实现它的类。&lt;/li&gt;
&lt;li&gt;2.接口可以多继承，抽象类不行。&lt;/li&gt;
&lt;li&gt;3.接口==定义方法，不能实现==，默认是 ==&lt;strong&gt;「public abstract」&lt;/strong&gt;==，而抽象类可以实现部分方法。&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;==接口中基本数据类型为 &lt;strong&gt;「public static final」&lt;/strong&gt;== 并且需要给出初始值，而抽类象不是的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-重载和重写的区别&#34;&gt;4. 重载和重写的区别
&lt;/h1&gt;&lt;p&gt;重写：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.参数列表必须**「完全与被重写的方法」**相同，否则不能称其为重写而是重载.&lt;/li&gt;
&lt;li&gt;2.&lt;strong&gt;「返回的类型必须一直与被重写的方法的返回类型相同」&lt;/strong&gt;，否则不能称其为重写而是重载。&lt;/li&gt;
&lt;li&gt;3.访问**「修饰符的限制一定要大于被重写方法的访问修饰符」**&lt;/li&gt;
&lt;li&gt;4.重写方法一定**「不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常」**。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.必须具有**「不同的参数列表」**；&lt;/li&gt;
&lt;li&gt;2.可以有不同的返回类型，只要参数列表不同就可以了；&lt;/li&gt;
&lt;li&gt;3.可以有**「不同的访问修饰符」**；&lt;/li&gt;
&lt;li&gt;4.可以抛出**「不同的异常」**&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-异常的处理方法&#34;&gt;5. 异常的处理方法
&lt;/h1&gt;&lt;p&gt;Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类&lt;/p&gt;
&lt;p&gt;Throwable又派生出**「Error类和Exception类」**&lt;/p&gt;
&lt;p&gt;错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类&lt;/p&gt;
&lt;p&gt;异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;try() catch()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;throw&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用是抛出一个异常, 抛出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法throws&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示此方法不处理异常, 而交给方法调用处进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;6-arraylist-和-linkedlist-的区别&#34;&gt;6. ArrayList 和 LinkedList 的区别
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225153351381.png&#34;
	width=&#34;380&#34;
	height=&#34;208&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225153351381&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;438px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据结构不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList 是基于数组的, 存储空间是连续的&lt;/li&gt;
&lt;li&gt;LinkedList 是基于链表的, 双向链表 , 存储空间不连续&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于get 和 set , ArrayList 比较好, 因为不需要移动指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增和删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinkList 占优势, 因为 ArrayList 需要移动数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样数据量, LinkedList 所占的空间会更小, 因为 ArrayList ==需要预留空间== 方便后面的数据增加; LinkedList 增加数据只要 ==增加一个节点==&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-hashmap-17-和-18-的区别&#34;&gt;7. HashMap 1.7 和 1.8 的区别
&lt;/h1&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;不同点&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;hashMap 1.7&lt;/th&gt;
          &lt;th style=&#34;text-align: right&#34;&gt;hashMap 1.8&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;数据结构&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;数组+链表&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;数组+链表+红黑树&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;插入数据的方式&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;头插法&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;尾插法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;hash 值计算方式&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;9次扰动处理(4次位运算+5次异或)&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;2次扰动处理(1次位运算+1次异或)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;扩容策略&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;插入前扩容&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;插入后扩容&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;9-hashmap-线程不安全的体现&#34;&gt;9. HashMap 线程不安全的体现
&lt;/h1&gt;&lt;p&gt;在 **「hashMap1.7 中扩容」**的时候，因为采用的是头插法，所以会可能会有循环链表产生，导致数据有问题，在 1.8 版本已修复，改为了尾插法&lt;/p&gt;
&lt;p&gt;在任意版本的 hashMap 中，如果在**「插入数据时多个线程命中了同一个槽」**，可能会有数据覆盖的情况发生，导致线程不安全。&lt;/p&gt;
&lt;h1 id=&#34;10-hashmap-线程不安全怎么解决&#34;&gt;10. HashMap 线程不安全怎么解决
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;直接加锁&lt;/li&gt;
&lt;li&gt;使用hashTable, 其实就是在方法上加了synchronized&lt;/li&gt;
&lt;li&gt;使用concurrentHashMap, 不管是1.7 和 1.8, 本质都是==减小了锁的力度, 减少锁竞争==&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;11-concurrenthashmap-17和-18的区别&#34;&gt;11. concurrentHashMap 1.7和 1.8的区别
&lt;/h1&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;不同点&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;concurrentHashMap 1.7&lt;/th&gt;
          &lt;th style=&#34;text-align: right&#34;&gt;concurrentHashMap 1.8&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;锁粒度&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;基于segment&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;基于entry节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;锁&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;reentrantLock&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;synchronized&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;底层结构&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;Segment + HashEntry + Unsafe&lt;/td&gt;
          &lt;td style=&#34;text-align: right&#34;&gt;Synchronized + CAS + Node + Unsafe&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;12-hashset&#34;&gt;12. HashSet
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;set 继承于 Collection 接口, 是一个 ==无序不重复集合==&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;==基于 HashMap 实现的, 底层采用HashMap 来保存元素==&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素的哈希值是通过元素的 hashcode 方法 来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 ==equals 方法 如果 equls 结果为 true== ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;13-什么是泛型&#34;&gt;13. 什么是泛型
&lt;/h1&gt;&lt;p&gt;把==类型明确的工作, 推迟==到 ==创建对象== 或 ==调用方法==的时候 才去明确的 特殊 类型&lt;/p&gt;
&lt;h1 id=&#34;14-泛型擦除&#34;&gt;14. 泛型擦除
&lt;/h1&gt;&lt;p&gt;因为泛型其实只是在编译器中实现的而虚拟机并不认识泛型类项，所以要在虚拟机中将泛型类型进行擦除。也就是说，==&lt;strong&gt;「在编译阶段使用泛型，运行阶段取消泛型，即擦除」&lt;/strong&gt;==。擦除是将泛型类型以其父类代替，如String 变成了Object等。其实在使用的时候还是进行带强制类型的转化，只不过这是比较安全的转换，因为在编译阶段已经确保了数据的一致性&lt;/p&gt;
&lt;h1 id=&#34;15-进程和线程的区别&#34;&gt;15. 进程和线程的区别
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;「进程是系统资源分配和调度的基本单位」&lt;/strong&gt;，它能并发执行较高系统资源的利用率.&lt;/li&gt;
&lt;li&gt;**「线程」&lt;strong&gt;是&lt;/strong&gt;「比进程更小」**的能独立运行的基本单位, 创建、销毁、切换==成本要小==于进程,可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;16-volatile-的作用&#34;&gt;16. volatile 的作用
&lt;/h1&gt;&lt;p&gt;保证共享变量的可见性和有序性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「1.保证内存可见性」&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「2.禁止指令重排序」&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;17-简述包装类-为什么需要包装类&#34;&gt;17. 简述包装类, 为什么需要包装类
&lt;/h1&gt;&lt;p&gt;八种基本类型, 对应8 种包装类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「为什么需要包装类」&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型方便、简单、高效，==但泛型不支持、集合元素不支持==&lt;/li&gt;
&lt;li&gt;不符合面向对象思维&lt;/li&gt;
&lt;li&gt;包装类提供很多方法，方便使用，如 Integer 类 toHexString(int i)、parseInt(String s) 方法等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;18-包装类的缓存&#34;&gt;18. 包装类的缓存
&lt;/h1&gt;&lt;p&gt;Integer a = 1000，Integer b = 1000，a==b 结果为**「false」**&lt;/p&gt;
&lt;p&gt;Integer a = 1，Integer b = 1，a==b 结果为**「true」**&lt;/p&gt;
&lt;p&gt;这道题主要考察 Integer 包装类缓存的范围,&lt;strong&gt;「在-128~127之间会缓存起来」&lt;/strong&gt;,比较的是直接缓存的数据,在此之外比较的是对象&lt;/p&gt;
&lt;h1 id=&#34;19-jmm&#34;&gt;19. JMM
&lt;/h1&gt;&lt;p&gt;JMM 就是 ==&lt;strong&gt;「Java内存模型」&lt;/strong&gt;==(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以java内存模型(JMM)&lt;strong&gt;「屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。==&lt;strong&gt;「线程不能直接读写主内存中的变量」&lt;/strong&gt;==。&lt;/p&gt;
&lt;p&gt;每个线程的工作内存都是==独立的==，==**「线程操作数据只能在工作内存中进行，然后刷回到主存」&lt;em&gt;==&lt;/em&gt;。这是 Java 内存模型定义的线程基本工作方式。&lt;/p&gt;
&lt;h1 id=&#34;20-创建对象的方式&#34;&gt;20. 创建对象的方式
&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1. new 关键字
Person person = new Person();

2. Class.newInstance
Person p1 = Person.class.newInstance();

3. Constructor.newInstance
Constructor&amp;lt;Person&amp;gt; constructor = Person.class.getConstructor();

4. clone
Person person =  new Person();
Person person2 = person.clone();

5. 反序列化
Person p1 = new Person();
byte[] bytes = SerializationUtils.serialize(p1);
Person p2 = (Person)SerializationUtils.deserialize(bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-讲讲单例懒汉模式&#34;&gt;21. 讲讲单例懒汉模式
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// 懒汉式
public class Singleton {
	// 延迟加载保证多线程安全
    Private volatile static Singleton singleton;
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用 volatile 是**「防止指令重排序，保证对象可见」**，防止读到半初始化状态的对象&lt;/li&gt;
&lt;li&gt;第一层if(singleton == null) 是为了防止有多个线程同时创建&lt;/li&gt;
&lt;li&gt;synchronized 是加锁防止多个线程同时进入该方法创建对象&lt;/li&gt;
&lt;li&gt;第二层if(singleton == null) 是防止有多个线程同时等待锁，一个执行完了后面一个又继续执行的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;22-如何保证线程安全&#34;&gt;22. 如何保证线程安全?
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;synchronized 关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;代码块, 方法 (静态方法, 同步锁是当前字节码对象,  实例方法, 同步锁是实例对象)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;lock 锁机制 (必须要在finally 中进行释放)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;Lock lock = new ReentrantLock();
lock. lock();
try {
    System. out. println(&amp;quot;获得锁&amp;quot;);
} catch (Exception e) {

} finally {
    System. out. println(&amp;quot;释放锁&amp;quot;);
    lock. unlock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;23-synchronized-锁升级的过程&#34;&gt;23. synchronized 锁升级的过程
&lt;/h1&gt;&lt;p&gt;在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，&lt;strong&gt;「锁是」&lt;/strong&gt; cpu 一个**「总量级的资源」**，每次获取锁都要和 cpu 申请，非常消耗性能。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;「jdk1.6 之后」&lt;/strong&gt; Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，&lt;strong&gt;「增加了锁升级的过程」&lt;/strong&gt;，由无锁-&amp;gt;偏向锁-&amp;gt;自旋锁-&amp;gt;重量级锁&lt;/p&gt;
&lt;p&gt;==增加锁升级的过程主要是**「减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁**==&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225164535298.png&#34;
	width=&#34;869&#34;
	height=&#34;473&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225164535298&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;440px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;25-cas-是什么&#34;&gt;25. CAS 是什么
&lt;/h1&gt;&lt;p&gt;cas 叫做 CompareAndSwap，&lt;strong&gt;「比较并交换」&lt;/strong&gt;，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是**「通过处理器的指令来保证操作的原子性」**，它主要包含三个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;「1.变量内存地址」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「2.旧的预期值 A」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「3.准备设置的新值 B」&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，&lt;strong&gt;「如果相同就认为其他线程没有进行修改」&lt;/strong&gt;，而将新值写入内存&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;「CPU开销比较大」&lt;/strong&gt;：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用CPU，如果CAS一直更新不成功就会一直占用，造成CPU的浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「ABA 问题」&lt;/strong&gt;：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用**「版本号」**来解决这个问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「只能保证一个共享变量的原子性」&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;26-reentrantlock-可重入锁&#34;&gt;26. ReentrantLock 可重入锁
&lt;/h1&gt;&lt;p&gt;==底层就是使用AQS==&lt;/p&gt;
&lt;p&gt;ReentrantLock有两种模式，一种是公平锁，一种是非公平锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平模式下等待线程入队列后会严格==按照队列顺序==去执行&lt;/li&gt;
&lt;li&gt;非公平模式下等待线程入队列后有可能会出现插队情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-公平锁&#34;&gt;1. 公平锁
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225165402177.png&#34;
	width=&#34;872&#34;
	height=&#34;639&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225165402177&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;136&#34;
		data-flex-basis=&#34;327px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;第一步: ==获取状态的state 的值==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 state = ==0 代表锁没有被其他线程占用==, 执行第二步&lt;/li&gt;
&lt;li&gt;如果 state != 0 则代表锁正在被其他线程占用, 执行第三步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二步: ==判断队列中是否有线程在排队==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不存在, 则将锁的所有者设置成当前线程, 且更新 state&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果存在就入队&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三步: ==判断锁的所有者是不是当前线程==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是则 更新状态 state的 值&lt;/li&gt;
&lt;li&gt;如果不是, 线程进入队列排队等待&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-非公平锁&#34;&gt;2. 非公平锁
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/640.png&#34;
	width=&#34;1080&#34;
	height=&#34;1189&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;90&#34;
		data-flex-basis=&#34;217px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取状态的 state 的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果 state=0 即代表锁没有被其它线程占用，==则设置当前锁的持有者为当前线程，该操作用 CAS 完成==。&lt;/li&gt;
&lt;li&gt;如果不为0或者设置失败，代表锁被占用进行下一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时**「获取 state 的值」**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果是，则给state+1，获取锁&lt;/li&gt;
&lt;li&gt;如果不是，则进入队列等待&lt;/li&gt;
&lt;li&gt;如果是0，代表刚好线程释放了锁，此时将锁的持有者设为自己&lt;/li&gt;
&lt;li&gt;如果不是0，则查看线程持有者是不是自己&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;27-多线程的创建方式&#34;&gt;27. 多线程的创建方式
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;继承Thread 类, 重写 run() 方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;public class Demo extends Thread{
    //重写父类Thread的run()
    public void run() {
    }
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.start();
        d2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现Runnable 接口, 重写run()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;public class Demo2 implements Runnable{

    //重写Runnable接口的run()
    public void run() {
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new Demo2());
        Thread t2 = new Thread(new Demo2());
        t1.start();
        t2.start();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现Callable 接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo implements Callable&amp;lt;String&amp;gt;{

    public String call() throws Exception {
        System.out.println(&amp;quot;正在执行新建线程任务&amp;quot;);
        Thread.sleep(2000);
        return &amp;quot;结果&amp;quot;;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Demo d = new Demo();
        FutureTask&amp;lt;String&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(d);
        Thread t = new Thread(task);
        t.start();
        //获取任务执行后返回的结果
        String result = task.get();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用线程池创建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;public class Demo {
    public static void main(String[] args) {
        Executor threadPool = Executors.newFixedThreadPool(5);
        for(int i = 0 ;i &amp;lt; 10 ; i++) {
            threadPool.execute(new Runnable() {
                public void run() {
                    //todo
                }
            });
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;28-线程池有哪些参数&#34;&gt;28. 线程池有哪些参数
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;corePoolSize: 核心线程函数,   线程池中始终存活的线程数&lt;/li&gt;
&lt;li&gt;maximumPoolSize: 最大线程数, 线程池中允许的 最大线程数&lt;/li&gt;
&lt;li&gt;keepAliveTime: 存活时间, 线程没有执行任务时 最多保持多久时间会终止&lt;/li&gt;
&lt;li&gt;unit: danwei 参数keepAliveTime的时间单位，7种可选&lt;/li&gt;
&lt;li&gt;workQueue: 一个阻塞队列, 用来存储等待执行的任务, 均为线程安全, 7 种可选&lt;/li&gt;
&lt;li&gt;threadFactory: 线程工厂, 主要是用来创建线程, 正常优先级、非守护线程&lt;/li&gt;
&lt;li&gt;handler: 拒绝策略, 拒绝处理任务时的策略, 4 种可选&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;29-线程池的执行流程&#34;&gt;29. 线程池的执行流程
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225173940901.png&#34;
	width=&#34;847&#34;
	height=&#34;777&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225173940901&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;109&#34;
		data-flex-basis=&#34;261px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;判断线程池中的线程数**「是否大于设置的核心线程数」**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果**「没有满」&lt;strong&gt;，则&lt;/strong&gt;「放入队列」**，等待线程空闲时执行任务&lt;/li&gt;
&lt;li&gt;如果队列已经**「满了」&lt;strong&gt;，则判断&lt;/strong&gt;「是否达到了线程池设置的最大线程数」**&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果**「没有达到」&lt;strong&gt;，就&lt;/strong&gt;「创建新线程」**来执行任务&lt;/li&gt;
&lt;li&gt;如果已经**「达到了」&lt;strong&gt;最大线程数，则&lt;/strong&gt;「执行指定的拒绝策略」**&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果**「小于」&lt;strong&gt;，就&lt;/strong&gt;「创建」**一个核心线程来执行任务&lt;/li&gt;
&lt;li&gt;如果**「大于」&lt;strong&gt;，就会&lt;/strong&gt;「判断缓冲队列是否满了」**&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;30-线程池的拒绝策略&#34;&gt;30. 线程池的拒绝策略
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;「AbortPolicy」&lt;/strong&gt;：直接丢弃任务，抛出异常，这是默认策略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「CallerRunsPolicy」&lt;/strong&gt;：只用调用者所在的线程来处理任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「DiscardOldestPolicy」&lt;/strong&gt;：丢弃等待队列中最旧的任务，并执行当前任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「DiscardPolicy」&lt;/strong&gt;：直接丢弃任务，也不抛出异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;31-四种引用类型&#34;&gt;31. 四种引用类型
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;强引用
&lt;ul&gt;
&lt;li&gt;垃圾回收器不会回收被引用的对象，哪怕内存不足时，JVM 也会直接抛出 OutOfMemoryError，除非赋值为 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软引用
&lt;ul&gt;
&lt;li&gt;软引用是用来描述一些==非必需但仍有用的对象==。在内存足够的时候，软引用对象不会被回收，只有在内存==不足时==，系统则会==回收==软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱引用
&lt;ul&gt;
&lt;li&gt;弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚引用
&lt;ul&gt;
&lt;li&gt;最弱的一种引用关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;32-深拷贝-浅拷贝&#34;&gt;32. 深拷贝, 浅拷贝
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝并不是真的拷贝，只是==&lt;strong&gt;「复制指向某个对象的指针」&lt;/strong&gt;==，而不复制对象本身，新旧对象还是共享同一块内存。&lt;/li&gt;
&lt;li&gt;深拷贝会另外==&lt;strong&gt;「创造一个一模一样的对象」&lt;/strong&gt;==，新对象跟原对象不共享内存，修改新对象不会改到原对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;33-threadlocal&#34;&gt;33. ThreadLocal
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ThreadLocal其实就是==&lt;strong&gt;「线程本地变量」&lt;/strong&gt;==，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225175445083.png&#34;
	width=&#34;844&#34;
	height=&#34;273&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225175445083&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;309&#34;
		data-flex-basis=&#34;741px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ThreadLocal 有一个**「静态内部类 ThreadLocalMap」&lt;strong&gt;，ThreadLocalMap 又包含了一个 Entry 数组，&lt;/strong&gt;「Entry 本身是一个弱引用」&lt;strong&gt;，他的 key 是指向 ThreadLocal 的弱引用，&lt;/strong&gt;「弱引用的目的是为了防止内存泄露」**,如果是强引用那么除非线程结束,否则无法终止,可能会有内存泄漏的风险&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是这样还是会存在内存泄露的问题，假如 key 和 ThreadLocal 对象被回收之后，entry 中就存在 key 为 null ，但是 value 有值的 entry 对象，但是永远没办法被访问到，同样除非线程结束运行。&lt;strong&gt;「解决方法就是调用 remove 方法删除 entry 对象」&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;34-一个对象的内存布局&#34;&gt;34. 一个对象的内存布局
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/java%E5%9F%BA%E7%A1%80/images/image-20220225174828437.png&#34;
	width=&#34;850&#34;
	height=&#34;520&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220225174828437&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;163&#34;
		data-flex-basis=&#34;392px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「1.对象头」&lt;/strong&gt;: 对象头又分为 &lt;strong&gt;「MarkWord」&lt;/strong&gt; 和 &lt;strong&gt;「Class Pointer」&lt;/strong&gt; 两部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;「MarkWord」&lt;/strong&gt;:包含一系列的标记位，比如==轻量级锁的标记位，偏向锁标记位,gc记录信息==等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「ClassPointer」&lt;/strong&gt;:用来==指向对象对应的 Class 对象（其对应的元数据对象）的内存地址==。在 32 位系统占 4 字节，在 64 位系统中占 8 字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「2.Length」&lt;/strong&gt;:只在数组对象中存在，用来记录数组的长度，占用 4 字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「3.Instance data」&lt;/strong&gt;: ==对象实际数据==，对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定。(这里不包括==静态成员变量，因为其是在方法区==维护的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「4.Padding」&lt;/strong&gt;:Java 对象占用空间是 8 字节对齐的，即所有 Java 对象占用 bytes 数必须是 8 的倍数,是因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是 8 个字节，所以为了完整，==padding 的作用就是补充字节，&lt;strong&gt;「保证对象是 8 字节的整数倍」&lt;/strong&gt;==。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;35-方法参数传递&#34;&gt;35. 方法参数传递
&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果形参是基本数据类型，那么实参（实际数据）向形参传递的时候，就是直接传递值，把实际值复制给形参&lt;/li&gt;
&lt;li&gt;如果形参是对象，那么实参（实际对象），向形参传递参数时，也是把值传递给形参，这个值是==实参在栈的值，也就是引用对象在堆内存中的地址==&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
