<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>RocketMq on lexqinMike</title>
        <link>https://mikeLing-qx.github.io/categories/rocketmq/</link>
        <description>Recent content in RocketMq on lexqinMike</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>LexqinMike</copyright>
        <lastBuildDate>Sun, 14 Jul 2024 16:23:18 +0800</lastBuildDate><atom:link href="https://mikeLing-qx.github.io/categories/rocketmq/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>RocketMq</title>
        <link>https://mikeLing-qx.github.io/p/rocketmq/</link>
        <pubDate>Sun, 14 Jul 2024 16:23:18 +0800</pubDate>
        
        <guid>https://mikeLing-qx.github.io/p/rocketmq/</guid>
        <description>&lt;h1 id=&#34;1-rocketmq-简介&#34;&gt;1. RocketMq 简介
&lt;/h1&gt;&lt;h2 id=&#34;1-特点&#34;&gt;1. 特点
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能够保证严格的消息顺序，在一个队列中可靠的先进先出（FIFO）和严格的顺序传递&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供丰富的消息拉取模式，支持拉（pull）和推（push）两种消息模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;推模式：在推模式下，==消息从服务器“推动”到消费者==。这意味着一旦有新的消息进入服务器，服务器都会将它们推送给消费者，消费者只需要接收和处理消息即可。这种模式下，消费者较为被动，主要关注点是如何处理推送过来的消息，适合消息处理速度较快，对实时性要求较高的场景。&lt;/p&gt;
&lt;p&gt;拉模式：在拉模式下，==消费者从服务器“拉取”消息==。这样，消费者可以决定何时获取消息，并可根据自身需求和能力去主动获取消息，因此可以更好地控制消息处理的速度和节奏。它适合处理的消息并不那么紧急，允许有一定延迟的场景，或者处理能力有限需要自我控制拉取速度的场景。&lt;/p&gt;
&lt;p&gt;值得注意的是，RocketMQ==默认采用的是推模式进行消息的消费==，但==实质上其内部对于消息的获取其实是拉模式==，区别在于RocketMQ的==客户端封装了详尽的拉取调用，使得对于终端使用者来说展示出的是推送模式==。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一队列百万消息的堆积能力，亿级消息堆积能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多种消息协议，如 JMS、MQTT 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式高可用的部署架构,满足至少一次消息传递语义&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;原理:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/2838890f3284&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/2838890f3284&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要优势&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持==事务型消息==（消息发送和 DB 操作保持两方的最终一致性，RabbitMQ 和 Kafka 不支持）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持结合 RocketMQ 的多个系统之间==数据最终一致性==（==多方事务==，二方事务是前提）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 18 个级别的==延迟消息==（RabbitMQ 和 Kafka 不支持）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持==指定次数和时间间隔的失败消息重发==（Kafka 不支持，RabbitMQ 需要手动确认）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 ==Consumer 端 Tag 过滤==，减少不必要的网络传输（RabbitMQ 和 Kafka 不支持）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;==支持重复消费==（RabbitMQ 不支持，Kafka 支持）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-运行架构&#34;&gt;2. 运行架构
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个正常工作的RocketMQ包括四个部分。&lt;/p&gt;
&lt;p&gt;NameServer ：基于高可用设计产生的，用于服务发现和路由。正式应用时通常采用集群部署。==就相当于与祖册中心==,  ==NameServer之间没有通信==,   ==broker 需要到 所有的nameServer上去注册==&lt;/p&gt;
&lt;p&gt;Broker：实现==队列机制==，负责消息存储和转发。正式应用时也采用集群部署. 也就是==消息存储中心==, 它还==存储与消息相关的元数据==, Broker 有 Master 和 Slave 两种类型，Master 既可以写又可以读，Slave不可以写只可以读。&lt;/p&gt;
&lt;p&gt;Producer：消息生产者，生成消息并发送到RocketMQ中，生产者通常是我们自己实现的应用程序。&lt;/p&gt;
&lt;p&gt;Consumer：消息消费者，从RocketMQ中接收消息并进行业务处理。这部分也通常是我们自己实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/image-20210604094345170.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20210604094345170&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;运转流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20211211104734307.png&#34;
	width=&#34;737&#34;
	height=&#34;443&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20211211104734307&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;399px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;1. NameServer启动
2. Broker启动向NameServer注册
3. 生产者再发送某个主题的消息前 先从 NameServer 获取Broker服务器地址列表(可能回是集群), 然后根据负载均衡算法, 从列表汇总选择一台Broker 进行消息发送
4. NameServer 与每台broker 服务器保持长链接, 每隔30s 监测是否存活, 如果检测到
Broker 宕机（使用心跳机制， 如果检测超过120S），则从路由注册表中将其移除。
5. 消费者在订阅某个主题的消息之前从 NamerServer 获取 Broker 服务器地址列表（有可能是集群），但是消费者选择从 Broker 中 订阅消息，订阅规则由 Broker 配置决定
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Message -&amp;gt; 要传输的信息&lt;/p&gt;
&lt;p&gt;Topic -&amp;gt; 一条消息必须要有一个Topic, ==可以看做是你的信件要邮寄的地址==&lt;/p&gt;
&lt;p&gt;Tag -&amp;gt; 一条消息也可以拥有一个==可选的标签（Tag）和额外的键值对==，它们可以用于设置&lt;/p&gt;
&lt;p&gt;==一个业务 key 并在 Broker 上查找此消息==以便在开发期间查找问题。&lt;/p&gt;
&lt;h2 id=&#34;3-基础概念&#34;&gt;3. 基础概念
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Producer Group:  只是一个概念性的, 配不配都没有什么影响&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者组：是一类生产者的集合，通常发送同一类消息并且发送逻辑一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Producer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三种消息发送方式&lt;/p&gt;
&lt;p&gt;1: 同步&lt;/p&gt;
&lt;p&gt;2: 异步&lt;/p&gt;
&lt;p&gt;3: 单向发送&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer Group&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者组：是一类消费者的集合，通常消费同一类消息并且消费逻辑一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两种消费模式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拉取型&lt;/li&gt;
&lt;li&gt;推送型: 实际上也是拉取消息, 但是对拉取逻辑进行了封装, 将消息达到时执行的回调接口留给用户来实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker (存储消息);&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)==注册Topic信息到所有Name Server==。Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20240509173328871.png&#34;
	width=&#34;1383&#34;
	height=&#34;794&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240509173328871&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NameServer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作用和zookeeper类似, 用来保存broker相关元素, 并给producer 和comsumer 查找broker 消息, ==Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息==。&lt;/p&gt;
&lt;p&gt;name-server充当==路由消息的提供者==。生产者或消费者能够通过name-server查找各主题相应的 Broker IP 列表。多个 Namesrv 实例组成集群，但相互独立，没有信息交换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;topic 消息主题 (==理解为rebbit 的 exchange==); 可以看做消息的规类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tag  消费标签;  (==理解为 rabbit 的 routing key==)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标签, Topic的二级分类, 可以理解为==消息队列==, ==一个Topic 可以设置多个Tag==, 发送消息时执行该消息的Topic, RockerMq ==会轮询该Topic 下所有的队列将消息发出去==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;message queue 消息队列&amp;ndash;&amp;gt; 主题被划分为一个或多个子主题. 就是消息队列&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Topic 和 Tags 使用示例&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以天猫交易平台为例，订单消息，支付消息属于不同业务类型的消息，分别创建 Topic_Order 和 Topic_Pay，其中订单消息根据商品品类以不同的 Tag 再进行细分，如电器类、男装类、女装类、化妆品类，最后他们都被各个不同的系统所接收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/topic-tags.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;topic-tags&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-windows-开发搭建&#34;&gt;4. windows 开发搭建
&lt;/h2&gt;&lt;h3 id=&#34;1-rocketmq&#34;&gt;1. rocketMq
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zxl646801924/article/details/105637278&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/zxl646801924/article/details/105637278&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意: ==java环境为1.8==&lt;/p&gt;
&lt;p&gt;nameserver 启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start mqnamesrv.cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;broker启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发送消息失败, 空间不足, 修改启动脚本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/muriyue6/article/details/130607492&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/muriyue6/article/details/130607492&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;runbroker.sh文件添加
set &amp;quot;JAVA_OPT=%JAVA_OPT% -server -Xms512m -Xmx512m -Xmn128m -Drocketmq.broker.diskSpaceWarningLevelRatio=0.99&amp;quot;，使磁盘使用超过99%再报错，根本的解决办法是保证磁盘空间永远不超过90%

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证Mq服务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;set NAMESRV_ADDR=127.0.0.1:9876
tools.cmd org.apache.rocketmq.example.quickstart.Consumer
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;启动producer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;set NAMESRV_ADDR=127.0.0.1:9876
tools.cmd org.apache.rocketmq.example.quickstart.Producer
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-rocketmq-dashboard&#34;&gt;2. rocketmq-dashboard
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/rocketmq-dashboard&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/rocketmq-dashboard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;mvn clean package -Dmaven.test.skip=true
java -jar target/rocketmq-dashboard-1.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-检测mq服务是否正常&#34;&gt;5. 检测mq服务是否正常
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; export NAMESRV_ADDR=localhost:9876
&amp;gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer
 SendResult [sendStatus=SEND_OK, msgId= ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下所示官方提供这个例子属于生产者，==用于发送消息，运行之后会发送大量的消息==，之后就会退出&lt;/p&gt;
&lt;p&gt;接收消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer
 ConsumeMessageThread_%d Receive New Messages: [MessageExt...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的消息发送完毕之后就会退出，在同一窗口中可以使用消费者类来进行接收消息, 是多线程的消费&lt;/p&gt;
&lt;h1 id=&#34;2-问题&#34;&gt;2. 问题
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; rocketMq 发送消息的时候, 默认的队列是什么? 不需要单独创建和指定吗?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 默认是四个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; rocketMq dashboard 要如何使用?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; rocketMq 的==消费策略不可以随意更改, 可能会造成重复消费和 队列没有消费者消费==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 为什么?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; rocketMq 的顺序消息是怎么实现的? 顺序消息有几种类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; rocketMq 有哪些消息投递策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-顺序消息&#34;&gt;3. 顺序消息
&lt;/h1&gt;&lt;h2 id=&#34;1-概念总结&#34;&gt;1. 概念总结
&lt;/h2&gt;&lt;p&gt;==rocketMq  里面的局部顺序, 依靠的是broker-queue 中的分段锁实现的, queue 中的消息一定是先入先出的==&lt;/p&gt;
&lt;p&gt;局部顺序有一个很关键的点，在==一个消费者集群的情况下==&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消费者1先去Queue拿消息，它拿到了北京订单1，它拿完后，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者2去queue拿到的是 北京订单2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拿的顺序是没毛病了，==但关键是先拿到不代表先消费完它==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会存在虽然你消费者1先拿到北京订单 但由于网络等原因，消费者2比你真正的先消费消息。这是不是很尴尬了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;实际上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;==Broker采用的是分段锁，它不是锁整个Broker而是锁里面的单个Queue==，因为只要锁单个 Queue就可以保证局部顺序消费了。&lt;/p&gt;
&lt;p&gt;所以最终的消费者这边的逻辑就是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消费者1去Queue拿 北京订单1，==它就锁住了整个Queue，只有它消费完成并返回成功后，这个锁才会释放==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后下一个消费者去拿到 北京订单2 同样锁住当前Queue,这样的一个过程来真正保证对同一个 Queue能够真正意义上的顺序消费，而不仅仅是顺序取出&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序消息暂不支持广播模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序消息不支持异步发送方式，否则将无法严格保证顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;==建议同一个 Group ID 只对应一种类型的 Topic，即不同时用于顺序消息和无序消息的收发==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于全局顺序消息，建议创建broker个数 &amp;gt;=2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-使用&#34;&gt;2. 使用
&lt;/h2&gt;&lt;h3 id=&#34;1-队列选择器&#34;&gt;1. 队列选择器
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SelectorFactory {
    /**
    * 工厂模式获取MessageQueueSelector
    *
    * @param value
    * @return
    */
	public static MessageQueueSelector getMessageQueueSelector(String value) {
        //如果value不为空使用hash选择器
        if (StringUtils.isNotEmpty(value)) {
        return new SelectMessageQueueByHash();
        }
        //如果value为空使用随机选择器
        return new SelectMessageQueueByRandom();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-消息生产者&#34;&gt;2. 消息生产者
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class MQProducer {

    @Autowired
    DefaultMQProducer defaultMQProducer;

    /**
     * 同步发送消息
     *
     * @param taxiBO
     */
    public void send(TaxiBO taxiBO) {
        if (null == taxiBO) {
            return;
        }
        SendResult sendResult = null;
        try {
//获取消息对象
            Message message =
                    RocketMQHelper.buildMessage(DispatchConstant.SEQ_TOPIC, taxiBO);
//根据区域编码获取队列选择器
            MessageQueueSelector selector =
                    SelectorFactory.getMessageQueueSelector(taxiBO.getAreaCode());
//发送同步消息
            sendResult = defaultMQProducer.send(message, selector,
                    taxiBO.getAreaCode(), 10000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (null != sendResult) {
            System.out.println(sendResult.toString());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-消息投递策略&#34;&gt;4. 消息投递策略
&lt;/h1&gt;&lt;p&gt;==一个队列只能被一个消费者订阅 (可以保证不被重复消费), 一个消费者可以订阅多个队列==&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群消费 clustering (默认); 就是分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被
一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;广播消费 broadcasting&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;发给消费者组中的每一个消费者进行消费
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;==commitlog 有文件过期时间, 默认是72小时, 当超过这个时间文件没有任何没有更新的话, 文件会被删除, 无法找回==&lt;/p&gt;
&lt;p&gt;==超过超时时间, 消息发送失败的, 是不会进行重试的==&lt;/p&gt;
&lt;p&gt;==集群部署需要禁止自动创建主题==&lt;/p&gt;
&lt;p&gt;消息重试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rabbitMq 是会回到队列的头部, 重新发送&lt;/li&gt;
&lt;li&gt;rocketMq 则是会新开一个新的队列, 已当前消费组为单位, 与具体的主题无关, 不会立马重试, 大概5小时内,默认会重试16次,  如果全部失败的话就会到死信队列里面&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-生产者投递策略&#34;&gt;1. 生产者投递策略
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;轮询投递&lt;/li&gt;
&lt;li&gt;顺序投递&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RockeMQ 采用了这种实现方案：&lt;strong&gt;对于相同订单号的消息，通过一定的策略，将其&lt;/strong&gt; 放置在一个queue队列中 &lt;strong&gt;，然后&lt;/strong&gt; 消费者 再采用一定的策略(一个线程独立处理一个queue ,保证处理消息的顺序性)，能够保证消费的顺序性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.apache.rocketmq.client.producer;

import java.util.List;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageQueue;

public interface MessageQueueSelector {
    MessageQueue select(List&amp;lt;MessageQueue&amp;gt; var1, Message var2, Object var3);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;投递策略&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;策略实现类&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;随机分配策略&lt;/td&gt;
          &lt;td&gt;SelectMessageQueueByRandom&lt;/td&gt;
          &lt;td&gt;使用了简单的随机数选择算法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;基于Hash分配&lt;/td&gt;
          &lt;td&gt;SelectMessageQueueByHash&lt;/td&gt;
          &lt;td&gt;根据附加参数的Hash值，按照消&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-消费者分配队列&#34;&gt;2. 消费者分配队列
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;BROADCASTING :广播式消费，这种模式下，一个消息会被通知到每一个 消费者&lt;/li&gt;
&lt;li&gt;CLUSTERING : 集群式消费，这种模式下，一个消息最多只会被投递到一个 消费者 上进行消费&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;平局分配算法, 并不是指的严格意义上的完全平均，如上面的例子中，==10个queue，而 消费者只有4个==，无法是整除关系，除了整除之外的==多出来的queue,将依次根据消费者的顺序均摊==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性hash分配算法, 会将 consumer消费者 作为Node节点构造成一个hash环，然后 queue队列 通过这个&lt;/p&gt;
&lt;p&gt;hash环来决定被分配给哪个 consumer消费者 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认消费者使用使用了 AllocateMessageQueueAveragely 平均分配策略&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//创建一个消息消费者，并设置一个消息消费者组，并指定使用一致性hash算法的分配策略
DefaultMQPushConsumer consumer = new
DefaultMQPushConsumer(null,&amp;quot;rocket_test_consumer_group&amp;quot;,null,new
AllocateMessageQueueConsistentHash());
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5--rocketmq-消息存储&#34;&gt;5.  rocketMq 消息存储
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;CommitLog：这是消息存储的核心文件，所有的消息都先写入 CommitLog。它是一个顺序写的日志文件，写入性能高。&lt;/li&gt;
&lt;li&gt;ConsumeQueue：这是消息的逻辑队列，存储了消息在 CommitLog 中的物理偏移量、消息大小和消息的 Tag 哈希值。每个 Topic 下的每个队列都有一个对应的 ConsumeQueue。&lt;/li&gt;
&lt;li&gt;IndexFile：这是消息的索引文件，存储了消息的索引信息，可以通过消息的 Key 快速查找消息。
这些文件都存储在磁盘上，&lt;/li&gt;
&lt;li&gt;Broker 会定期进行刷盘操作，将内存中的数据写入磁盘，保证消息的持久性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-消息保障&#34;&gt;6. 消息保障
&lt;/h1&gt;&lt;h2 id=&#34;1-生产端保障&#34;&gt;1. 生产端保障
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用可靠的消息发送方式,    同步发送比异步发送可靠,  ==两者都可以对消息的响应结果做处理==, 只有one-way(单向模式) 的时候才会不需要处理, 而且==只有同步发送才有重试==, ==并且超时是不会进行重试的==&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意生产端重试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生产禁止自动创建topic&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发送重试源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
     * 说明 抽取部分代码
     */
    private SendResult sendDefaultImpl(Message msg, final CommunicationMode
            communicationMode, final SendCallback sendCallback, final long timeout) {
//1、获取当前时间
        long beginTimestampFirst = System.currentTimeMillis();
        long beginTimestampPrev ;
//2、去服务器看下有没有主题消息
        TopicPublishInfo topicPublishInfo =
                this.tryToFindTopicPublishInfo(msg.getTopic());
        if (topicPublishInfo != null &amp;amp;&amp;amp; topicPublishInfo.ok()) {
            boolean callTimeout = false;
//3、通过这里可以很明显看出 如果不是同步发送消息 那么消息重试只有1次
            int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 +
                    this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;
//4、根据设置的重试次数，循环再去获取服务器主题消息
            for (times = 0; times &amp;lt; timesTotal; times++) {
                MessageQueue mqSelected =
                        this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
                beginTimestampPrev = System.currentTimeMillis();
                long costTime = beginTimestampPrev - beginTimestampFirst;
//5、前后时间对比 如果前后时间差 大于 设置的等待时间 那么直接跳出for循环了 这就
                说明连接超时是不进行多次连接重试的
                if (timeout &amp;lt; costTime) {
                    callTimeout = true;
                    break
                }
//6、如果超时直接报错
                if (callTimeout) {
                    throw new RemotingTooMuchRequestException(&amp;quot;sendDefaultImpl call
                            timeout&amp;quot;);
                }
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;==自动创建topic==&lt;/p&gt;
&lt;p&gt;autoCreateTopicEnable 设置为true 标识开启自动创建topic&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息发送时如果根据topic没有获取到 路由信息，则会根据默认的topic去获取，获取到路由信息后&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择一个队列进行发送，发送时报文会带上默认的topic以及默认的队列数量。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;消息到达broker后，broker检测没有topic的路由信息，则查找默认topic的路由信息，查到表示开&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;启了自动创建topic，则会根据消息内容中的默认的队列数量在本broker上创建topic，然后进行消&lt;/p&gt;
&lt;p&gt;息存储。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;broker创建topic后并不会马上同步给namesrv&lt;/strong&gt;，而是每30进行汇报一次，更新namesrv上的 topic路由信息，producer会每30s进行拉取一次topic的路由信息，更新完成后就可以正常发送消 息。更新之前一直都是按照默认的topic查找路由信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-消费端保障&#34;&gt;2. 消费端保障
&lt;/h2&gt;&lt;h3 id=&#34;1-消息确认&#34;&gt;1. 消息确认
&lt;/h3&gt;&lt;p&gt;业务实现消费回调的时候，当且仅当此回调函数返回 ==ConsumeConcurrentlyStatus.CONSUME_SUCCESS== ，RocketMQ才会认为这批消息（默认是1 条）是消费完成的。&lt;/p&gt;
&lt;h3 id=&#34;2-消费异常&#34;&gt;2. &lt;strong&gt;消费异常&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;数据库异常，余额不足扣款失败等一切业务认为消息需要重试的场 景，只要返回 ==ConsumeConcurrentlyStatus.RECONSUME_LATER== ，RocketMQ就会认为这批消息 消费失败了。&lt;/p&gt;
&lt;p&gt;为了保证消息是肯定被至少消费成功一次，RocketMQ会把这批消息重发回Broker（==topic不是原 topic而是这个消费租的RETRY topic==），在延迟的某个时间点（默认是10秒，业务可设置）后，==再次投 递到这个ConsumerGroup==。而如果一直这样重复消费都持续失败到一定次数（默认16次），就会==投递 到DLQ死信队列==。应用可以监控死信队列来做人工干预。&lt;/p&gt;
&lt;h2 id=&#34;3-死信队列&#34;&gt;3. 死信队列
&lt;/h2&gt;&lt;p&gt;当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；&lt;/p&gt;
&lt;p&gt;达到最大重试次 数后，若 消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，&lt;/p&gt;
&lt;p&gt;此时，消息队列 RocketMQ 不会立 刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。 在消息队列 RocketMQ 中，这种正常情况 下无法被消费的消息称为死信消息，存储死信消息的特殊队列称为死信队列&lt;/p&gt;
&lt;p&gt;==不会再被消费者正常消费==&lt;/p&gt;
&lt;p&gt;有效期与正常消息相同，均为 3 天，3 天后会被自动删除。故死信消息应在产生的 3 天内及时处理&lt;/p&gt;
&lt;p&gt;==一个死信队列对应一个消费者组，而不是对应单个消费者实例==&lt;/p&gt;
&lt;p&gt;一个死信队列包含了对应的 ==Group ID所产生的所有死信消息，不论该消息属于哪个Topic若一个 Group ID 没有产生过死信消息，则 RocketMQ 不会为其创建相应的死信队列==&lt;/p&gt;
&lt;h1 id=&#34;7-应用&#34;&gt;7. 应用
&lt;/h1&gt;&lt;h2 id=&#34;1-spring-cloud-stream-整合&#34;&gt;1. spring cloud stream 整合
&lt;/h2&gt;&lt;p&gt;以统一的一套API来进行消息的发送和消费, 底层消息中间件的实现细节由各消息中间件的 binder 完成&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/7f8fd90564ca?utm_campaign=hugo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/7f8fd90564ca?utm_campaign=hugo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gitee: &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/jbcode/GitRepository.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/jbcode/GitRepository.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-依赖&#34;&gt;1. 依赖
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;

    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.erbadagang.springcloud.stream&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sc-stream-rocketmq-producer&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;spring.boot.version&amp;gt;2.2.4.RELEASE&amp;lt;/spring.boot.version&amp;gt;
        &amp;lt;spring.cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring.cloud.version&amp;gt;
        &amp;lt;spring.cloud.alibaba.version&amp;gt;2.2.0.RELEASE&amp;lt;/spring.cloud.alibaba.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!--
        引入 Spring Boot、Spring Cloud、Spring Cloud Alibaba 三者 BOM 文件，进行依赖版本的管理，防止不兼容。
        在 https://dwz.cn/mcLIfNKt 文章中，Spring Cloud Alibaba 开发团队推荐了三者的依赖关系
     --&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.cloud.alibaba.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- 引入 SpringMVC 相关依赖，并实现对其的自动配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 引入 Spring Cloud Alibaba Stream RocketMQ 相关依赖，将 RocketMQ 作为消息队列，并实现对其的自动配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rocketmq&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-生产端配置文件&#34;&gt;2. 生产端配置文件
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  application:
    name: stream-rocketmq-producer-application
  cloud:
    # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类
    stream:
      # Binding 配置项，对应 BindingProperties Map
      bindings:
        erbadagang-output:
          destination: ERBADAGANG-TOPIC-01 # 目的地。这里使用 RocketMQ Topic
          content-type: application/json # 内容格式。这里使用 JSON

        trek-output:
          destination: TREK-TOPIC-01 # 目的地。这里使用 RocketMQ Topic
          content-type: application/json # 内容格式。这里使用 JSON
      # Spring Cloud Stream RocketMQ 配置项
      rocketmq:
        # RocketMQ Binder 配置项，对应 RocketMQBinderConfigurationProperties 类
        binder:
          name-server: 101.133.227.13:9876 # RocketMQ Namesrv 地址
        # RocketMQ 自定义 Binding 配置项，对应 RocketMQBindingProperties Map
        bindings:
          erbadagang-output:
            # RocketMQ Producer 配置项，对应 RocketMQProducerProperties 类
            producer:
              group: test # 生产者分组
              sync: true # 是否同步发送消息，默认为 false 异步。

server:
  port: 18080

# 同时我们设置了2个binding，模拟2个topic情形。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3--消费端配置文件&#34;&gt;3.  消费端配置文件
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  application:
    name: erbadagang-consumer-application
  cloud:
    # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类
    stream:
      # Binding 配置项，对应 BindingProperties Map
      bindings:
        erbadagang-input:
          destination: ERBADAGANG-TOPIC-01 # 目的地。这里使用 RocketMQ Topic
          content-type: application/json # 内容格式。这里使用 JSON
          group: erbadagang-consumer-group-ERBADAGANG-TOPIC-01 # 消费者分组,命名规则：组名+topic名

        trek-input:
          destination: TREK-TOPIC-01 # 目的地。这里使用 RocketMQ Topic
          content-type: application/json # 内容格式。这里使用 JSON
          group: trek-consumer-group-TREK-TOPIC-01 # 消费者分组,命名规则：组名+topic名
      # Spring Cloud Stream RocketMQ 配置项
      rocketmq:
        # RocketMQ Binder 配置项，对应 RocketMQBinderConfigurationProperties 类
        binder:
          name-server: 101.133.227.13:9876 # RocketMQ Namesrv 地址
        # RocketMQ 自定义 Binding 配置项，对应 RocketMQBindingProperties Map
        bindings:
          erbadagang-input:
            # RocketMQ Consumer 配置项，对应 RocketMQConsumerProperties 类
            consumer:
              enabled: true # 是否开启消费，默认为 true
              broadcasting: false # 是否使用广播消费，默认为 false 使用集群消费，如果要使用广播消费值设成true。

server:
  port: ${random.int[10000,19999]} # 随机端口，方便启动多个消费者
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;发送消息 @OutPut&lt;/li&gt;
&lt;li&gt;接受消息 @ Input&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-springboot-集成-rocketmq&#34;&gt;2. springboot 集成 rocketMq
&lt;/h2&gt;&lt;h3 id=&#34;1-知识点-泛型方法&#34;&gt;1. 知识点: 泛型方法
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static &amp;lt;T&amp;gt; void getConsumer() {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zxl646801924/article/details/105659481&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/zxl646801924/article/details/105659481&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-rocketmq-spring-boot-starter&#34;&gt;2. rocketmq-spring-boot-starter
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/m0_37968982/article/details/109066088&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/m0_37968982/article/details/109066088&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1-引入依赖&#34;&gt;1. 引入依赖
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rocketmq-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-配置rocketmq&#34;&gt;2. 配置rocketMq
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;rocketmq:
  name-server: 127.0.0.1:9876
  producer:
    group: my-producer-group
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-构建生产者&#34;&gt;3. 构建生产者
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class Producer {

    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    @GetMapping(&amp;quot;send&amp;quot;)
    public void send(){

        rocketMQTemplate.convertAndSend(&amp;quot;first-topic&amp;quot;,&amp;quot;你好,Java旅途&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-消费者&#34;&gt;4. 消费者
&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;@Component
@RocketMQMessageListener(topic = &amp;quot;first-topic&amp;quot;,consumerGroup = &amp;quot;my-consumer-group&amp;quot;)
@Slf4j
public class Consumer implements RocketMQListener&amp;lt;String&amp;gt; {

    @Override
    public void onMessage(String message) {
        log.info(&amp;quot;我收到消息了！消息内容为：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-打车服务&#34;&gt;3. 打车服务
&lt;/h2&gt;&lt;h3 id=&#34;1-车辆调度&#34;&gt;1. 车辆调度
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20240612163426938.png&#34;
	width=&#34;1187&#34;
	height=&#34;748&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240612163426938&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-司机自动接单&#34;&gt;2. 司机自动接单
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20240612163538833.png&#34;
	width=&#34;1220&#34;
	height=&#34;493&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240612163538833&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;247&#34;
		data-flex-basis=&#34;593px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-用户下车&#34;&gt;3. 用户下车
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20240612163602860.png&#34;
	width=&#34;1168&#34;
	height=&#34;763&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240612163602860&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;367px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-总体流程&#34;&gt;4. 总体流程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20240612163932221.png&#34;
	width=&#34;1212&#34;
	height=&#34;730&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240612163932221&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;398px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;4--rocketmqpushconsumerlifecyclelistener-接口&#34;&gt;4.  RocketMQPushConsumerLifecycleListener 接口
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;RocketMQPushConsumerLifecycleListener&lt;/code&gt; 是一个用于管理 RocketMQ 推送消费者生命周期的接口。实现这个接口的类可以在==消费者启动前和启动后执行一些自定义逻辑==。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyConsumerLifecycleListener implements RocketMQPushConsumerLifecycleListener {

    @Override
    public void prepareStart(DefaultMQPushConsumer consumer) {
        // 在消费者启动前执行一些初始化操作
        consumer.setConsumeThreadMax(10); // 设置最大消费线程数
        System.out.println(&amp;quot;Consumer is about to start.&amp;quot;);
    }

    @Override
    public void prepareShutdown(DefaultMQPushConsumer consumer) {
        // 在消费者关闭前执行一些清理操作
        System.out.println(&amp;quot;Consumer is about to shut down.&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8--任务&#34;&gt;8.  任务
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;del&gt;复习文档&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;整理面试题&lt;/li&gt;
&lt;li&gt;查看代码使用&lt;/li&gt;
&lt;li&gt;&lt;del&gt;复述 rocket 打车&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;搭建一个本机的 rocketMq&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;kafka 进行学习&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;9-rocketmq-的事务消息&#34;&gt;9. RocketMq 的事务消息
&lt;/h1&gt;&lt;p&gt;面试官：什么是RocketMQ的事务消息&lt;/p&gt;
&lt;p&gt;事务消息就是MQ提供的类似XA的分布式事务能力，通过事务消息可以达到分布式事务的最终一致性。&lt;/p&gt;
&lt;p&gt;半事务消息就是MQ收到了生产者的消息，但是没有收到二次确认，不能投递的消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1&lt;/strong&gt; &lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生产者先发送一条半事务消息到MQ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MQ收到消息后返回ack确认&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生产者开始执行本地事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果事务执行成功发送commit到MQ，失败发送rollback&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果MQ长时间未收到生产者的二次确认commit或者rollback，MQ对生产者发起消息回查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生产者查询事务执行最终状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据查询事务状态再次提交二次确认&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终，如果MQ收到二次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在==3天后被删除==。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mikeLing-qx.github.io/p/rocketmq/images/image-20220217104845523.png&#34;
	width=&#34;713&#34;
	height=&#34;289&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220217104845523&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;246&#34;
		data-flex-basis=&#34;592px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;10-消费者闲置&#34;&gt;10. 消费者闲置
&lt;/h1&gt;&lt;p&gt;在使用 RocketMQ 时，如果存在多个消费者，但某些消费者闲置不接收消息&lt;/p&gt;
&lt;p&gt;消费者分组在 RocketMQ 中起着重要作用。一个消费者分组中的所有消费者共同消费主题中的消息。消息队列（queue）会在同一个分组的消费者之间均匀分配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消费者分组内部的消费者不均衡&lt;/strong&gt;：==如果消费者数量大于消息队列的数量==，则多出的消费者会闲置。例如，如果一个主题有4个消息队列，但有5个消费者在同一个分组内，那么多出的一个消费者将不会分配到任何队列，从而闲置。&lt;/li&gt;
&lt;li&gt;==类似于kafka 中的分区数量少于 消费者数量==&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
