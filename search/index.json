[{"content":"1. 概述 常见lamda 函数式接口:\n1 2 3 4 5 6 runAsync：异步执行没有返回值； supplyAsync：异步执行有返回值； thenApply：继续执行当前线程future完成的函数，不需要阻塞等待其处理完成； thenApplyAsync：在不同线程池异步地应用参数中的函数； thenCompose：用于多个彼此依赖的futrue进行串联起来, 串行 thenCombine：并联起两个独立的future，注意，这些future都是在长时间计算都完成以后, 并行关系 每个变种函数的第三个方法也许会发现里面都有一个 ==Executor 类型的参数==，用于指定线程池\n如果没有指定线程池，那自然就会有一个默认的线程池，也就是 ForkJoinPool\nForkJoinPool 的线程数默认是==CPU 的核心数==\n不要所有业务共用一个线程池，因为，一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成线程饥饿，进而影响整个系统的性能\nJdk9 升级内容\n添加了新的工厂方法\n支持延迟和超时处理\n1 2 orTimeout() completeOnTimeout() 2. 类结构 1. Future 实现了 Future 接口，那就具有 Future 接口的相关特性，请脑补 Future 那少的可怜的 5 个方法，这里不再赘述，具体请查看 不会用Java Future，我怀疑你泡茶没我快\n2. CompletionStage CompletionStage 这个接口还是挺陌生的，中文直译过来是【竣工阶段】，如果将烧水泡茶比喻成一项大工程，他们的竣工阶段体现是不一样的\n3. 线程关系 单看线程1 或单看线程 2 就是一种串行关系，做完一步之后做下一步 一起看线程1 和 线程 2，它们彼此就是并行关系，两个线程做的事彼此独立互补干扰 泡茶就是线程1 和 线程 2 的汇总/组合，也就是线程 1 和 线程 2 都完成之后才能到这个阶段（当然也存在线程1 或 线程 2 任意一个线程竣工就可以开启下一阶段的场景） CompletionStage 所有函数都是用于描述任务的时序关系\n4. CompleteableFutute 方法总览 0. 常用api 概述 参考资料: https://blog.51cto.com/zhangzhixi/5626288\n==提交任务==：\nsupplyAsync 需要返回值时使用\nrunAsync\n==接力处理==：\nthenRun thenRunAsync\nthenAccept thenAcceptAsync\nthenApply thenApplyAsync\nhandle handleAsync\napplyToEither applyToEitherAsync\nacceptEither acceptEitherAsync\nrunAfterEither runAfterEitherAsync\nthenCombine thenCombineAsync\nthenAcceptBoth thenAcceptBothAsync\n==获取结果==：\njoin 阻塞等待，不会抛异常 get 阻塞等待，会抛异常 complete(T value) 不阻塞，如果任务已完成，返回处理结果。如果没完成，则返回传参value。 ==总结分类==\n带run的方法，无入参，无返回值。 带accept的方法，有入参，无返回值。 带supply的方法，无入参，有返回值。 带apply的方法，有入参，有返回值。 带handle的方法，有入参，有返回值，并且带异常处理。 以Async结尾的方法，都是异步的，否则是同步的。 以Either结尾的方法，只需完成任意一个。 以Both/Combine结尾的方法，必须所有都完成 completeExceptionally(Throwable ex) 不阻塞，如果任务已完成，返回处理结果。如果没完成，抛异常。\n1. 串行关系 then 直译【然后】，也就是表示下一步，所以通常是一种串行关系体现, then 后面的单词（比如 run /apply/accept）就是上面说的函数式接口中的抽象方法名称了，它的作用和那几个函数式接口的作用是一样一样滴\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // run 是没有返回值的 CompletableFuture\u0026lt;Void\u0026gt; thenRun(Runnable action) CompletableFuture\u0026lt;Void\u0026gt; thenRunAsync(Runnable action) CompletableFuture\u0026lt;Void\u0026gt; thenRunAsync(Runnable action, Executor executor) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApply(Function\u0026lt;? super T,? extends U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync(Function\u0026lt;? super T,? extends U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync(Function\u0026lt;? super T,? extends U\u0026gt; fn, Executor executor) CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;? super T\u0026gt; action) CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action) CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action, Executor executor) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenCompose(Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenComposeAsync(Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenComposeAsync(Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn, Executor executor) 2. 聚合关系 and combine... with... 和 both...and... 都是要求两者都满足，也就是 and 的关系了\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombine(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn) \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombineAsync(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn) \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombineAsync(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn, Executor executor) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBoth(CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBothAsync(CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBothAsync( CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action, Executor executor) CompletableFuture\u0026lt;Void\u0026gt; runAfterBoth(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) CompletableFuture\u0026lt;Void\u0026gt; runAfterBothAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) CompletableFuture\u0026lt;Void\u0026gt; runAfterBothAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action, Executor executor) 3. or或 关系 Either...or... 表示两者中的一个，自然也就是 Or 的体现了\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; applyToEither(CompletionStage\u0026lt;? extends T\u0026gt; other, Function\u0026lt;? super T, U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; applyToEitherAsync(、CompletionStage\u0026lt;? extends T\u0026gt; other, Function\u0026lt;? super T, U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; applyToEitherAsync(CompletionStage\u0026lt;? extends T\u0026gt; other, Function\u0026lt;? super T, U\u0026gt; fn, Executor executor) CompletableFuture\u0026lt;Void\u0026gt; acceptEither(CompletionStage\u0026lt;? extends T\u0026gt; other, Consumer\u0026lt;? super T\u0026gt; action) CompletableFuture\u0026lt;Void\u0026gt; acceptEitherAsync(CompletionStage\u0026lt;? extends T\u0026gt; other, Consumer\u0026lt;? super T\u0026gt; action) CompletableFuture\u0026lt;Void\u0026gt; acceptEitherAsync(CompletionStage\u0026lt;? extends T\u0026gt; other, Consumer\u0026lt;? super T\u0026gt; action, Executor executor) CompletableFuture\u0026lt;Void\u0026gt; runAfterEither(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) CompletableFuture\u0026lt;Void\u0026gt; runAfterEitherAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) CompletableFuture\u0026lt;Void\u0026gt; runAfterEitherAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action, Executor executor) 4. 异常处理 1 2 3 4 5 6 7 8 9 10 11 12 CompletableFuture\u0026lt;T\u0026gt; exceptionally(Function\u0026lt;Throwable, ? extends T\u0026gt; fn) CompletableFuture\u0026lt;T\u0026gt; exceptionallyAsync(Function\u0026lt;Throwable, ? extends T\u0026gt; fn) CompletableFuture\u0026lt;T\u0026gt; exceptionallyAsync(Function\u0026lt;Throwable, ? extends T\u0026gt; fn, Executor executor) CompletableFuture\u0026lt;T\u0026gt; whenComplete(BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) CompletableFuture\u0026lt;T\u0026gt; whenCompleteAsync(BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) CompletableFuture\u0026lt;T\u0026gt; whenCompleteAsync(BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action, Executor executor) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handle(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn, Executor executor) ==exceptionally 和 whenComplete, handle 的区别==\n5. 性能 任务巨多, 如何保证性能 如何观察任务的调度情况 (存在线程复用的情况) 可以使用线程池. 设置核心线程数为0, 线程存活时间为0, 保证每个任务都在新线程上执行 ​\n","date":"2024-12-31T18:04:23+08:00","permalink":"https://mikeLing-qx.github.io/p/thread/","title":"Thread"},{"content":"1. wsl安装k3s 遇到问题\n7. service Kubernetes service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 ——\n通常称为微服务。这一组 pod 能够被 Service 访问到，通常是通过 Label selector\nService 资源基于标签选择器将一组 Pod 定义成一个逻辑组合，并通过自己的 IP 地址和端口调度代理请求至组内的 Pod 对象之上，如下图所示，它向客户端隐藏了真实的、处理用户请求的 Pod 资源， 使得客户端的请求看上去就像是由 Service 直接处理并响应一样。 service 的 ip 也被称作为 cluster-ip\n","date":"2024-12-31T17:01:24+08:00","permalink":"https://mikeLing-qx.github.io/p/image-test/","title":"Image Test"},{"content":"Spring相关教程/资料 官网相关 Spring官网、Spring系列主要项目、Spring官网指南、官方文档 spring-framework-reference Spring Framework 4.3.17.RELEASE API 系统学习教程 文档 极客学院Spring Wiki Spring W3Cschool教程 视频 网易云课堂——58集精通java教程Spring框架开发\n慕课网相关视频\n黑马视频和尚硅谷视频（非常推荐）： 微信公众号：“JavaGuide”后台回复关键字 “1” 免费领取。\n面试必备知识点 SpringAOP,IOC实现原理 AOP实现原理、动态代理和静态代理、Spring IOC的初始化过程、IOC原理、自己实现怎么实现一个IOC容器？这些东西都是经常会被问到的。\n推荐阅读：\n自己动手实现的 Spring IOC 和 AOP - 上篇\n自己动手实现的 Spring IOC 和 AOP - 下篇\nAOP AOP思想的实现一般都是基于 代理模式 ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。\n如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类； 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。 推荐阅读：\n静态代理、JDK动态代理、CGLIB动态代理讲解 ：我们知道AOP思想的实现一般都是基于 代理模式 ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。 Spring AOP 入门 ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理， Spring AOP 基于AspectJ注解如何实现AOP ： AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器），可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。 探秘Spring AOP（慕课网视频，很不错）:慕课网视频，讲解的很不错，详细且深入 spring源码剖析（六）AOP实现原理剖析 :通过源码分析Spring AOP的原理 IOC [Spring框架]Spring IOC的原理及详解。 Spring IOC核心源码学习 :比较简短，推荐阅读。 Spring IOC 容器源码分析 :强烈推荐，内容详尽，而且便于阅读。 Bean初始化过程 Spring事务管理 可能是最漂亮的Spring事务管理详解 Spring编程式和声明式事务实例讲解 Spring单例与线程安全 Spring框架中的单例模式（源码解读）:单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例。spring依赖注入时，使用了 多重判断加锁 的单例模式。 Spring源码阅读 阅读源码不仅可以加深我们对Spring设计思想的理解，提高自己的编码水平，还可以让自己在面试中如鱼得水。下面的是Github上的一个开源的Spring源码阅读，大家有时间可以看一下，当然你如果有时间也可以自己慢慢研究源码。\nspring-core spring-aop spring-context spring-task spring-transaction spring-mvc guava-cache ","date":"2024-12-31T16:42:10+08:00","permalink":"https://mikeLing-qx.github.io/p/spring/","title":"Spring"}]