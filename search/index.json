[{"content":"1. wsl安装k3s 遇到问题\n[System has not been booted with systemd as init system (PID 1). Can\u0026rsquo;t operate]\n参考资料\nhttps://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate\nKubernetes介绍：https://www.cnblogs.com/weicunqi/p/14892207.html 资源管理：https://www.cnblogs.com/weicunqi/p/14894122.html 实战入门：https://www.cnblogs.com/weicunqi/p/14894249.html\n2. minikube window安装 1 2 3 4 5 6 7 New-Item -Path \u0026#39;c:\\\u0026#39; -Name \u0026#39;minikube\u0026#39; -ItemType Directory -Force Invoke-WebRequest -OutFile \u0026#39;c:\\minikube\\minikube.exe\u0026#39; -Uri \u0026#39;https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe\u0026#39; -UseBasicParsing $oldPath = [Environment]::GetEnvironmentVariable(\u0026#39;Path\u0026#39;, [EnvironmentVariableTarget]::Machine) if ($oldPath.Split(\u0026#39;;\u0026#39;) -inotcontains \u0026#39;C:\\minikube\u0026#39;){ [Environment]::SetEnvironmentVariable(\u0026#39;Path\u0026#39;, $(\u0026#39;{0};C:\\minikube\u0026#39; -f $oldPath), [EnvironmentVariableTarget]::Machine) } 控制台\n1 minikube dashboard 测试pod\n1 2 3 4 5 6 7 8 kubectl create deployment hello-minikube --image=kicbase/echo-server:1.0 kubectl expose deployment hello-minikube --type=NodePort --port=8080 kubectl get services hello-minikube minikube service hello-minikube kubectl port-forward service/hello-minikube 7080:8080 3. kube 命令 nginx-pod\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.12 ports: - containerPort: 80 副本数量\n==spec.replicas==是可以选字段，指定期望的pod数量，默认是1。\n==.spec.selector==是可选字段，用来==指定 label selector ，圈定Deployment管理的pod范围==。如果被\n指定， .spec.selector 必须匹配 .spec.template.metadata.labels，否则它将被API拒绝。如果\n.spec.selector 没有被指定， .spec.selector.matchLabels 默认是.spec.template.metadata.labels。\n==在Pod的template跟.spec.template不同或者数量超过了.spec.replicas规定的数量的情况下, Deployment会杀掉label跟selector不同的Pod==\nPod模板，.spec.template 是 .spec中唯一要求的字段\n.spec.template.spec.restartPolicy 可以设置为 Always , 如果不指定的话这就是默认配置。\n创建pod 1 2 kubectl get pods -o wide -w kubectl apply -f nginx-pod.yml 删除pod 1 2 3 4 5 kubectl delete pod nginx-deployment-f77774fc5-cgs82 # 查看Pod详情 kubectl get pods -o wide 它会重新拉起来 查看创建过程 1 kubectl describe pod nginx-deployment 查看pod 的详细信息 1 kubectl describe pod nginx 4. pod 0. 特点 ​\tPod中封装着应用的容器（有的情况下是好几个容器），==存储、独立的网络IP==，管理容器如何运行\n的策略选项。Pod代表着部署的一个单位：kubernetes中应用的一个实例，可能由一个或者多个容器组\n合在一起共享资源。\n==网络==\n==每一个Pod都会被指派一个唯一的Ip地址==，在Pod中的==每一个容器共享网络命名空间==，包括==Ip地址和 网络端口。在同一个Pod中的容器可以同locahost进行互相通信==。当Pod中的容器需要与Pod外的实体进 行通信时，则需要通过端口等共享的网络资源。\n==存储==\nPod能够被指定共享存储卷的集合，在Pod中所有的容器能够访问共享存储卷，允许这些容器共享 数据。存储卷也允许在一个Pod持久化数据，以防止其中的容器需要被重启。\n1. 镜像拉取策略 pod的镜像拉取策略分为三种：\nalways（总是从官方下载镜像）\nnever（从不下载镜像）\nifnotpresent（如果本地没有镜像就从官方下载镜像）。\n2. 生命周期行为 1. 初始化容器（ init container ） 即应用程序的主容器启动之前要运行的容器，常用于为主容器 执行一些预置操作，它们具有两种典型特征。\n初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么 kubernetes 需要重启它直到 成功完成。（注意：如果 pod 的 spec.restartPolicy 字段值为“ Never ”，那么运行失败的初始化 容器不会被重启。）\n每个初始化容器都==必须按定义的顺序串行运行==。\n2. 容器探测 容器探测（ container probe ）是 Pod 对象生命周期中的一项重要的日常任务，它是 kubelet 对\n容器周期性执行的健康状态诊断，诊断操作由容器的处理器（ handler ）进行定义。\nKubernetes 支持三种处理器用于 Pod 探测：\nExecAction ：在容器内执行指定命令，并根据其返回的状态码进行诊断的操作称为 Exec 探测， 状态码为 0 表示成功，否则即为不健康状态。\nTCPSocketAction ：通过与容器的某 TCP 端口尝试建立连接进行诊断，端口能够成功打开即为正 常，否则为不健康状态。\nHTTPGetAction ：通过向容器 IP 地址的某指定端口的指定 path 发起 HTTP GET 请求进行诊断， 响应码为 2xx 或 3xx 时即为成功，否则为失败。\n任何一种探测方式都可能存在三种结果： “Success”（成功） 、 “Failure”（失败） 、 “Unknown”\n（未知） ，只有 success 表示成功通过检测。\n3. 健康检查 存活探测 ==应用是否活着== 就绪探测 ==用是否准备好为请求提供服务== Liveness探测和Readiness探测是两种Health Check机制,如果不特意配置,Kubernetes将对两种探 测采取相同的默认行为,即通过判断容器启动进程的返回值是否为零来判断探测是否成功。\n两种探测的配置方法完全一样,支持的配置参数也一样。\n不同之处在于探测失败后的行为:Liveness 探测是重启容器;Readiness探测则是将容器设置为不可用,不接收Service转发的请求。\nLiveness探测和Readiness探测是独立执行的,二者之间没有依赖,所以可以单独使用,也可以同时使用。\n用Liveness探测判断容器是否需要重启以实现自愈;用Readiness探测判断容器是否已经准备好 对外提供服务\n5. pod 控制器 ​\tPod控制器是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时， 会尝试 进行重启，当根据重启策略无效，则会重新新建pod的资源。 创建为具体的控制器对象之后，每个控制器均通过 API Server 提供的接口持续监控相关资源对象 的当前状态，并在因故障、更新或其他原因导致系统状态发生变化时，尝试让资源的当前状态想期望状 态迁移和逼近。\n一个 Pod 控制器资源至少应该包含三个基本的组成部分：\n标签选择器：匹配并关联 Pod 资源对象，并据此完成受其管控的 Pod 资源计数。 期望的副本数：期望在集群中精确运行着的 Pod 资源的对象量。 Pod模板：用于新建 Pod 资源对象的 Pod 模板资源。 常见的控制器\nReplicaSet: 代用户创建指定数量的 pod 副本数量，确保 pod 副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能 Deployment: 工作在 ReplicaSet 之上，用于管理无状态应用，目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。 DaemonSet: 用于确保集群中的每一个节点只运行特定的 pod 副本，常用于实现系统级后台任务。比如 ELK 服务 1. ReplicaSet控制器 示例\n1 vi nginx-rs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 apiVersion: apps/v1 # api版本定义 kind: ReplicaSet # 定义资源类型为ReplicaSet metadata: name: nginx-rs # ReplicaSet的名称 namespace: default # 命名空间 spec: # ReplicaSet的规格定义 replicas: 2 # 定义副本数量为2个 selector: # 标签选择器，定义匹配Pod的标签 matchLabels: app: nginx template: # Pod的模板定义 metadata: # Pod的元数据定义 name: nginx-pod # 自定义Pod的名称 labels: # 定义Pod的标签 app: nginx #定义Pod的标签，需要和上面的标签选择器内匹配规则中定义的标签一致，可以多出其他标签 spec: # Pod的规格定义 containers: # 容器定义 - name: nginx # 容器名称 image: nginx:1.12 # 容器镜像 imagePullPolicy: IfNotPresent # 拉取镜像的规则 ports: # 暴露端口 - name: http # 端口名称 containerPort: 80 # 容器端口 创建rs 控制器\n1 kubectl apply -f nginx-rs.yaml 查看 rs 控制器\n1 kubectl get rs ==更新控制器一般来说都是修改配置文件 然后再apply==\n扩缩容, 使用scale 命令, (==用于临时的处理==), 永久的还是要使用配置文件\n1 kubectl scale replicasets nginx-rs --replicas=4 删除rs 控制器, 数 cascade=false 设置不删除pod\n1 kubectl delete replicasets nginx-rs --cascade=false 2. Deployment 控制器 1 vi nginx-deployment.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 更新策略\n滚动更新: 滚动更新是==默认的更新策略==，==它在删除一些旧版本的Pod的同时补充创建一些新的Pod，更新期间 服务不会中断==。 滚动更新期间，应用升级期间还要确保可用的Pod对象数量不低于某些阈值。确保可以持续处理客 户端请求。变动的方式和Pod对象的数量范围将通过==spec.strategy.roollingUpdata.maxSurge和 spec.strategy.roollingUpdata.maxunavailable两个属性协同进行定义。两个参数用法如下：\nmaxSurge：指定升级期间存在的总Pod对象数量最多以超出期望值的个数，其值可以为0或者正整 数，也可以是一个期望值的百分比：例如如果期望值是3，当前的属性值为1，则表示Pod对象的总 数不能超过4个。\nmaxUnavailable：升级期间正常可用的Pod副本数（包括新旧版本）最多不能低于期望的个数、其 值可以是0或者正整数。也可以是一个期望值的百分比，默认值为1；该值意味着如果期望值是3， 那么在升级期间至少要有两个Pod对象处于正常提供服务的状态\n==查看pod的版本号==\n1 kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image 重建更新: 先删除所有的Pod再根据新的模板创建新的Pod，中间会导致服务的不可用，用户要 么使用的是新版本，要么就是旧版本 执行回滚\n1 kubectl rollout undo deployment/nginx-deployment ==回滚只能在最近的两个版本之间回滚, 如果想要回滚到指定的节点需要加版本==\n1 kubectl rollout history deployment/nginx-deployment --revision=1 6. 数据存储 通过命令 kubectl explain pod.spec 可以查看 当前 kubernetes 版本支持的存储卷类型\n1. emptydir emptyDir 存储卷是 Pod 对象生命周期中的一个临时目录，类似于 Docker 上的 “docker 挂载\n卷” ，在 Pod 对象启动时即被创建，而在 Pod 对象被移除时会被一并删除（永久删除）。\n==一个容器崩溃了不会导致数据的丢失，因为容器的崩溃并不移除 Pod==。\n2. hostpath 半持久化, 需要配合nfs 使用\n7. service Kubernetes service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 ——\n通常称为微服务。这一组 pod 能够被 Service 访问到，通常是通过 Label selector\nService 资源基于标签选择器将一组 Pod 定义成一个逻辑组合，并通过自己的 IP 地址和端口调度代理请求至组内的 Pod 对象之上，如下图所示，它向客户端隐藏了真实的、处理用户请求的 Pod 资源， 使得客户端的请求看上去就像是由 Service 直接处理并响应一样。 service 的 ip 也被称作为 cluster-ip\nService能够提供负载均衡的能力，但是在使用上有以下限制：\n只提供4层负载均衡能力，而没有7层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上4层负载均衡是不支持的\n客户端只需要访问 Service 的 IP，==Kubernetes 则负责建立和维护 Service 与 Pod 的映射关系==。 无论后端 Pod 如何变化，对客户端不会有任何影响，因为 Service 没有变 service 的 类型\nClusterlp：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟 IP\nNodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过： NodePort 来访问该服务\nLoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到：NodePort\nExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理\n被创建，这只有kubernetes 1.7或更高版本的 kube-dns 才支持\n1. clusterIp 类型为ClusterIP的service，这个service有一个Cluster-IP，其实就一个VIP，具体实现原理依靠\nkubeproxy组件，通过iptables或是ipvs实现。\n==注意：这种类型的service只能在集群内访问==\n2. NodePort NodePort的最主要功能是进行外网访问，我们是不能通过访问 8000 端口访问的，他是内网端\n口，外网访问需要访问映射出来的端口 8000:31337/TCP 这里映射出来的 nodeport 是 31337 ，\n还可以通过指定 nodePort 来指定端口，要求端口必须大于30000\n","date":"2024-12-31T17:01:24+08:00","permalink":"https://mikeLing-qx.github.io/p/image-test/","title":"Image Test"},{"content":"Spring相关教程/资料 官网相关 Spring官网、Spring系列主要项目、Spring官网指南、官方文档 spring-framework-reference Spring Framework 4.3.17.RELEASE API 系统学习教程 文档 极客学院Spring Wiki Spring W3Cschool教程 视频 网易云课堂——58集精通java教程Spring框架开发\n慕课网相关视频\n黑马视频和尚硅谷视频（非常推荐）： 微信公众号：“JavaGuide”后台回复关键字 “1” 免费领取。\n面试必备知识点 SpringAOP,IOC实现原理 AOP实现原理、动态代理和静态代理、Spring IOC的初始化过程、IOC原理、自己实现怎么实现一个IOC容器？这些东西都是经常会被问到的。\n推荐阅读：\n自己动手实现的 Spring IOC 和 AOP - 上篇\n自己动手实现的 Spring IOC 和 AOP - 下篇\nAOP AOP思想的实现一般都是基于 代理模式 ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。\n如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类； 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。 推荐阅读：\n静态代理、JDK动态代理、CGLIB动态代理讲解 ：我们知道AOP思想的实现一般都是基于 代理模式 ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。 Spring AOP 入门 ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理， Spring AOP 基于AspectJ注解如何实现AOP ： AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器），可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。 探秘Spring AOP（慕课网视频，很不错）:慕课网视频，讲解的很不错，详细且深入 spring源码剖析（六）AOP实现原理剖析 :通过源码分析Spring AOP的原理 IOC [Spring框架]Spring IOC的原理及详解。 Spring IOC核心源码学习 :比较简短，推荐阅读。 Spring IOC 容器源码分析 :强烈推荐，内容详尽，而且便于阅读。 Bean初始化过程 Spring事务管理 可能是最漂亮的Spring事务管理详解 Spring编程式和声明式事务实例讲解 Spring单例与线程安全 Spring框架中的单例模式（源码解读）:单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例。spring依赖注入时，使用了 多重判断加锁 的单例模式。 Spring源码阅读 阅读源码不仅可以加深我们对Spring设计思想的理解，提高自己的编码水平，还可以让自己在面试中如鱼得水。下面的是Github上的一个开源的Spring源码阅读，大家有时间可以看一下，当然你如果有时间也可以自己慢慢研究源码。\nspring-core spring-aop spring-context spring-task spring-transaction spring-mvc guava-cache ","date":"2024-12-31T16:42:10+08:00","permalink":"https://mikeLing-qx.github.io/p/spring/","title":"Spring"}]